diff -ruNa TC4_Kernel_3.0/arch/arm/configs/tc4_dvt_ics_cdc_acm_defconfig modem/arch/arm/configs/tc4_dvt_ics_cdc_acm_defconfig
--- TC4_Kernel_3.0/arch/arm/configs/tc4_dvt_ics_cdc_acm_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ modem/arch/arm/configs/tc4_dvt_ics_cdc_acm_defconfig	2012-07-04 15:30:18.000000000 +0800
@@ -0,0 +1,2911 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 3.0.15 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_HAVE_PWM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_NO_IOPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_LOCKBREAK=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+# CONFIG_KERNEL_PANIC_DUMP is not set
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_CHIP=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
+# CONFIG_AIO is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+CONFIG_ARCH_EXYNOS=y
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+CONFIG_IOMMU_API=y
+CONFIG_PLAT_SAMSUNG=y
+
+#
+# Boot options
+#
+# CONFIG_S3C_BOOT_WATCHDOG is not set
+# CONFIG_S3C_BOOT_ERROR_RESET is not set
+CONFIG_S3C_BOOT_UART_FORCE_FIFO=y
+CONFIG_S3C_LOWLEVEL_UART_PORT=2
+CONFIG_SAMSUNG_CLKSRC=y
+CONFIG_SAMSUNG_IRQ_VIC_TIMER=y
+CONFIG_SAMSUNG_IRQ_UART=y
+CONFIG_SAMSUNG_GPIOLIB_4BIT=y
+CONFIG_S3C_GPIO_CFG_S3C24XX=y
+CONFIG_S3C_GPIO_CFG_S3C64XX=y
+CONFIG_S3C_GPIO_PULL_UPDOWN=y
+CONFIG_S5P_GPIO_DRVSTR=y
+CONFIG_SAMSUNG_GPIO_EXTRA=0
+CONFIG_S3C_GPIO_SPACE=0
+CONFIG_S3C_GPIO_TRACK=y
+# CONFIG_S3C_ADC is not set
+CONFIG_S3C_DEV_HSMMC2=y
+CONFIG_S3C_DEV_HSMMC3=y
+CONFIG_S5P_DEV_MSHC=y
+CONFIG_S3C_DEV_I2C1=y
+CONFIG_S3C_DEV_I2C2=y
+CONFIG_S3C_DEV_I2C3=y
+CONFIG_S3C_DEV_I2C4=y
+CONFIG_S3C_DEV_I2C5=y
+CONFIG_S3C_DEV_I2C6=y
+CONFIG_S3C_DEV_I2C7=y
+CONFIG_S3C_DEV_WDT=y
+CONFIG_S3C_DEV_RTC=y
+CONFIG_SAMSUNG_DEV_ADC=y
+CONFIG_SAMSUNG_DEV_KEYPAD=y
+CONFIG_SAMSUNG_DEV_PWM=y
+CONFIG_SAMSUNG_DEV_BACKLIGHT=y
+CONFIG_S3C24XX_PWM=y
+CONFIG_S3C_PL330_DMA=y
+# CONFIG_DMA_M2M_TEST is not set
+
+#
+# Power management
+#
+# CONFIG_SAMSUNG_PM_DEBUG is not set
+# CONFIG_SAMSUNG_PM_CHECK is not set
+
+#
+# Power Domain
+#
+CONFIG_SAMSUNG_PD=y
+CONFIG_PLAT_S5P=y
+CONFIG_S5P_GPIO_INT=y
+
+#
+# System MMU
+#
+CONFIG_S5P_SYSTEM_MMU=y
+CONFIG_S3C_DEV_FIMC=y
+CONFIG_S5P_DEV_I2C_HDMIPHY=y
+CONFIG_S5P_DEV_MFC=y
+CONFIG_S5P_DEV_FIMD0=y
+CONFIG_S5P_DEV_TVOUT=y
+CONFIG_S5P_DEV_FIMG2D=y
+CONFIG_S5P_DEV_CSIS=y
+CONFIG_S5P_DEV_CSIS0=y
+CONFIG_S5P_DEV_CSIS1=y
+CONFIG_S5P_DEV_JPEG=y
+CONFIG_S5P_DEV_USB_EHCI=y
+CONFIG_S5P_DEV_FIMD_S5P=y
+CONFIG_S5P_DEV_USBGADGET=y
+CONFIG_S5P_DEV_USB_SWITCH=y
+CONFIG_S5P_SETUP_MIPIPHY=y
+CONFIG_S5P_MEM_CMA=y
+CONFIG_S5P_DEV_THERMAL=y
+CONFIG_ARCH_EXYNOS4=y
+# CONFIG_ARCH_EXYNOS5 is not set
+CONFIG_CPU_EXYNOS4212=y
+CONFIG_CPU_EXYNOS4412=y
+# CONFIG_EXYNOS4_CONTENT_PATH_PROTECTION is not set
+CONFIG_TC4_ICS=y
+# CONFIG_TC4_GB is not set
+CONFIG_TC4_DVT=y
+# CONFIG_TC4_EVT is not set
+CONFIG_TC4_AP1_0=y
+# CONFIG_TC4_AP1_1 is not set
+CONFIG_EXYNOS4_PM=y
+CONFIG_EXYNOS4_CPUIDLE=y
+CONFIG_EXYNOS_MCT=y
+CONFIG_EXYNOS4_SETUP_FIMD0=y
+CONFIG_EXYNOS_DEV_PD=y
+# CONFIG_EXYNOS4_DEV_DWMCI is not set
+CONFIG_EXYNOS4_DEV_FIMC_LITE=y
+CONFIG_EXYNOS4_DEV_FIMC_IS=y
+CONFIG_EXYNOS4_SETUP_I2C1=y
+CONFIG_EXYNOS4_SETUP_I2C2=y
+CONFIG_EXYNOS4_SETUP_I2C3=y
+CONFIG_EXYNOS4_SETUP_I2C4=y
+CONFIG_EXYNOS4_SETUP_I2C5=y
+CONFIG_EXYNOS4_SETUP_I2C6=y
+CONFIG_EXYNOS4_SETUP_I2C7=y
+CONFIG_EXYNOS4_SETUP_KEYPAD=y
+CONFIG_EXYNOS4_SETUP_MFC=y
+CONFIG_EXYNOS4_SETUP_SDHCI=y
+CONFIG_EXYNOS4_SETUP_SDHCI_GPIO=y
+CONFIG_EXYNOS4_SETUP_MSHCI=y
+CONFIG_EXYNOS4_SETUP_MSHCI_GPIO=y
+CONFIG_EXYNOS4_SETUP_FIMC0=y
+CONFIG_EXYNOS4_SETUP_FIMC1=y
+CONFIG_EXYNOS4_SETUP_FIMC2=y
+CONFIG_EXYNOS4_SETUP_FIMC3=y
+CONFIG_EXYNOS4_SETUP_FIMC_IS=y
+CONFIG_EXYNOS4_SETUP_USB_PHY=y
+CONFIG_EXYNOS4_SETUP_CSIS=y
+CONFIG_EXYNOS4_SETUP_FB_S5P=y
+CONFIG_EXYNOS4_SETUP_TVOUT=y
+CONFIG_EXYNOS_SETUP_THERMAL=y
+# CONFIG_TMU_DEBUG is not set
+CONFIG_EXYNOS4_SETUP_JPEG=y
+CONFIG_EXYNOS4_ENABLE_CLOCK_DOWN=y
+CONFIG_EXYNOS4_CPUFREQ=y
+# CONFIG_EXYNOS4X12_1500MHZ_SUPPORT is not set
+CONFIG_EXYNOS4X12_1400MHZ_SUPPORT=y
+# CONFIG_EXYNOS4X12_1200MHZ_SUPPORT is not set
+
+#
+# Support dynamic CPU Hotplug
+#
+CONFIG_EXYNOS_PM_HOTPLUG=y
+# CONFIG_STAND_ALONE_POLICY is not set
+# CONFIG_WITH_DVFS_POLICY is not set
+CONFIG_DVFS_NR_RUNNING_POLICY=y
+# CONFIG_NR_RUNNING_POLICY is not set
+# CONFIG_BUSFREQ_NONE is not set
+# CONFIG_BUSFREQ is not set
+CONFIG_BUSFREQ_OPP=y
+
+#
+# EXYNOS4 Machines
+#
+# CONFIG_MACH_SMDKC210 is not set
+# CONFIG_MACH_SMDKV310 is not set
+# CONFIG_MACH_ARMLEX4210 is not set
+# CONFIG_MACH_UNIVERSAL_C210 is not set
+# CONFIG_MACH_NURI is not set
+CONFIG_MACH_SMDK4X12=y
+CONFIG_USE_GPIO_AS_I2C=y
+
+#
+# MMC/SD slot setup
+#
+
+#
+# SELECT SYNOPSYS CONTROLLER INTERFACE DRIVER
+#
+CONFIG_EXYNOS4_MSHC_MPLL_40MHZ=y
+# CONFIG_EXYNOS4_MSHC_VPLL_46MHZ is not set
+# CONFIG_EXYNOS4_MSHC_EPLL_45MHZ is not set
+
+#
+# Use 8-bit bus width
+#
+CONFIG_EXYNOS4_MSHC_8BIT=y
+# CONFIG_EXYNOS4_SDHCI_CH2_8BIT is not set
+
+#
+# Use DDR
+#
+# CONFIG_EXYNOS4_MSHC_DDR is not set
+
+#
+# Miscellaneous drivers
+#
+# CONFIG_WAKEUP_ASSIST is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_TRUSTZONE=y
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_CPU_HAS_PMU=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_PL310_ERRATA_588369 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_720791 is not set
+# CONFIG_PL310_ERRATA_727915 is not set
+CONFIG_ARM_ERRATA_743622=y
+CONFIG_ARM_ERRATA_751472=y
+# CONFIG_ARM_ERRATA_753970 is not set
+CONFIG_ARM_ERRATA_754322=y
+# CONFIG_ARM_ERRATA_754327 is not set
+CONFIG_ARM_ERRATA_761320=y
+# CONFIG_ARM_ERRATA_761171 is not set
+# CONFIG_ARM_ERRATA_762974 is not set
+# CONFIG_ARM_ERRATA_763722 is not set
+CONFIG_ARM_GIC=y
+CONFIG_PL330=y
+# CONFIG_FIQ_DEBUGGER is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+CONFIG_ARM_ERRATA_764369=y
+# CONFIG_PL310_ERRATA_769419 is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+CONFIG_LOCAL_TIMERS=y
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=200
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+# CONFIG_HAVE_ARCH_PFN_VALID is not set
+CONFIG_ARCH_SKIP_SECONDARY_CALIBRATE=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEVELOPEMENT is not set
+CONFIG_CMA_BEST_FIT=y
+CONFIG_FORCE_MAX_ZONEORDER=12
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+# CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttySAC2,115200"
+# CONFIG_CMDLINE_FROM_BOOTLOADER is not set
+CONFIG_CMDLINE_EXTEND=y
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ADAPTIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_ADAPTIVE=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_HAS_OPP=y
+CONFIG_PM_OPP=y
+CONFIG_PM_RUNTIME_CLK=y
+# CONFIG_SUSPEND_TIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_NET_ACTIVITY_STATS=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_LOG=y
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_NF_CONNTRACK_IPV6=y
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_PHONET=y
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+CONFIG_NET_SCH_INGRESS=y
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CLS_U32_MARK is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+CONFIG_NET_EMATCH_U32=y
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+# CONFIG_GACT_PROB is not set
+CONFIG_NET_ACT_MIRRED=y
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+# CONFIG_BT_HIDP is not set
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_BT_HCIUART_LL=y
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+CONFIG_ANDROID_PMEM=y
+
+#
+# Reserved memory configurations
+#
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM=4096
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_GPU1=10240
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+CONFIG_UID_STAT=y
+# CONFIG_BMP085 is not set
+# CONFIG_APANIC is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+CONFIG_MPU_SENSORS_TIMERIRQ=y
+CONFIG_INV_SENSORS=y
+CONFIG_MPU_SENSORS_MPU3050_ICS=y
+# CONFIG_MPU_SENSORS_MPU6050A2_ICS is not set
+# CONFIG_MPU_SENSORS_MPU6050B1_ICS is not set
+CONFIG_MPU_SENSORS_MPU3050_GYRO=y
+CONFIG_INV_SENSORS_ACCELEROMETERS=y
+# CONFIG_MPU_SENSORS_ADXL34X is not set
+# CONFIG_MPU_SENSORS_BMA222_ICS is not set
+# CONFIG_MPU_SENSORS_BMA150_ICS is not set
+CONFIG_MPU_SENSORS_BMA250_ICS=y
+# CONFIG_MPU_SENSORS_KXSD9_ICS is not set
+# CONFIG_MPU_SENSORS_KXTF9_ICS is not set
+# CONFIG_MPU_SENSORS_LIS331DLH_ICS is not set
+# CONFIG_MPU_SENSORS_LIS3DH_ICS is not set
+# CONFIG_MPU_SENSORS_LSM303DLX_A_ICS is not set
+# CONFIG_MPU_SENSORS_MMA8450_ICS is not set
+# CONFIG_MPU_SENSORS_MMA845X_ICS is not set
+CONFIG_INV_SENSORS_COMPASS=y
+# CONFIG_MPU_SENSORS_AK8975_ICS is not set
+# CONFIG_MPU_SENSORS_AK8972_ICS is not set
+# CONFIG_MPU_SENSORS_MMC314X_ICS is not set
+# CONFIG_MPU_SENSORS_AMI30X_ICS is not set
+# CONFIG_MPU_SENSORS_AMI306_ICS is not set
+CONFIG_MPU_SENSORS_HMC5883_ICS=y
+# CONFIG_MPU_SENSORS_LSM303DLX_M_ICS is not set
+# CONFIG_MPU_SENSORS_MMC314XMS_ICS is not set
+# CONFIG_MPU_SENSORS_YAS530_ICS is not set
+# CONFIG_MPU_SENSORS_HSCDTD002B_ICS is not set
+# CONFIG_MPU_SENSORS_HSCDTD004A_ICS is not set
+# CONFIG_INV_SENSORS_PRESSURE is not set
+# CONFIG_MPU_USERSPACE_DEBUG is not set
+CONFIG_TC4_PORTRAIT_MODE=y
+# CONFIG_SAMSUNG_C2C is not set
+CONFIG_SNFC=y
+# CONFIG_SNFC_I2C is not set
+CONFIG_SNFC_I2C_GPIO=y
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+CONFIG_DM_UEVENT=y
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_IFB is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_MII is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_NET_ETHERNET is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NETDEV_10000=y
+CONFIG_WLAN=y
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_WIFI_CONTROL_FUNC is not set
+# CONFIG_BCM4329 is not set
+# CONFIG_BCMDHD is not set
+# CONFIG_HOSTAP is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_CDC_PHONET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_NET_RAW_IP is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+CONFIG_INPUT_KEYRESET=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+CONFIG_KEYBOARD_SAMSUNG=y
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=y
+CONFIG_TABLET_USB_AIPTEK=y
+CONFIG_TABLET_USB_GTCO=y
+CONFIG_TABLET_USB_HANWANG=y
+CONFIG_TABLET_USB_KBTAB=y
+CONFIG_TABLET_USB_WACOM=y
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_EXYNOS4 is not set
+CONFIG_TOUCHSCREEN_EGALAX=y
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+CONFIG_INPUT_KEYCHORD=y
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+CONFIG_RMNET=y
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_CONSOLE is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_UARTS_4=y
+CONFIG_SERIAL_SAMSUNG_UARTS=4
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+CONFIG_SERIAL_S5PV210=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_S3C_MEM=y
+CONFIG_EXYNOS_MEM=y
+CONFIG_GPS_PM=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_SMBUS is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+CONFIG_I2C_GPIO=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+CONFIG_HAVE_S3C2410_I2C=y
+CONFIG_I2C_S3C2410=y
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSOR_ROHM_BH1721 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_GPIO=y
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_S3C64XX is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+# CONFIG_GPIO_SMM6260 is not set
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_BASIC_MMIO is not set
+# CONFIG_GPIO_IT8761E is not set
+CONFIG_GPIO_EXYNOS4=y
+CONFIG_GPIO_PLAT_SAMSUNG=y
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_WM8994 is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+CONFIG_VIBRATOR=y
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ20Z75 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+CONFIG_BATTERY_MAX17040=y
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_BATTERY_SAMSUNG is not set
+# CONFIG_BATTERY_MAX8997 is not set
+CONFIG_CHARGER_MAX8903=y
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_HAVE_S3C2410_WATCHDOG=y
+CONFIG_S3C2410_WATCHDOG=y
+# CONFIG_MAX63XX_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+CONFIG_MFD_SUPPORT=y
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MAX8698 is not set
+# CONFIG_MFD_MAX77686 is not set
+CONFIG_MFD_S5M_CORE=y
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+CONFIG_MFD_WM8994=y
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65910 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+CONFIG_REGULATOR_S5M8767=y
+CONFIG_REGULATOR_WM8994=y
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+CONFIG_RC_CORE=y
+CONFIG_LIRC=y
+CONFIG_RC_MAP=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_IR_RC5_SZ_DECODER=y
+CONFIG_IR_LIRC_CODEC=y
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_RC_LOOPBACK is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+
+#
+# Customize TV tuners
+#
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_V4L2_MEM2MEM_DEV=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_CMA_PHYS=y
+# CONFIG_VIDEOBUF2_ION is not set
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_FIXED_MINOR_RANGES=y
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+CONFIG_VIDEO_IR_I2C=y
+
+#
+# Encoders, decoders, sensors and other helper chips
+#
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+# CONFIG_VIDEO_S5K3H2 is not set
+# CONFIG_VIDEO_S5K3H7 is not set
+# CONFIG_VIDEO_S5K4E5 is not set
+# CONFIG_VIDEO_S5K6A3 is not set
+CONFIG_VIDEO_M5MO=y
+# CONFIG_VIDEO_S5K4EA is not set
+# CONFIG_CSI_C is not set
+CONFIG_CSI_D=y
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_AK881X is not set
+
+#
+# Camera sensor devices
+#
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_MT9V032 is not set
+# CONFIG_VIDEO_TCM825X is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+
+#
+# Miscelaneous helper chips
+#
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_VIDEO_M5MOLS is not set
+CONFIG_SOC_CAMERA=y
+# CONFIG_SOC_CAMERA_IMX074 is not set
+# CONFIG_SOC_CAMERA_MT9M001 is not set
+# CONFIG_SOC_CAMERA_MT9M111 is not set
+# CONFIG_SOC_CAMERA_MT9T031 is not set
+# CONFIG_SOC_CAMERA_MT9T112 is not set
+CONFIG_SOC_CAMERA_MT9D115=y
+CONFIG_VIDEO_S5K4ECGX=y
+# CONFIG_VIDEO_S5K4ECGX_DEBUG is not set
+CONFIG_VIDEO_S5K4ECGX_V_1_1=y
+# CONFIG_SOC_CAMERA_MT9V022 is not set
+# CONFIG_SOC_CAMERA_RJ54N1 is not set
+# CONFIG_SOC_CAMERA_TW9910 is not set
+# CONFIG_SOC_CAMERA_PLATFORM is not set
+# CONFIG_SOC_CAMERA_OV2640 is not set
+# CONFIG_SOC_CAMERA_OV6650 is not set
+# CONFIG_SOC_CAMERA_OV772X is not set
+# CONFIG_SOC_CAMERA_OV9640 is not set
+# CONFIG_SOC_CAMERA_OV9740 is not set
+# CONFIG_VIDEO_SH_MOBILE_CSI2 is not set
+# CONFIG_VIDEO_SH_MOBILE_CEU is not set
+# CONFIG_VIDEO_SAMSUNG_S5P_FIMC is not set
+# CONFIG_VIDEO_S5P_MIPI_CSIS is not set
+CONFIG_SAMSUNG_MFC_DRIVERS=y
+CONFIG_USE_LEGACY_MFC=y
+# CONFIG_USE_V4L2_MFC is not set
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_VIDEO_SAMSUNG=y
+CONFIG_VIDEO_SAMSUNG_V4L2=y
+CONFIG_VIDEO_FIMC=y
+CONFIG_VIDEO_FIMC_RANGE_NARROW=y
+# CONFIG_VIDEO_FIMC_RANGE_WIDE is not set
+# CONFIG_VIDEO_FIMC_DEBUG is not set
+CONFIG_VIDEO_FIMC_MIPI=y
+CONFIG_VIDEO_FIMC_DMA_AUTO=y
+# CONFIG_VIDEO_FIMC_FIFO is not set
+CONFIG_VIDEO_TVOUT=y
+CONFIG_VIDEO_TVOUT_2CH_AUDIO=y
+# CONFIG_VIDEO_TVOUT_5_1CH_AUDIO is not set
+CONFIG_HDMI_CEC=y
+CONFIG_HDMI_HPD=y
+CONFIG_HDMI_14A_3D=y
+CONFIG_HDMI_PHY_32N=y
+CONFIG_TV_FB=y
+CONFIG_USER_ALLOC_TVOUT=y
+# CONFIG_TV_DEBUG is not set
+CONFIG_VIDEO_MFC5X=y
+CONFIG_VIDEO_MFC_MAX_INSTANCE=4
+CONFIG_VIDEO_MFC_MEM_PORT_COUNT=2
+# CONFIG_VIDEO_MFC5X_DEBUG is not set
+CONFIG_VIDEO_FIMG2D=y
+# CONFIG_VIDEO_FIMG2D_DEBUG is not set
+CONFIG_VIDEO_FIMG2D4X=y
+# CONFIG_VIDEO_FIMG2D4X_DEBUG is not set
+CONFIG_VIDEO_UMP=y
+# CONFIG_UMP_DED_ONLY is not set
+CONFIG_UMP_OSMEM_ONLY=y
+# CONFIG_UMP_VCM_ONLY is not set
+CONFIG_UMP_MEM_SIZE=512
+# CONFIG_VIDEO_UMP_DEBUG is not set
+CONFIG_VIDEO_MALI400MP=y
+# CONFIG_MALI_DED_ONLY is not set
+# CONFIG_MALI_DED_MMU is not set
+CONFIG_MALI_OSMEM_ONLY=y
+# CONFIG_MALI_DED_OSMEM is not set
+# CONFIG_VIDEO_MALI400MP_DEBUG is not set
+CONFIG_VIDEO_MALI400MP_DVFS=y
+# CONFIG_VIDEO_JPEG_DEBUG is not set
+CONFIG_VIDEO_JPEG_V2X=y
+
+#
+# Reserved memory configurations
+#
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC0=32768
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC1=32768
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC2=32768
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC3=58368
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC0=41984
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC1=41984
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_JPEG=40960
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMG2D=8192
+CONFIG_VIDEO_EXYNOS=y
+CONFIG_EXYNOS_MEDIA_DEVICE=y
+CONFIG_VIDEO_EXYNOS_FIMC_LITE=y
+CONFIG_VIDEO_EXYNOS_MIPI_CSIS=y
+# CONFIG_VIDEO_EXYNOS_TV is not set
+# CONFIG_VIDEO_EXYNOS_ROTATOR is not set
+CONFIG_VIDEO_EXYNOS_FIMC_IS=y
+# CONFIG_VIDEO_EXYNOS_FIMC_IS_BAYER is not set
+CONFIG_VIDEO_EXYNOS_MEMSIZE_FIMC_IS=10240
+CONFIG_MEDIA_EXYNOS=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+# CONFIG_VIDEO_MEM2MEM_TESTDEV is not set
+# CONFIG_RADIO_ADAPTERS is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+CONFIG_ION=y
+CONFIG_ION_EXYNOS=y
+CONFIG_ION_EXYNOS_CONTIGHEAP_SIZE=45056
+# CONFIG_VITHAR is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_S5P=y
+CONFIG_FB_S5P_SPLASH_SCREEN=y
+CONFIG_FB_S5P_LCD_INIT=y
+# CONFIG_FB_S5P_DEBUG is not set
+# CONFIG_FB_S5P_TRACE_UNDERRUN is not set
+CONFIG_FB_S5P_DEFAULT_WINDOW=2
+CONFIG_FB_S5P_NR_BUFFERS=2
+# CONFIG_FB_S5P_VIRTUAL is not set
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMD=24576
+# CONFIG_FB_S5P_MIPI_DSIM is not set
+CONFIG_FB_S5P_WA101S=y
+# CONFIG_FB_S5P_LMS501KF03 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_S3C is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_MIPI_S6E63M0 is not set
+# CONFIG_LCD_MIPI_S6E8AB0 is not set
+# CONFIG_LCD_MIPI_TC358764 is not set
+# CONFIG_LCD_LD9040 is not set
+CONFIG_LCD_WA101S=y
+# CONFIG_LCD_LTE480WV is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_PWM=y
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_CACHE_LZO is not set
+CONFIG_SND_SOC_SAMSUNG=y
+CONFIG_SND_SAMSUNG_I2S=y
+CONFIG_SND_SOC_SAMSUNG_SMDK_WM8994=y
+# CONFIG_SND_SOC_WM8994_MEIZU_ARCH is not set
+# CONFIG_SND_SAMSUNG_NORMAL is not set
+# CONFIG_SND_SAMSUNG_LP is not set
+# CONFIG_SND_SAMSUNG_ALP is not set
+CONFIG_SND_SAMSUNG_RP=y
+CONFIG_AUDIO_SAMSUNG_MEMSIZE_SRP=1024
+# CONFIG_SND_SAMSUNG_RP_DEBUG is not set
+CONFIG_SND_SAMSUNG_I2S_MASTER=y
+# CONFIG_SND_SOC_SAMSUNG_SMDK_WM8994_PCM is not set
+# CONFIG_SND_SOC_SAMSUNG_SMDK_WM9713 is not set
+# CONFIG_SND_SOC_SAMSUNG_SMDK_SPDIF is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_WM_HUBS=y
+CONFIG_SND_SOC_WM8994=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWII_FF=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+# CONFIG_HID_PICOLCD_FB is not set
+# CONFIG_HID_PICOLCD_BACKLIGHT is not set
+# CONFIG_HID_PICOLCD_LCD is not set
+CONFIG_HID_QUANTA=y
+CONFIG_HID_ROCCAT=y
+CONFIG_HID_ROCCAT_COMMON=y
+CONFIG_HID_ROCCAT_ARVO=y
+CONFIG_HID_ROCCAT_KONE=y
+CONFIG_HID_ROCCAT_KONEPLUS=y
+CONFIG_HID_ROCCAT_KOVAPLUS=y
+CONFIG_HID_ROCCAT_PYRA=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_S5P=y
+CONFIG_USB_S5P_HSIC0=y
+# CONFIG_USB_S5P_HSIC1 is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=y
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EXYNOS_SWITCH is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_FUSB300 is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+CONFIG_USB_GADGET_S3C_OTGD=y
+# CONFIG_USB_GADGET_PXA_U2O is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+
+#
+# NOTE: S3C OTG device role enables the controller driver below
+#
+CONFIG_USB_S3C_OTGD=y
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_G_ANDROID=y
+# CONFIG_USB_ANDROID is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_NOKIA is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_OTG_WAKELOCK is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_CLKGATE=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_MSHCI=y
+CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_PLTFM is not set
+CONFIG_MMC_SDHCI_S3C=y
+# CONFIG_MMC_SDHCI_S3C_DMA is not set
+CONFIG_MMC_DW=y
+# CONFIG_MMC_DW_IDMAC is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_NFC_DEVICES is not set
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=y
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc1"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+CONFIG_RTC_DRV_S5M=y
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_HAVE_S3C_RTC=y
+CONFIG_RTC_DRV_S3C=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_VIDEO_TM6000 is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_ECHO is not set
+# CONFIG_BRCMUTIL is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_R8712U is not set
+# CONFIG_TRANZPORT is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
+# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+# CONFIG_POHMELFS is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_VT6656 is not set
+# CONFIG_IIO is not set
+# CONFIG_XVMALLOC is not set
+# CONFIG_ZRAM is not set
+# CONFIG_FB_SM7XX is not set
+# CONFIG_LIRC_STAGING is not set
+# CONFIG_EASYCAP is not set
+CONFIG_MACH_NO_WESTBRIDGE=y
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_SMM6260_PHONE=y
+CONFIG_SMM6260_MODEM=y
+# CONFIG_MODEM_BOOT_IN_UBOOT is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_CPU_NOTIFIER_ERROR_INJECT is not set
+# CONFIG_FAULT_INJECTION is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_LL is not set
+# CONFIG_OC_ETM is not set
+CONFIG_DEBUG_S3C_UART=1
+# CONFIG_CACHE_PERF is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_PCBC=y
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_S5P_DEV_ACE is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_NLATTR=y
+# CONFIG_AVERAGE is not set
diff -ruNa TC4_Kernel_3.0/arch/arm/mach-exynos/cpuidle-exynos4.c modem/arch/arm/mach-exynos/cpuidle-exynos4.c
--- TC4_Kernel_3.0/arch/arm/mach-exynos/cpuidle-exynos4.c	2012-05-15 15:08:08.000000000 +0800
+++ modem/arch/arm/mach-exynos/cpuidle-exynos4.c	2012-07-04 15:30:18.000000000 +0800
@@ -287,7 +287,6 @@
 	if (exynos4_check_usb_op())
 		return 1;
 #endif
-
 	return 0;
 }
 
@@ -638,6 +637,25 @@
 	return ret;
 }
 
+static int exynos4_is_hsic_suspended(void)
+{
+	u32 suspended;
+
+	suspended = readl(EXYNOS4_PHYPWR) & EXYNOS4212_HSIC0_FORCE_SUSPEND;
+	
+	if (suspended)
+	{
+		//printk("hsic_suspended 1");
+		return 1;
+	}
+	else
+	{
+		//printk("hsic_suspended 0");
+		return 0;  
+	}
+}
+
+
 static int exynos4_enter_lowpower(struct cpuidle_device *dev,
 				  struct cpuidle_state *state)
 {
@@ -657,7 +675,7 @@
 		__raw_writel(tmp, S5P_CENTRAL_SEQ_OPTION);
 	}
 
-	if (new_state == &dev->states[0])
+	if ((new_state == &dev->states[0]) || exynos4_is_hsic_suspended() == 0)
 		return exynos4_enter_idle(dev, new_state);
 
 	enter_mode = exynos4_check_entermode();
diff -ruNa TC4_Kernel_3.0/arch/arm/mach-exynos/include/mach/modem.h modem/arch/arm/mach-exynos/include/mach/modem.h
--- TC4_Kernel_3.0/arch/arm/mach-exynos/include/mach/modem.h	1970-01-01 08:00:00.000000000 +0800
+++ modem/arch/arm/mach-exynos/include/mach/modem.h	2012-07-04 15:30:18.000000000 +0800
@@ -0,0 +1,75 @@
+/* linux/arch/arm/mach-s5pv310/include/mach/modem.h
+ *
+ * Copyright (c) 2011 Samsung Electronics Co.Ltd
+ *		
+ *
+ *
+ * Based on arch/arm/mach-s5p6442/include/mach/io.h
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __MODEM_H
+#define __MODEM_H
+
+#define GPIO_PHONE_ON		EXYNOS4_GPC0(0)	//power on cp
+#define GPIO_PHONE_ACTIVE	S5PV310_GPX0(7)	// NC
+#define GPIO_PDA_ACTIVE		S5PV310_GPK1(0)	// NC
+#define GPIO_CP_DUMP_INT	S5PV310_GPL0(5)	// NC
+#define GPIO_CP_RST			EXYNOS4_GPL2(1)	//reset cp
+#define GPIO_CP_PMU_RST	EXYNOS4_GPC0(2)	//reset cp pmu
+#define GPIO_CP_REQ_RST	S5PV310_GPL0(6)	// NC
+#define GPIO_CP_ABNORMAL_RESET_INT	S5PV310_GPX1(3)	//NC lisw //cp -> ap abnormal reset
+#define GPIO_IPC_SLAVE_WAKEUP	EXYNOS4_GPC0(4)	//ap -> cp wakeup slave
+#define GPIO_IPC_HOST_WAKEUP	EXYNOS4_GPX2(5)	//cp -> ap wakeup host
+#define GPIO_SUSPEND_REQUEST	EXYNOS4_GPX1(6)	//cp -> ap request sleep
+#define GPIO_ISP_INT		S5PV310_GPL0(7)	// NC
+#define GPIO_ACTIVE_STATE	EXYNOS4_GPC0(3)		//ap active state
+#define GPIO_CP_RESET_REPORT	EXYNOS4_GPX3(2)		//CP reset ,CP->AP
+
+#define GPIO_XUJIE_MONITOR    EXYNOS4_GPL2(6)		//test
+
+#define IRQ_PHONE_ACTIVE	IRQ_EINT7 //NC
+#define IRQ_SUSPEND_REQUEST	IRQ_EINT12
+#define IRQ_IPC_HOST_WAKEUP	IRQ_EINT14
+
+#define HOST_WUP_LEVEL 0
+
+struct modem_ops {
+	void (*modem_on)(void);
+	void (*modem_off)(void);
+	void (*modem_reset)(void);
+	void (*modem_boot)(void);
+	void (*modem_suspend)(void);
+	void (*modem_resume)(void);
+	void (*modem_cfg)(void);
+};
+
+struct modem_platform_data {
+	const char *name;
+	unsigned gpio_phone_on;
+	unsigned gpio_phone_active;
+	unsigned gpio_pda_active;
+	unsigned gpio_cp_reset;
+	unsigned gpio_usim_boot;
+	unsigned gpio_flm_sel;
+	unsigned gpio_cp_req_reset;	/*HSIC*/
+	unsigned gpio_ipc_slave_wakeup;
+	unsigned gpio_ipc_host_wakeup;
+	unsigned gpio_suspend_request;
+	unsigned gpio_active_state;
+	unsigned gpio_cp_dump_int;
+	unsigned gpio_cp_reset_int;
+	int wakeup;
+	struct modem_ops ops;
+};
+
+extern struct platform_device smm6260_modem;
+extern int smm6260_is_on(void);
+extern int smm6260_is_host_wakeup(void);
+extern int smm6260_set_active_state(int val);
+extern int smm6260_set_slave_wakeup(int val);
+#endif//__MODEM_H
diff -ruNa TC4_Kernel_3.0/arch/arm/mach-exynos/include/mach/pm-core.h modem/arch/arm/mach-exynos/include/mach/pm-core.h
--- TC4_Kernel_3.0/arch/arm/mach-exynos/include/mach/pm-core.h	2012-05-15 15:08:07.000000000 +0800
+++ modem/arch/arm/mach-exynos/include/mach/pm-core.h	2012-07-04 15:30:18.000000000 +0800
@@ -34,7 +34,8 @@
 	s3c_irqwake_intmask &= ~(0xFFF << 20);
 	s3c_irqwake_intmask |= (0x3F << 20);//Robin, Mask IRQ2/IRQ3/FIQ2/FIQ3 of external GIC
 	s3c_irqwake_eintmask &=~(0x1 << 2);	//yulu
-
+        s3c_irqwake_intmask |= (0x1 << 1);  //ylk: mask RTC_ALARM
+        
 #endif
 	__raw_writel(s3c_irqwake_intmask, S5P_WAKEUP_MASK);
 	__raw_writel(s3c_irqwake_eintmask, S5P_EINT_WAKEUP_MASK);
diff -ruNa TC4_Kernel_3.0/arch/arm/mach-exynos/mach-smdk4x12.c modem/arch/arm/mach-exynos/mach-smdk4x12.c
--- TC4_Kernel_3.0/arch/arm/mach-exynos/mach-smdk4x12.c	2012-05-29 09:32:09.000000000 +0800
+++ modem/arch/arm/mach-exynos/mach-smdk4x12.c	2012-07-04 15:30:18.000000000 +0800
@@ -101,7 +101,7 @@
 #ifdef CONFIG_EXYNOS4_DEV_DWMCI
 #include <mach/dwmci.h>
 #endif
-#ifdef CONFIG_XMM6260_MODEM
+#ifdef CONFIG_SMM6260_MODEM
 #include <mach/modem.h>
 #endif
 #include <mach/map.h>
@@ -588,8 +588,8 @@
 		regulator_enable(vdd5m_cam_regulator); 
 	       udelay(10);
 
-		if (!regulator_is_enabled(tv_regulator_vdd18) ||
-			!regulator_is_enabled(tv_regulator_vdd10))
+	//	if (!regulator_is_enabled(tv_regulator_vdd18) ||
+		//	!regulator_is_enabled(tv_regulator_vdd10))
 		{
 			regulator_enable(tv_regulator_vdd18);
 			udelay(10);
@@ -3411,13 +3411,13 @@
 		REGULATOR_CHANGE_STATUS, 1);//sleep controlled by pwren
 REGULATOR_INIT(ldo7, "VDD10_XPLL", 1000000, 1000000, 1,
 		REGULATOR_CHANGE_STATUS, 1);//sleep controlled by pwren
-REGULATOR_INIT(ldo8, "VDD10_MIPI", 1000000, 1000000, 1,
+REGULATOR_INIT(ldo8, "VDD10_MIPI", 1000000, 1000000, 0,
 		REGULATOR_CHANGE_STATUS, 1);
 REGULATOR_INIT(ldo9, "VDD33_LCD", 3300000, 3300000, 1,
 		REGULATOR_CHANGE_STATUS, 1);
 
 
-REGULATOR_INIT(ldo10, "VDD18_MIPI", 1800000, 1800000, 1,
+REGULATOR_INIT(ldo10, "VDD18_MIPI", 1800000, 1800000, 0,
 		REGULATOR_CHANGE_STATUS, 1);
 REGULATOR_INIT(ldo11, "VDD18_ABB1", 1800000, 1800000, 1,
 		REGULATOR_CHANGE_STATUS, 0); //???
@@ -4659,12 +4659,12 @@
         &headset_switch_device,
 #endif
 	&s3c_device_gps,
-	//&xmm6260_modem,
+	//&smm6260_modem,
 #ifdef CONFIG_GPIO_SMM6260
 	&smm6260_device,//liang
 #endif
-#ifdef CONFIG_XMM6260_MODEM
-	&xmm6260_modem,
+#ifdef CONFIG_SMM6260_MODEM
+	&smm6260_modem,
 #endif	
 #ifdef CONFIG_VIBRATOR
 	&s5p_vib_dev,
@@ -5703,11 +5703,21 @@
 	{ EXYNOS4_GPB(7),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //PMIC_SET3
 
 
+#ifdef CONFIG_SMM6260_MODEM
+	{ EXYNOS4_GPC0(0),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //MD_PWON
+#else
 	{ EXYNOS4_GPC0(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //MD_PWON
+#endif
 	{ EXYNOS4_GPC0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //VLED_ON
 	{ EXYNOS4_GPC0(2),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //MD_RSTN
+#ifdef CONFIG_SMM6260_MODEM
+	//{ EXYNOS4_GPC0(3),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //AP_SLEEP
+	{ EXYNOS4_GPC0(4),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //AP_WAKEUP_MD
+	{ EXYNOS4_GPX2(5),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //MD_WAKEUP_AP
+#else
 	{ EXYNOS4_GPC0(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //AP_SLEEP
 	{ EXYNOS4_GPC0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //AP_WAKEUP_MD
+#endif
 	
 	{ EXYNOS4_GPC1(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //UART_SW  config as hp  out1??
 	{ EXYNOS4_GPC1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //LED_EN18
@@ -5833,7 +5843,11 @@
 	{ EXYNOS4_GPL1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
 
 	{ EXYNOS4_GPL2(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//KP_COL0
+#ifdef CONFIG_SMM6260_MODEM
+	{ EXYNOS4_GPL2(1),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//MD_RESETBB
+#else
 	{ EXYNOS4_GPL2(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//MD_RESETBB
+#endif
 	{ EXYNOS4_GPL2(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//HUB_RESET
 	{ EXYNOS4_GPL2(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//NFC_SCL
 	{ EXYNOS4_GPL2(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//NFC_SDA
@@ -5954,7 +5968,11 @@
 
 	{ EXYNOS4_GPC0(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //MD_PWON
 	{ EXYNOS4_GPC0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //VLED_ON
+#ifdef CONFIG_SMM6260_MODEM
+	{ EXYNOS4_GPC0(2),  S3C_GPIO_SLP_PREV,  S3C_GPIO_PULL_NONE}, //MD_RSTN  //lisw_2012.029 for Modem do not go into L3
+#else
 	{ EXYNOS4_GPC0(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //MD_RSTN
+#endif
 	{ EXYNOS4_GPC0(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //AP_SLEEP
 	{ EXYNOS4_GPC0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //AP_WAKEUP_MD
 	
@@ -6189,7 +6207,7 @@
 	{EXYNOS4_GPX1(3), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //HOOK_DET
 	{EXYNOS4_GPX1(4), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//WIFI_WOW
 	//{EXYNOS4_GPX1(5), S3C_GPIO_SFN(0xf),	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//CHG_UOK
-	{EXYNOS4_GPX1(6), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//MD_SLEEP_REQUEST
+	//{EXYNOS4_GPX1(6), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//MD_SLEEP_REQUEST
 	{EXYNOS4_GPX1(7), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //IRQ_PMIC
 
 
diff -ruNa TC4_Kernel_3.0/arch/arm/mach-exynos/mach-smdk4x12.c.bak modem/arch/arm/mach-exynos/mach-smdk4x12.c.bak
--- TC4_Kernel_3.0/arch/arm/mach-exynos/mach-smdk4x12.c.bak	1970-01-01 08:00:00.000000000 +0800
+++ modem/arch/arm/mach-exynos/mach-smdk4x12.c.bak	2012-07-04 15:30:18.000000000 +0800
@@ -0,0 +1,6841 @@
+/* linux/arch/arm/mach-exynos/mach-smdk4x12.c
+ *
+ * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/platform_device.h>
+#include <linux/serial_core.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_gpio.h>
+#include <linux/clk.h>
+#include <linux/lcd.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/i2c.h>
+#ifdef CONFIG_SNFC
+#include <linux/nfc/s3fhrn2.h>
+#include <linux/i2c-gpio.h>
+#include <linux/pn544.h>
+#endif
+#include <linux/pwm_backlight.h>
+#include <linux/input.h>
+#include <linux/mmc/host.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/max8649.h>
+#include <linux/regulator/fixed.h>
+#include <linux/mfd/wm8994/pdata.h>
+#include <linux/mfd/max8997.h>
+#include <linux/mfd/max77686.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/memblock.h>
+#include <linux/delay.h>
+#if defined(CONFIG_S5P_MEM_CMA)
+#include <linux/cma.h>
+#endif
+#ifdef CONFIG_ANDROID_PMEM
+#include <linux/android_pmem.h>
+#endif
+#ifdef CONFIG_BATTERY_MAX17040
+#include <linux/max17040_battery.h>
+#endif
+#include <linux/smsc911x.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach-types.h>
+
+#include <plat/regs-serial.h>
+#include <plat/exynos4.h>
+#include <plat/cpu.h>
+#include <plat/clock.h>
+#include <plat/keypad.h>
+#include <plat/devs.h>
+#include <plat/fb.h>
+#include <plat/fb-s5p.h>
+#include <plat/fb-core.h>
+#include <plat/regs-fb-v4.h>
+#include <plat/backlight.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-adc.h>
+#include <plat/adc.h>
+#include <plat/iic.h>
+#include <plat/pd.h>
+#include <plat/sdhci.h>
+#include <plat/mshci.h>
+#include <plat/ehci.h>
+#include <plat/usbgadget.h>
+#include <plat/s3c64xx-spi.h>
+#if defined(CONFIG_VIDEO_FIMC)
+#include <plat/fimc.h>
+#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
+#include <plat/fimc-core.h>
+#include <media/s5p_fimc.h>
+#endif
+#if defined(CONFIG_VIDEO_FIMC_MIPI)
+#include <plat/csis.h>
+#elif defined(CONFIG_VIDEO_S5P_MIPI_CSIS)
+#include <plat/mipi_csis.h>
+#endif
+#include <plat/tvout.h>
+#include <plat/media.h>
+#include <plat/regs-srom.h>
+#include <plat/tv-core.h>
+#include <media/s5k4ba_platform.h>
+#include <media/s5k4ea_platform.h>
+#include <media/exynos_flite.h>
+#include <media/exynos_fimc_is.h>
+#include <video/platform_lcd.h>
+#include <media/m5mo_platform.h>
+#include <media/m5mols.h>
+#include <mach/board_rev.h>
+#include <mach/map.h>
+#include <mach/spi-clocks.h>
+#include <mach/exynos-ion.h>
+#include <mach/regs-pmu.h>
+#ifdef CONFIG_EXYNOS4_DEV_DWMCI
+#include <mach/dwmci.h>
+#endif
+#ifdef CONFIG_SMM6260_MODEM
+#include <mach/modem.h>
+#endif
+#include <mach/map.h>
+#include <mach/regs-pmu.h>
+#ifdef CONFIG_SOC_CAMERA_MT9D115
+#include <media/mt9d115_platform.h>
+#endif
+#ifdef CONFIG_VIDEO_S5K4ECGX
+#include <media/s5k4ecgx.h>
+#define temp_width 640
+#define temp_height 480
+#endif
+
+#include <mach/max8997.h>
+#ifdef CONFIG_BATTERY_MAX8997
+#include <linux/fg8997_battery.h>
+#endif
+#ifdef CONFIG_RTC_MAX8997
+#include <linux/rtc-max8997.h>
+#endif
+#ifdef CONFIG_EXYNOS4_CONTENT_PATH_PROTECTION
+#include <mach/secmem.h>
+#endif
+#include <mach/dev.h>
+#include <mach/ppmu.h>
+#ifdef CONFIG_EXYNOS_C2C
+#include <mach/c2c.h>
+#endif
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_MFC) || defined(CONFIG_VIDEO_MFC5X)
+#include <plat/s5p-mfc.h>
+#endif
+
+#ifdef CONFIG_FB_S5P_MIPI_DSIM
+#include <mach/mipi_ddi.h>
+#include <mach/dsim.h>
+#include <../../../drivers/video/samsung/s3cfb.h>
+#endif
+#include <plat/fimg2d.h>
+#ifdef CONFIG_TC4_GB
+#include <mach/sysmmu.h>
+#else
+#include <mach/dev-sysmmu.h>
+#include <plat/sysmmu.h>
+
+#endif
+#if defined(CONFIG_SENSOR_ST_LSM303DLHC)	// G/M sensor
+#include <linux/i2c/lsm303dlhc.h>
+#endif
+
+#if defined(CONFIG_SENSOR_ST_L3G4200D)		// Gyroscope sensor
+#include <linux/i2c/l3g4200d.h>
+#endif
+
+#if defined(CONFIG_SENSOR_ROHM_BH1721)		// Light sensor
+#include <linux/i2c/rohm_bh1721.h>
+#endif
+
+#if defined(CONFIG_KERNEL_PANIC_DUMP)		//panic-dump
+#include <mach/panic-dump.h>
+#endif
+
+#include <linux/i2c/max8997.h>
+
+//zxz for 8M sensor
+#define GPIO_CAM_MCLK    EXYNOS4212_GPJ1(3)
+#define GPIO_CAM_MEGA_EN    EXYNOS4_GPF1(5)
+#define GPIO_CAM_MEGA_nRST   EXYNOS4_GPF1(4)
+#define GPIO_CAM_PCLK    EXYNOS4212_GPJ0(0)
+
+#ifdef CONFIG_SNFC
+#define SNFC_I2C_ADDR		0x2a
+#define SNFC_EINT_NUM		9
+#endif
+
+#ifdef CONFIG_TC4_GB// liang
+#include <linux/mpu.h>
+#if defined(CONFIG_MPU_SENSORS_MPU3050) || defined(CONFIG_MPU_SENSORS_MPU3050_MODULE)
+
+#define SENSOR_MPU_NAME "mpu3050"
+#define MPUGPIO (EXYNOS4_GPX3(3))
+
+static struct mpu3050_platform_data mpu_data = {
+	.int_config  = 0x10,
+#ifdef CONFIG_TC4_PORTRAIT_MODE
+	.orientation = {  0,  1,  0, 
+		1,  0,  0, 
+		0,  0, -1 },
+#else
+	.orientation = {  -1,  0,  0, 
+		0,  1,  0, 
+		0,  0, -1 },
+#endif
+	/* accel */
+	.accel = {
+#ifdef CONFIG_MPU_SENSORS_MPU3050_MODULE
+		.get_slave_descr = NULL,
+#else
+		.get_slave_descr = get_accel_slave_descr,
+#endif
+		.adapt_num   = 5,
+		.bus         = EXT_SLAVE_BUS_SECONDARY,
+		.address     = (0x30>>1),//0x0F,
+#ifdef CONFIG_TC4_PORTRAIT_MODE
+		.orientation = {  1,  0,  0, 
+			0,  -1,  0, 
+			0,  0, -1 },
+	},
+#else
+		.orientation = {  0,  1,  0, 
+			1,  0,  0, 
+			0,  0, -1 },
+	},
+#endif
+	/* compass */
+	.compass = {
+#ifdef CONFIG_MPU_SENSORS_MPU3050_MODULE
+		.get_slave_descr = NULL,
+#else
+		.get_slave_descr = get_compass_slave_descr,
+#endif
+		.adapt_num   = 5,
+		.bus         = EXT_SLAVE_BUS_PRIMARY,
+		.address     = (0x3c>>1),//0x0E,
+#ifdef CONFIG_TC4_PORTRAIT_MODE
+		.orientation = { -1, 0, 0, 
+			0, 1, 0, 
+			0, 0, 1 },
+	},
+#else
+		.orientation = { 0, -1, 0, 
+			-1, 0, 0, 
+			0, 0, -1 },
+	},
+#endif
+	/* pressure */
+	.pressure = {
+#ifdef CONFIG_MPU_SENSORS_MPU3050_MODULE
+		.get_slave_descr = NULL,
+#else
+		.get_slave_descr = get_pressure_slave_descr,
+#endif
+		.adapt_num   = 2,
+		.bus         = EXT_SLAVE_BUS_PRIMARY,
+		.address     = 0x77,
+		.orientation = { 1, 0, 0, 
+			0, 1, 0, 
+			0, 0, 1 },
+	},
+};
+#endif
+
+#if defined(CONFIG_MPU_SENSORS_MPU6000) || defined(CONFIG_MPU_SENSORS_MPU6000_MODULE)
+
+#define SENSOR_MPU_NAME "mpu6000"
+
+static struct mpu3050_platform_data mpu_data = {
+	.int_config  = 0x10,
+	.orientation = {  -1,  0,  0,
+		0,  1,  0,
+		0,  0, -1 },
+	/* accel */
+	.accel = {
+#ifdef CONFIG_MPU_SENSORS_MPU6000_MODULE
+		.get_slave_descr = NULL,
+#else
+		.get_slave_descr = get_accel_slave_descr,
+#endif
+		.adapt_num   = 2,
+		.bus         = EXT_SLAVE_BUS_PRIMARY,
+		.address     = 0x68,
+		.orientation = {  -1,  0,  0,
+			0,  1,  0,
+			0,  0, -1 },
+	},
+	/* compass */
+	.compass = {
+#ifdef CONFIG_MPU_SENSORS_MPU6000_MODULE
+		.get_slave_descr = NULL,
+#else
+		.get_slave_descr = get_compass_slave_descr,
+#endif
+		.adapt_num   = 2,
+		.bus         = EXT_SLAVE_BUS_SECONDARY,
+		.address     = 0x0E,
+		.orientation = { 1, 0, 0,
+			0, 1, 0,
+			0, 0, 1 },
+	},
+	/* pressure */
+	.pressure = {
+#ifdef CONFIG_MPU_SENSORS_MPU6000_MODULE
+		.get_slave_descr = NULL,
+#else
+		.get_slave_descr = get_pressure_slave_descr,
+#endif
+		.adapt_num   = 2,
+		.bus         = EXT_SLAVE_BUS_PRIMARY,
+		.address     = 0x77,
+		.orientation = { 1, 0, 0, 
+			0, 1, 0, 
+			0, 0, 1 },
+	},
+
+};
+#endif
+#endif
+
+#ifdef CONFIG_TC4_ICS
+#include <linux/mpu.h>
+
+static struct mpu_platform_data mpu3050_data = {
+	.int_config  = 0x10,
+#ifdef CONFIG_TC4_PORTRAIT_MODE
+	.orientation = {  0,  1,  0, 
+		1,  0,  0, 
+		0,  0, -1 },
+#else
+	.orientation = {  -1,  0,  0,
+			   0,  1,  0,
+			   0,  0, -1 },
+#endif
+};
+
+/* accel */
+static struct ext_slave_platform_data inv_mpu_bma250_data = {
+	.bus         = EXT_SLAVE_BUS_SECONDARY,
+#ifdef CONFIG_TC4_PORTRAIT_MODE
+	.orientation = {  1,  0,  0, 
+		0,  -1,  0, 
+		0,  0, -1 },
+#else
+	.orientation = {  0,  1,  0,
+			  1,  0,  0,
+			  0,  0, -1 },
+#endif
+};
+
+/* compass */
+static struct ext_slave_platform_data inv_mpu_hmc5883_data = {
+	.bus         = EXT_SLAVE_BUS_PRIMARY,
+#ifdef CONFIG_TC4_PORTRAIT_MODE
+	.orientation = { -1, 0, 0, 
+		0, 1, 0, 
+		0, 0, 1 },
+#else
+	.orientation = { 0, -1, 0,
+			 -1, 0, 0,
+			 0, 0, -1 },
+#endif
+};
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_EGALAX)	// Egalax I2C TS
+#include <linux/i2c/egalax.h>	// touch
+#endif
+#include <linux/i2c-gpio.h>	
+
+#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+#include <plat/fimc-core.h>
+#include <media/s5p_fimc.h>
+#endif
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_MFC)
+#include <plat/s5p-mfc.h>
+#endif
+
+#if defined (CONFIG_VIDEO_JPEG_V2X) || defined(CONFIG_VIDEO_JPEG)
+#include <plat/jpeg.h>
+#endif
+#ifdef CONFIG_REGULATOR_S5M8767
+#include <linux/mfd/s5m87xx/s5m-core.h>
+#include <linux/mfd/s5m87xx/s5m-pmic.h>
+#endif
+
+#if defined(CONFIG_EXYNOS_SETUP_THERMAL) 
+#include <plat/s5p-tmu.h> 
+#endif
+#define REG_INFORM4            (S5P_INFORM4)
+
+/* Following are default values for UCON, ULCON and UFCON UART registers */
+#define SMDK4X12_UCON_DEFAULT	(S3C2410_UCON_TXILEVEL |	\
+				 S3C2410_UCON_RXILEVEL |	\
+				 S3C2410_UCON_TXIRQMODE |	\
+				 S3C2410_UCON_RXIRQMODE |	\
+				 S3C2410_UCON_RXFIFO_TOI |	\
+				 S3C2443_UCON_RXERR_IRQEN)
+
+#define SMDK4X12_ULCON_DEFAULT	S3C2410_LCON_CS8
+
+#define SMDK4X12_UFCON_DEFAULT	(S3C2410_UFCON_FIFOMODE |	\
+				 S5PV210_UFCON_TXTRIG4 |	\
+				 S5PV210_UFCON_RXTRIG4)
+
+static struct s3c2410_uartcfg smdk4x12_uartcfgs[] __initdata = {
+	[0] = {
+		.hwport		= 0,
+		.flags		= 0,
+		.ucon		= SMDK4X12_UCON_DEFAULT,
+		.ulcon		= SMDK4X12_ULCON_DEFAULT,
+		.ufcon		= SMDK4X12_UFCON_DEFAULT,
+	},
+	[1] = {
+		.hwport		= 1,
+		.flags		= 0,
+		.ucon		= SMDK4X12_UCON_DEFAULT,
+		.ulcon		= SMDK4X12_ULCON_DEFAULT,
+		.ufcon		= SMDK4X12_UFCON_DEFAULT,
+	},
+	[2] = {
+		.hwport		= 2,
+		.flags		= 0,
+		.ucon		= SMDK4X12_UCON_DEFAULT,
+		.ulcon		= SMDK4X12_ULCON_DEFAULT,
+		.ufcon		= SMDK4X12_UFCON_DEFAULT,
+	},
+	[3] = {
+		.hwport		= 3,
+		.flags		= 0,
+		.ucon		= SMDK4X12_UCON_DEFAULT,
+		.ulcon		= SMDK4X12_ULCON_DEFAULT,
+		.ufcon		= SMDK4X12_UFCON_DEFAULT,
+	},
+};
+
+static struct resource smdk4x12_smsc911x_resources[] = {
+	[0] = {
+		.start	= EXYNOS4_PA_SROM_BANK(1),
+		.end	= EXYNOS4_PA_SROM_BANK(1) + SZ_64K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_EINT(5),
+		.end	= IRQ_EINT(5),
+		.flags	= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
+	},
+};
+
+static struct smsc911x_platform_config smsc9215_config = {
+	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
+	.irq_type	= SMSC911X_IRQ_TYPE_PUSH_PULL,
+	.flags		= SMSC911X_USE_16BIT | SMSC911X_FORCE_INTERNAL_PHY,
+	.phy_interface	= PHY_INTERFACE_MODE_MII,
+	.mac		= {0x00, 0x80, 0x00, 0x23, 0x45, 0x67},
+};
+
+static struct platform_device smdk4x12_smsc911x = {
+	.name		= "smsc911x",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(smdk4x12_smsc911x_resources),
+	.resource	= smdk4x12_smsc911x_resources,
+	.dev		= {
+		.platform_data	= &smsc9215_config,
+	},
+};
+
+#ifdef CONFIG_EXYNOS_MEDIA_DEVICE
+struct platform_device exynos_device_md0 = {
+	.name = "exynos-mdev",
+	.id = -1,
+};
+#endif
+
+#define WRITEBACK_ENABLED
+
+#if defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
+/*
+ * External camera reset
+ * Because the most of cameras take i2c bus signal, so that
+ * you have to reset at the boot time for other i2c slave devices.
+ * This function also called at fimc_init_camera()
+ * Do optimization for cameras on your platform.
+*/
+#if defined(CONFIG_ITU_A) || defined(CONFIG_CSI_C) \
+	|| defined(CONFIG_S5K3H2_CSI_C) || defined(CONFIG_S5K3H7_CSI_C) \
+	|| defined(CONFIG_S5K4E5_CSI_C) || defined(CONFIG_S5K6A3_CSI_C)
+static int smdk4x12_cam0_reset(int dummy)
+{
+	int err;
+
+	return 0;
+}
+
+static int S5K3H2_cam0_reset(int dummy)
+{
+	int err;
+	/* Camera A */
+
+	printk(KERN_ERR "#### S5K3H2_cam0_reset ####\n");
+	err = gpio_request(EXYNOS4_GPF1(4), "GPF1_4");
+	if (err)
+		printk(KERN_ERR "#### failed to request GPF1_4 ####\n");
+
+	s3c_gpio_setpull(EXYNOS4_GPF1(4), S3C_GPIO_PULL_NONE);
+	gpio_direction_output(EXYNOS4_GPF1(4), 0);
+	gpio_direction_output(EXYNOS4_GPF1(4), 1);
+	gpio_free(EXYNOS4_GPF1(4));
+
+
+	err = gpio_request(EXYNOS4_GPF1(5), "GPF1_5");
+	if (err)
+		printk(KERN_ERR "#### failed to request GPF1_5 ####\n");
+
+	s3c_gpio_setpull(EXYNOS4_GPF1(5), S3C_GPIO_PULL_NONE);
+	gpio_direction_output(EXYNOS4_GPF1(5), 1);
+	gpio_free(EXYNOS4_GPF1(5));
+
+	return 0;
+}
+#endif
+#if defined(CONFIG_ITU_B) || defined(CONFIG_CSI_D) \
+	|| defined(CONFIG_S5K3H2_CSI_D) || defined(CONFIG_S5K3H7_CSI_D) \
+	|| defined(CONFIG_S5K4E5_CSI_D) || defined(CONFIG_S5K6A3_CSI_D)
+static int smdk4x12_cam1_reset(int dummy)
+{
+	int err;
+
+	return 0;
+}
+#if 1//ndef CONFIG_TC4_EVT
+static struct regulator *vdd18_5m_cam_regulator = NULL;	
+static struct regulator *vdd28_5m_cam_regulator = NULL;
+static struct regulator *vddaf_cam_regulator = NULL;	
+static struct regulator *vdd5m_cam_regulator = NULL;
+
+extern struct regulator *tv_regulator_vdd18 ;	//added by yulu for controlling mipi voltage 	
+extern struct regulator *tv_regulator_vdd10 ;	
+extern bool cam_mipi_en;
+#endif
+
+static int S5K3H2_cam1_reset(int dummy)
+{
+	int err;
+	int ret = -ENODEV;
+#ifndef CONFIG_TC4_EVT
+	vdd28_5m_cam_regulator = regulator_get(NULL, "vdd28_cam");
+	
+	if (IS_ERR(vdd28_5m_cam_regulator)) {
+		printk("%s: failed to get %s\n", __func__, "vdd28_cam");
+		ret = -ENODEV;
+		goto err_regulator;
+	}
+	vddaf_cam_regulator = regulator_get(NULL, "vdd28_af");
+	if (IS_ERR(vdd28_5m_cam_regulator)) {
+		printk("%s: failed to get %s\n", __func__, "vdd28_af");
+		ret = -ENODEV;
+		goto err_regulator;
+	}
+	vdd18_5m_cam_regulator = regulator_get(NULL, "vdd18_cam");
+	
+	if (IS_ERR(vdd18_5m_cam_regulator)) {
+		printk("%s: failed to get %s\n", __func__, "vdd18_cam");
+		ret = -ENODEV;
+		goto err_regulator;
+	}
+	vdd5m_cam_regulator = regulator_get(NULL, "vdd12_5m");
+	if (IS_ERR(vdd5m_cam_regulator)) {
+		printk("%s: failed to get %s\n", __func__, "vdd12_5m");
+		ret = -ENODEV;
+		goto err_regulator;
+	}
+#endif
+	printk("S5K3H2_cam1_reset  dummy = %d\n",dummy);
+       /* Camera B */
+	if(dummy == 1)// power on
+	{	
+		if (gpio_request(GPIO_CAM_MEGA_nRST, "GPF1_4"/*"GPJ1"*/) < 0)
+			pr_err("failed gpio_request(GPF1_4) for camera control\n");
+
+		gpio_direction_output(GPIO_CAM_MEGA_nRST, 0);
+		s3c_gpio_setpull(GPIO_CAM_MEGA_nRST, S3C_GPIO_PULL_NONE);
+	
+		if (gpio_request(GPIO_CAM_MEGA_EN, "GPF1_5"/*"GPJ0"*/) < 0)
+			pr_err("failed gpio_request(GPF1_5) for camera control\n");
+
+		gpio_direction_output(GPIO_CAM_MEGA_EN, 0);
+		s3c_gpio_setpull(GPIO_CAM_MEGA_EN, S3C_GPIO_PULL_NONE);
+#ifndef CONFIG_TC4_EVT
+		regulator_enable(vdd18_5m_cam_regulator); 
+	       udelay(10);
+		regulator_enable(vdd28_5m_cam_regulator); 
+	       udelay(10);
+         	regulator_enable(vddaf_cam_regulator); 
+	       udelay(10);
+		regulator_enable(vdd5m_cam_regulator); 
+	       udelay(10);
+
+	//	if (!regulator_is_enabled(tv_regulator_vdd18) ||
+		//	!regulator_is_enabled(tv_regulator_vdd10))
+		{
+			regulator_enable(tv_regulator_vdd18);
+			udelay(10);
+			regulator_enable(tv_regulator_vdd10);
+			udelay(10);
+		}
+		cam_mipi_en = true;
+#endif
+		
+		s3c_gpio_cfgpin(GPIO_CAM_MCLK, S3C_GPIO_SFN(2));//MCLK
+		mdelay(1);
+
+		// STBYN high
+		gpio_direction_output(GPIO_CAM_MEGA_EN, 1);	
+		mdelay(1);
+
+		// RSTN high
+		gpio_direction_output(GPIO_CAM_MEGA_nRST, 1);	
+		mdelay(1);
+
+		// PCLK high
+		s3c_gpio_cfgpin(GPIO_CAM_PCLK, S3C_GPIO_SFN(2));//PCLK
+
+		gpio_free(GPIO_CAM_MEGA_nRST);
+		gpio_free(GPIO_CAM_MEGA_EN);
+
+	}else{
+		if (gpio_request(GPIO_CAM_MEGA_nRST, "GPF1_4"/*"GPJ1"*/) < 0)
+			pr_err("failed gpio_request(GPF1_4) for camera control\n");
+	
+		gpio_direction_output(GPIO_CAM_MEGA_nRST, 0);	
+		mdelay(1);
+		// STBYN high
+		if (gpio_request(GPIO_CAM_MEGA_EN, "GPF1_5"/*"GPJ0"*/) < 0)
+			pr_err("failed gpio_request(GPF1_5) for camera control\n");
+		gpio_direction_output(GPIO_CAM_MEGA_EN, 0); 
+		mdelay(1);
+
+		gpio_free(GPIO_CAM_MEGA_nRST);
+		gpio_free(GPIO_CAM_MEGA_EN);
+#ifndef CONFIG_TC4_EVT
+    	      // cam_mipi_en = false;
+    	      // if((!tv_mipi_en )&& (!cam_mipi_en)){
+			regulator_disable(tv_regulator_vdd10); 
+		       udelay(10);
+			regulator_disable(tv_regulator_vdd18); 
+		       udelay(10);
+    	       //}
+		regulator_disable(vdd18_5m_cam_regulator); 
+	       udelay(10);
+		regulator_disable(vdd28_5m_cam_regulator); 
+	       udelay(10);
+		regulator_disable(vddaf_cam_regulator); 
+	       udelay(10);
+		regulator_disable(vdd5m_cam_regulator); 
+	       udelay(10);
+#endif		
+	}
+#ifndef CONFIG_TC4_EVT
+err_regulator:
+	regulator_put(vdd18_5m_cam_regulator);	
+	regulator_put(vdd28_5m_cam_regulator);
+	regulator_put(vddaf_cam_regulator);	
+	regulator_put(vdd5m_cam_regulator);
+#endif
+       return 0;
+}
+
+#endif
+#endif
+
+#ifdef CONFIG_VIDEO_FIMC
+#ifdef CONFIG_VIDEO_S5K4BA
+static struct s5k4ba_platform_data s5k4ba_plat = {
+	.default_width = 800,
+	.default_height = 600,
+	.pixelformat = V4L2_PIX_FMT_YUYV,
+	.freq = 24000000,
+	.is_mipi = 0,
+};
+
+static struct i2c_board_info s5k4ba_i2c_info = {
+	I2C_BOARD_INFO("S5K4BA", 0x2d),
+	.platform_data = &s5k4ba_plat,
+};
+
+static struct s3c_platform_camera s5k4ba = {
+#ifdef CONFIG_ITU_A
+	.id		= CAMERA_PAR_A,
+	.clk_name	= "sclk_cam0",
+	.i2c_busnum	= 4,
+	.cam_power	= smdk4x12_cam0_reset,
+#endif
+#ifdef CONFIG_ITU_B
+	.id		= CAMERA_PAR_B,
+	.clk_name	= "sclk_cam1",
+	.i2c_busnum	= 5,
+	.cam_power	= smdk4x12_cam1_reset,
+#endif
+	.type		= CAM_TYPE_ITU,
+	.fmt		= ITU_601_YCBCR422_8BIT,
+	.order422	= CAM_ORDER422_8BIT_CBYCRY,
+	.info		= &s5k4ba_i2c_info,
+	.pixelformat	= V4L2_PIX_FMT_YUYV,
+	.srclk_name	= "xusbxti",
+	.clk_rate	= 24000000,
+	.line_length	= 1920,
+	.width		= 1600,
+	.height		= 1200,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 1600,
+		.height	= 1200,
+	},
+
+	/* Polarity */
+	.inv_pclk	= 0,
+	.inv_vsync	= 1,
+	.inv_href	= 0,
+	.inv_hsync	= 0,
+	.reset_camera	= 1,
+	.initialized	= 0,
+};
+#endif
+#ifdef CONFIG_SOC_CAMERA_MT9D115
+
+static struct mt9d115_platform_data mt9d115_plat = {
+	.default_width = 640,
+	.default_height = 480,
+	.pixelformat = V4L2_PIX_FMT_UYVY,
+	.freq = 24000000,
+	.is_mipi = 0,
+};
+
+static struct i2c_board_info  mt9d115_i2c_info = {
+	I2C_BOARD_INFO("MT9D115", 0x3c),
+	.platform_data = &mt9d115_plat,
+};
+
+static struct s3c_platform_camera mt9d115 = {
+//#ifdef CONFIG_CSI_C //added yqf, remove
+			.id 	= CAMERA_PAR_A,
+			.clk_name	= "sclk_cam0",
+			.i2c_busnum = 7,
+			.cam_power	= smdk4x12_cam1_reset,
+//#endif
+
+		.type		= CAM_TYPE_ITU,
+		.fmt		= ITU_601_YCBCR422_8BIT,
+		.order422	= CAM_ORDER422_8BIT_CBYCRY,
+		.info		= &mt9d115_i2c_info,
+		.pixelformat	= V4L2_PIX_FMT_UYVY,
+		.srclk_name = "xusbxti",
+		.clk_rate	= 24000000,
+		.line_length	= 1920,
+		.width		= 640,
+		.height 	= 480,
+		.window 	= {
+			.left	= 0,
+			.top	= 0,
+			.width	= 640,
+			.height = 480,
+		},
+	
+		/* Polarity */
+		.inv_pclk	= 0,
+		.inv_vsync	= 1,
+		.inv_href	= 0,
+		.inv_hsync	= 0,
+		.reset_camera	= 1,
+		.initialized	= 0,
+              .layout_rotate = 180, 
+};
+#endif
+
+/*
+ * Guide for Camera Configuration for Crespo board
+ * ITU CAM CH A: LSI s5k4ecgx
+ */
+
+#ifdef CONFIG_VIDEO_S5K4ECGX
+static struct s5k4ecgx_platform_data s5k4ecgx_plat = {
+	.default_width = temp_width,
+	.default_height = temp_height,
+	.pixelformat = V4L2_PIX_FMT_UYVY,
+	.freq = 24000000,
+
+	.is_mipi = 1,
+};
+
+static struct i2c_board_info  s5k4ecgx_i2c_info = {
+	I2C_BOARD_INFO("S5K4ECGX", 0xAC>>1),
+	.platform_data = &s5k4ecgx_plat,
+};
+
+static struct s3c_platform_camera s5k4ecgx = {
+	.id = CAMERA_CSI_D,      
+	.type = CAM_TYPE_MIPI, 
+	.fmt = MIPI_CSI_YCBCR422_8BIT, 
+	.order422 = CAM_ORDER422_8BIT_CBYCRY,
+	.i2c_busnum = 6,
+	.info = &s5k4ecgx_i2c_info,
+	.pixelformat = V4L2_PIX_FMT_UYVY,
+	.srclk_name ="xusbxti",
+	.clk_name = "sclk_cam0",
+	.clk_rate = 24000000,
+	.line_length = 1920,
+	.width = temp_width,
+	.height = temp_height,
+	.window = {
+		.left = 0,
+		.top = 0,
+		.width = temp_width,
+		.height = temp_height,
+	},
+
+	.mipi_lanes = 2, //add
+	.mipi_settle = 12, //add
+	.mipi_align = 32, //add
+
+	/* Polarity */
+	.inv_pclk = 0,
+	.inv_vsync = 1,
+	.inv_href = 0,
+	.inv_hsync = 0,
+
+	.initialized = 0,
+       .layout_rotate = 180, 
+	.cam_power = smdk4x12_cam1_reset,
+
+};
+#endif
+
+
+
+/* 2 MIPI Cameras */
+#ifdef CONFIG_VIDEO_S5K4EA
+static struct s5k4ea_platform_data s5k4ea_plat = {
+	.default_width = 1920,
+	.default_height = 1080,
+	.pixelformat = V4L2_PIX_FMT_UYVY,
+	.freq = 24000000,
+	.is_mipi = 1,
+};
+
+static struct i2c_board_info s5k4ea_i2c_info = {
+	I2C_BOARD_INFO("S5K4EA", 0x2d),
+	.platform_data = &s5k4ea_plat,
+};
+
+static struct s3c_platform_camera s5k4ea = {
+#ifdef CONFIG_CSI_C
+	.id		= CAMERA_CSI_C,
+	.clk_name	= "sclk_cam0",
+	.i2c_busnum	= 4,
+	.cam_power	= smdk4x12_cam0_reset,
+#endif
+#ifdef CONFIG_CSI_D
+	.id		= CAMERA_CSI_D,
+	.clk_name	= "sclk_cam1",
+	.i2c_busnum	= 5,
+	.cam_power	= smdk4x12_cam1_reset,
+#endif
+	.type		= CAM_TYPE_MIPI,
+	.fmt		= MIPI_CSI_YCBCR422_8BIT,
+	.order422	= CAM_ORDER422_8BIT_YCBYCR,
+	.info		= &s5k4ea_i2c_info,
+	.pixelformat	= V4L2_PIX_FMT_UYVY,
+	.srclk_name	= "xusbxti",
+	.clk_rate	= 24000000,
+	.line_length	= 1920,
+	.width		= 1920,
+	.height		= 1080,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 1920,
+		.height	= 1080,
+	},
+
+	.mipi_lanes	= 2,
+	.mipi_settle	= 12,
+	.mipi_align	= 32,
+
+	/* Polarity */
+	.inv_pclk	= 0,
+	.inv_vsync	= 1,
+	.inv_href	= 0,
+	.inv_hsync	= 0,
+
+	.initialized	= 0,
+};
+#endif
+
+#ifdef WRITEBACK_ENABLED
+static struct i2c_board_info writeback_i2c_info = {
+	I2C_BOARD_INFO("WriteBack", 0x0),
+};
+
+static struct s3c_platform_camera writeback = {
+	.id		= CAMERA_WB,
+	.fmt		= ITU_601_YCBCR422_8BIT,
+	.order422	= CAM_ORDER422_8BIT_CBYCRY,
+	.i2c_busnum	= 0,
+	.info		= &writeback_i2c_info,
+	.pixelformat	= V4L2_PIX_FMT_YUV444,
+	.line_length	= 800,
+	.width		= 480,
+	.height		= 800,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 480,
+		.height	= 800,
+	},
+
+	.initialized	= 0,
+};
+#endif
+
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_IS
+#ifdef CONFIG_VIDEO_S5K3H2
+static struct i2c_board_info s5k3h2_sensor_info = {
+	.type = "S5K3H2",
+};
+
+static struct s3c_platform_camera s5k3h2 = {
+#ifdef CONFIG_S5K3H2_CSI_C
+	.id		= CAMERA_CSI_C,
+	.clk_name	= "sclk_cam0",
+	.cam_power	= S5K3H2_cam0_reset,
+#endif
+#ifdef CONFIG_S5K3H2_CSI_D
+	.id		= CAMERA_CSI_D,
+	.clk_name	= "sclk_cam0",//zhuxuezhen
+	.cam_power	= S5K3H2_cam1_reset,
+#endif
+	.type		= CAM_TYPE_MIPI,
+	.fmt		= MIPI_CSI_RAW10,
+	.info		= &s5k3h2_sensor_info,
+	.order422	= CAM_ORDER422_8BIT_YCBYCR,
+	.pixelformat	= V4L2_PIX_FMT_UYVY,
+	.line_length	= 1920,
+	.width		= 1920,
+	.height		= 1080,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 1920,
+		.height	= 1080,
+	},
+	.srclk_name	= "xusbxti",
+	.clk_rate	= 24000000,
+	.mipi_lanes	= 2,
+	.mipi_settle	= 12,
+	.mipi_align	= 24,
+
+	.initialized	= 0,
+#ifdef CONFIG_S5K3H2_CSI_C
+	.flite_id	= FLITE_IDX_A,
+#endif
+#ifdef CONFIG_S5K3H2_CSI_D
+	.flite_id	= FLITE_IDX_B,
+#endif
+	.use_isp	= true,
+#ifdef CONFIG_S5K3H2_CSI_C
+	.sensor_index	= 1,
+#endif
+#ifdef CONFIG_S5K3H2_CSI_D
+	.sensor_index	= 101,
+#endif
+};
+#endif
+
+#ifdef CONFIG_VIDEO_S5K3H7
+static struct s3c_platform_camera s5k3h7 = {
+#ifdef CONFIG_S5K3H7_CSI_C
+	.id		= CAMERA_CSI_C,
+	.clk_name	= "sclk_cam0",
+	.cam_power	= smdk4x12_cam0_reset,
+#endif
+#ifdef CONFIG_S5K3H7_CSI_D
+	.id		= CAMERA_CSI_D,
+	.clk_name	= "sclk_cam1",
+	.cam_power	= smdk4x12_cam1_reset,
+#endif
+	.type		= CAM_TYPE_MIPI,
+	.fmt		= MIPI_CSI_RAW10,
+	.order422	= CAM_ORDER422_8BIT_YCBYCR,
+	.pixelformat	= V4L2_PIX_FMT_UYVY,
+	.line_length	= 1920,
+	.width		= 1920,
+	.height		= 1080,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 1920,
+		.height	= 1080,
+	},
+	.srclk_name	= "xusbxti",
+	.clk_rate	= 24000000,
+	.mipi_lanes	= 2,
+	.mipi_settle	= 12,
+	.mipi_align	= 24,
+
+	.initialized	= 0,
+#ifdef CONFIG_S5K3H7_CSI_C
+	.flite_id	= FLITE_IDX_A,
+#endif
+#ifdef CONFIG_S5K3H7_CSI_D
+	.flite_id	= FLITE_IDX_B,
+#endif
+	.use_isp	= true,
+#ifdef CONFIG_S5K3H7_CSI_C
+	.sensor_index	= 4,
+#endif
+#ifdef CONFIG_S5K3H7_CSI_D
+	.sensor_index	= 104,
+#endif
+};
+#endif
+
+#ifdef CONFIG_VIDEO_S5K4E5
+static struct s3c_platform_camera s5k4e5 = {
+#ifdef CONFIG_S5K4E5_CSI_C
+	.id		= CAMERA_CSI_C,
+	.clk_name	= "sclk_cam0",
+	.cam_power	= smdk4x12_cam0_reset,
+#endif
+#ifdef CONFIG_S5K4E5_CSI_D
+	.id		= CAMERA_CSI_D,
+	.clk_name	= "sclk_cam1",
+	.cam_power	= smdk4x12_cam1_reset,
+#endif
+	.type		= CAM_TYPE_MIPI,
+	.fmt		= MIPI_CSI_RAW10,
+	.order422	= CAM_ORDER422_8BIT_YCBYCR,
+	.pixelformat	= V4L2_PIX_FMT_UYVY,
+	.line_length	= 1920,
+	.width		= 1920,
+	.height		= 1080,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 1920,
+		.height	= 1080,
+	},
+	.srclk_name	= "xusbxti",
+	.clk_rate	= 24000000,
+	.mipi_lanes	= 2,
+	.mipi_settle	= 12,
+	.mipi_align	= 24,
+
+	.initialized	= 0,
+#ifdef CONFIG_S5K4E5_CSI_C
+	.flite_id	= FLITE_IDX_A,
+#endif
+#ifdef CONFIG_S5K4E5_CSI_D
+	.flite_id	= FLITE_IDX_B,
+#endif
+	.use_isp	= true,
+#ifdef CONFIG_S5K4E5_CSI_C
+	.sensor_index	= 3,
+#endif
+#ifdef CONFIG_S5K4E5_CSI_D
+	.sensor_index	= 103,
+#endif
+};
+#endif
+
+
+#ifdef CONFIG_VIDEO_S5K6A3
+static struct s3c_platform_camera s5k6a3 = {
+#ifdef CONFIG_S5K6A3_CSI_C
+	.id		= CAMERA_CSI_C,
+	.clk_name	= "sclk_cam0",
+	.cam_power	= smdk4x12_cam0_reset,
+#endif
+#ifdef CONFIG_S5K6A3_CSI_D
+	.id		= CAMERA_CSI_D,
+	.clk_name	= "sclk_cam1",
+	.cam_power	= smdk4x12_cam1_reset,
+#endif
+	.type		= CAM_TYPE_MIPI,
+	.fmt		= MIPI_CSI_RAW10,
+	.order422	= CAM_ORDER422_8BIT_YCBYCR,
+	.pixelformat	= V4L2_PIX_FMT_UYVY,
+	.line_length	= 1920,
+	.width		= 1920,
+	.height		= 1080,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 1920,
+		.height	= 1080,
+	},
+	.srclk_name	= "xusbxti",
+	.clk_rate	= 24000000,
+	.mipi_lanes	= 1,
+	.mipi_settle	= 12,
+	.mipi_align	= 24,
+
+	.initialized	= 0,
+#ifdef CONFIG_S5K6A3_CSI_C
+	.flite_id	= FLITE_IDX_A,
+#endif
+#ifdef CONFIG_S5K6A3_CSI_D
+	.flite_id	= FLITE_IDX_B,
+#endif
+	.use_isp	= true,
+#ifdef CONFIG_S5K6A3_CSI_C
+	.sensor_index	= 2,
+#endif
+#ifdef CONFIG_S5K6A3_CSI_D
+	.sensor_index	= 102,
+#endif
+};
+#endif
+
+#endif
+
+/* legacy M5MOLS Camera driver configuration */
+#ifdef CONFIG_VIDEO_M5MO
+#define CAM_CHECK_ERR_RET(x, msg)	\
+	if (unlikely((x) < 0)) { \
+		printk(KERN_ERR "\nfail to %s: err = %d\n", msg, x); \
+		return x; \
+	}
+#define CAM_CHECK_ERR(x, msg)	\
+		if (unlikely((x) < 0)) { \
+			printk(KERN_ERR "\nfail to %s: err = %d\n", msg, x); \
+		}
+
+static int m5mo_config_isp_irq(void)
+{
+	s3c_gpio_cfgpin(EXYNOS4_GPX3(3), S3C_GPIO_SFN(0xF));
+	s3c_gpio_setpull(EXYNOS4_GPX3(3), S3C_GPIO_PULL_NONE);
+	return 0;
+}
+
+static struct m5mo_platform_data m5mo_plat = {
+	.default_width = 640, /* 1920 */
+	.default_height = 480, /* 1080 */
+	.pixelformat = V4L2_PIX_FMT_UYVY,
+	.freq = 24000000,
+	.is_mipi = 1,
+	.config_isp_irq = m5mo_config_isp_irq,
+	.irq = IRQ_EINT(27),
+};
+
+static struct i2c_board_info m5mo_i2c_info = {
+	I2C_BOARD_INFO("M5MO", 0x1F),
+	.platform_data = &m5mo_plat,
+	.irq = IRQ_EINT(27),
+};
+
+static struct s3c_platform_camera m5mo = {
+#ifdef CONFIG_CSI_C
+	.id		= CAMERA_CSI_C,
+	.clk_name	= "sclk_cam0",
+	.i2c_busnum	= 4,
+	.cam_power	= smdk4x12_cam0_reset,
+#endif
+#ifdef CONFIG_CSI_D
+	.id		= CAMERA_CSI_D,
+	.clk_name	= "sclk_cam1",
+	.i2c_busnum	= 5,
+	.cam_power	= smdk4x12_cam1_reset,
+#endif
+	.type		= CAM_TYPE_MIPI,
+	.fmt		= MIPI_CSI_YCBCR422_8BIT,
+	.order422	= CAM_ORDER422_8BIT_YCBYCR,
+	.info		= &m5mo_i2c_info,
+	.pixelformat	= V4L2_PIX_FMT_UYVY,
+	.srclk_name	= "xusbxti", /* "mout_mpll" */
+	.clk_rate	= 24000000, /* 48000000 */
+	.line_length	= 1920,
+	.width		= 640,
+	.height		= 480,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 640,
+		.height	= 480,
+	},
+
+	.mipi_lanes	= 2,
+	.mipi_settle	= 12,
+	.mipi_align	= 32,
+
+	/* Polarity */
+	.inv_pclk	= 1,
+	.inv_vsync	= 1,
+	.inv_href	= 0,
+	.inv_hsync	= 0,
+	.reset_camera	= 0,
+	.initialized	= 0,
+};
+#endif
+
+/* Interface setting */
+static struct s3c_platform_fimc fimc_plat = {
+#ifdef CONFIG_ITU_A
+	.default_cam	= CAMERA_PAR_A,
+#endif
+#ifdef CONFIG_ITU_B
+	.default_cam	= CAMERA_PAR_B,
+#endif
+#ifdef CONFIG_CSI_C
+	.default_cam	= CAMERA_CSI_C,
+#endif
+#ifdef CONFIG_CSI_D
+	.default_cam	= CAMERA_CSI_D,
+#endif
+#ifdef WRITEBACK_ENABLED
+	.default_cam	= CAMERA_WB,
+#endif
+	.camera		= {
+#ifdef CONFIG_VIDEO_S5K4BA
+		&s5k4ba,
+#endif
+#ifdef CONFIG_VIDEO_S5K4EA
+		&s5k4ea,
+#endif
+
+#ifdef CONFIG_VIDEO_S5K3H2
+		&s5k3h2,
+#endif
+
+#if 0 //added yqf, adjust for middleware request
+#ifdef CONFIG_SOC_CAMERA_MT9D115
+                &mt9d115,
+#endif
+#ifdef CONFIG_VIDEO_S5K4ECGX
+                &s5k4ecgx,
+#endif
+#else
+//for S5K4EC back
+#ifdef CONFIG_VIDEO_S5K4ECGX
+		&s5k4ecgx,
+#endif
+//front
+#ifdef CONFIG_SOC_CAMERA_MT9D115
+		&mt9d115,
+#endif
+#endif
+
+#ifdef CONFIG_VIDEO_M5MO
+		&m5mo,
+#endif
+#ifdef CONFIG_VIDEO_S5K3H7
+		&s5k3h7,
+#endif
+#ifdef CONFIG_VIDEO_S5K4E5
+		&s5k4e5,
+#endif
+#ifdef CONFIG_VIDEO_S5K6A3
+		&s5k6a3,
+#endif
+#ifdef WRITEBACK_ENABLED
+		&writeback,
+#endif
+	},
+	.hw_ver		= 0x51,
+};
+#endif /* CONFIG_VIDEO_FIMC */
+
+/* for mainline fimc interface */
+#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+#ifdef WRITEBACK_ENABLED
+struct writeback_mbus_platform_data {
+	int id;
+	struct v4l2_mbus_framefmt fmt;
+};
+
+static struct i2c_board_info __initdata writeback_info = {
+	I2C_BOARD_INFO("writeback", 0x0),
+};
+#endif
+
+#ifdef CONFIG_FB_S3C
+#ifdef CONFIG_VIDEO_S5K4ECGX		//yulu
+static struct s5k4ecgx_platform_data s5k4ecgx_plat = {
+	.default_width = temp_width,
+	.default_height = temp_height,
+	.pixelformat = V4L2_PIX_FMT_UYVY,
+	.freq = 24000000,
+
+	.is_mipi = 1,
+};
+static struct i2c_board_info  s5k4ecgx_i2c_info = {
+	I2C_BOARD_INFO("S5K4ECGX", 0xAC>>1),
+	.platform_data = &s5k4ecgx_plat,
+};
+/* This is for platdata of fimc-lite */
+static struct s3c_platform_camera s5k4ecgx = {
+	.type		= CAM_TYPE_MIPI,
+	.use_isp	= false,
+	.inv_pclk	= 0,
+	.inv_vsync	= 1,
+	.inv_href	= 0,
+	.inv_hsync	= 0,
+};
+#endif
+#ifdef CONFIG_SOC_CAMERA_MT9D115
+
+static struct mt9d115_platform_data mt9d115_plat = {
+	.default_width = 640,
+	.default_height = 480,
+	.pixelformat = V4L2_PIX_FMT_UYVY,
+	.freq = 24000000,
+	.is_mipi = 0,
+};
+
+static struct i2c_board_info  mt9d115_i2c_info = {
+	I2C_BOARD_INFO("MT9D115", 0x3c),
+	.platform_data = &mt9d115_plat,
+};
+static struct s3c_platform_camera mt9d115 = {
+	.type		= CAM_TYPE_ITU,
+	.use_isp	= false,
+	.inv_pclk	= 0,
+	.inv_vsync	= 1,
+	.inv_href	= 0,
+	.inv_hsync	= 0,
+};
+#endif
+#endif
+
+#ifdef CONFIG_VIDEO_S5K4BA
+static struct s5k4ba_mbus_platform_data s5k4ba_mbus_plat = {
+	.id		= 0,
+	.fmt = {
+		.width	= 1600,
+		.height	= 1200,
+		/*.code	= V4L2_MBUS_FMT_UYVY8_2X8, */
+		.code	= V4L2_MBUS_FMT_VYUY8_2X8,
+	},
+	.clk_rate	= 24000000UL,
+#ifdef CONFIG_ITU_A
+	.set_power	= smdk4x12_cam0_reset,
+#endif
+#ifdef CONFIG_ITU_B
+	.set_power	= smdk4x12_cam1_reset,
+#endif
+};
+
+static struct i2c_board_info s5k4ba_info = {
+	I2C_BOARD_INFO("S5K4BA", 0x2d),
+	.platform_data = &s5k4ba_mbus_plat,
+};
+#endif
+
+/* 2 MIPI Cameras */
+#ifdef CONFIG_VIDEO_S5K4EA
+static struct s5k4ea_mbus_platform_data s5k4ea_mbus_plat = {
+#ifdef CONFIG_CSI_C
+	.id		= 0,
+	.set_power = smdk4x12_cam0_reset,
+#endif
+#ifdef CONFIG_CSI_D
+	.id		= 1,
+	.set_power = smdk4x12_cam1_reset,
+#endif
+	.fmt = {
+		.width	= 1920,
+		.height	= 1080,
+		.code	= V4L2_MBUS_FMT_VYUY8_2X8,
+	},
+	.clk_rate	= 24000000UL,
+};
+
+static struct i2c_board_info s5k4ea_info = {
+	I2C_BOARD_INFO("S5K4EA", 0x2d),
+	.platform_data = &s5k4ea_mbus_plat,
+};
+#endif
+
+#ifdef CONFIG_VIDEO_M5MOLS
+static struct m5mols_platform_data m5mols_platdata = {
+#ifdef CONFIG_CSI_C
+	.gpio_rst = EXYNOS4_GPX1(2), /* ISP_RESET */
+#endif
+#ifdef CONFIG_CSI_D
+	.gpio_rst = EXYNOS4_GPX1(0), /* ISP_RESET */
+#endif
+	.enable_rst = true, /* positive reset */
+	.irq = IRQ_EINT(27),
+};
+
+static struct i2c_board_info m5mols_board_info = {
+	I2C_BOARD_INFO("M5MOLS", 0x1F),
+	.platform_data = &m5mols_platdata,
+};
+
+#endif
+
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_IS
+#ifdef CONFIG_VIDEO_S5K3H2
+static struct i2c_board_info s5k3h2_sensor_info = {
+	.type = "S5K3H2",
+};
+#endif
+#ifdef CONFIG_VIDEO_S5K3H7
+static struct i2c_board_info s5k3h7_sensor_info = {
+	.type = "S5K3H7",
+};
+#endif
+#ifdef CONFIG_VIDEO_S5K4E5
+static struct i2c_board_info s5k4e5_sensor_info = {
+	.type = "S5K4E5",
+};
+#endif
+#ifdef CONFIG_VIDEO_S5K6A3
+static struct i2c_board_info s5k6a3_sensor_info = {
+	.type = "S5K6A3",
+};
+#endif
+#endif
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_LITE
+/* This is for platdata of fimc-lite */
+#ifdef CONFIG_VIDEO_S5K3H2
+static struct s3c_platform_camera s5k3h2 = {
+	.type  = CAM_TYPE_MIPI,
+	.use_isp = true,
+	.inv_pclk = 0,
+	.inv_vsync = 0,
+	.inv_href = 0,
+	.inv_hsync = 0,
+};
+#endif
+
+#ifdef CONFIG_VIDEO_S5K3H7
+static struct s3c_platform_camera s5k3h7 = {
+	.type  = CAM_TYPE_MIPI,
+	.use_isp = true,
+	.inv_pclk = 0,
+	.inv_vsync = 0,
+	.inv_href = 0,
+	.inv_hsync = 0,
+};
+#endif
+
+#ifdef CONFIG_VIDEO_S5K4E5
+static struct s3c_platform_camera s5k4e5 = {
+	.type  = CAM_TYPE_MIPI,
+	.use_isp = true,
+	.inv_pclk = 0,
+	.inv_vsync = 0,
+	.inv_href = 0,
+	.inv_hsync = 0,
+};
+#endif
+
+
+#ifdef CONFIG_VIDEO_S5K6A3
+static struct s3c_platform_camera s5k6a3 = {
+	.type  = CAM_TYPE_MIPI,
+	.use_isp = true,
+	.inv_pclk = 0,
+	.inv_vsync = 0,
+	.inv_href = 0,
+	.inv_hsync = 0,
+};
+#endif
+#endif
+#endif /* CONFIG_VIDEO_SAMSUNG_S5P_FIMC */
+
+#ifdef CONFIG_S3C64XX_DEV_SPI
+static struct s3c64xx_spi_csinfo spi0_csi[] = {
+	[0] = {
+		.line = EXYNOS4_GPB(1),
+		.set_level = gpio_set_value,
+		.fb_delay = 0x2,
+	},
+};
+
+static struct spi_board_info spi0_board_info[] __initdata = {
+	{
+		.modalias = "spidev",
+		.platform_data = NULL,
+		.max_speed_hz = 10*1000*1000,
+		.bus_num = 0,
+		.chip_select = 0,
+		.mode = SPI_MODE_0,
+		.controller_data = &spi0_csi[0],
+	}
+};
+
+#ifndef CONFIG_FB_S5P_LMS501KF03
+static struct s3c64xx_spi_csinfo spi1_csi[] = {
+	[0] = {
+		.line = EXYNOS4_GPB(5),
+		.set_level = gpio_set_value,
+		.fb_delay = 0x2,
+	},
+};
+
+static struct spi_board_info spi1_board_info[] __initdata = {
+	{
+		.modalias = "spidev",
+		.platform_data = NULL,
+		.max_speed_hz = 10*1000*1000,
+		.bus_num = 1,
+		.chip_select = 0,
+		.mode = SPI_MODE_3,
+		.controller_data = &spi1_csi[0],
+	}
+};
+#endif
+
+static struct s3c64xx_spi_csinfo spi2_csi[] = {
+	[0] = {
+		.line = EXYNOS4_GPC1(2),
+		.set_level = gpio_set_value,
+		.fb_delay = 0x2,
+	},
+};
+
+static struct spi_board_info spi2_board_info[] __initdata = {
+	{
+		.modalias = "spidev",
+		.platform_data = NULL,
+		.max_speed_hz = 10*1000*1000,
+		.bus_num = 2,
+		.chip_select = 0,
+		.mode = SPI_MODE_0,
+		.controller_data = &spi2_csi[0],
+	}
+};
+#endif
+
+#ifdef CONFIG_FB_S3C
+#if defined(CONFIG_LCD_AMS369FG06)
+static int lcd_power_on(struct lcd_device *ld, int enable)
+{
+	return 1;
+}
+
+static int reset_lcd(struct lcd_device *ld)
+{
+	int err = 0;
+
+	err = gpio_request_one(EXYNOS4_GPX0(6), GPIOF_OUT_INIT_HIGH, "GPX0");
+	if (err) {
+		printk(KERN_ERR "failed to request GPX0 for "
+				"lcd reset control\n");
+		return err;
+	}
+	gpio_set_value(EXYNOS4_GPX0(6), 0);
+	mdelay(1);
+
+	gpio_set_value(EXYNOS4_GPX0(6), 1);
+
+	gpio_free(EXYNOS4_GPX0(6));
+
+	return 1;
+}
+
+static struct lcd_platform_data ams369fg06_platform_data = {
+	.reset			= reset_lcd,
+	.power_on		= lcd_power_on,
+	.lcd_enabled		= 0,
+	.reset_delay		= 100,	/* 100ms */
+};
+
+#define		LCD_BUS_NUM	3
+#define		DISPLAY_CS	EXYNOS4_GPB(5)
+#define		DISPLAY_CLK	EXYNOS4_GPB(4)
+#define		DISPLAY_SI	EXYNOS4_GPB(7)
+
+static struct spi_board_info spi_board_info[] __initdata = {
+	{
+		.modalias		= "ams369fg06",
+		.platform_data		= (void *)&ams369fg06_platform_data,
+		.max_speed_hz		= 1200000,
+		.bus_num		= LCD_BUS_NUM,
+		.chip_select		= 0,
+		.mode			= SPI_MODE_3,
+		.controller_data	= (void *)DISPLAY_CS,
+	}
+};
+
+static struct spi_gpio_platform_data ams369fg06_spi_gpio_data = {
+	.sck	= DISPLAY_CLK,
+	.mosi	= DISPLAY_SI,
+	.miso	= -1,
+	.num_chipselect = 1,
+};
+
+static struct platform_device s3c_device_spi_gpio = {
+	.name	= "spi_gpio",
+	.id	= LCD_BUS_NUM,
+	.dev	= {
+		.parent		= &s5p_device_fimd0.dev,
+		.platform_data	= &ams369fg06_spi_gpio_data,
+	},
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win0 = {
+	.win_mode = {
+		.left_margin	= 9,
+		.right_margin	= 9,
+		.upper_margin	= 5,
+		.lower_margin	= 5,
+		.hsync_len	= 2,
+		.vsync_len	= 2,
+		.xres		= 480,
+		.yres		= 800,
+	},
+	.virtual_x		= 480,
+	.virtual_y		= 1600,
+	.width			= 48,
+	.height			= 80,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win1 = {
+	.win_mode = {
+		.left_margin	= 9,
+		.right_margin	= 9,
+		.upper_margin	= 5,
+		.lower_margin	= 5,
+		.hsync_len	= 2,
+		.vsync_len	= 2,
+		.xres		= 480,
+		.yres		= 800,
+	},
+	.virtual_x		= 480,
+	.virtual_y		= 1600,
+	.width			= 48,
+	.height			= 80,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win2 = {
+	.win_mode = {
+		.left_margin	= 9,
+		.right_margin	= 9,
+		.upper_margin	= 5,
+		.lower_margin	= 5,
+		.hsync_len	= 2,
+		.vsync_len	= 2,
+		.xres		= 480,
+		.yres		= 800,
+	},
+	.virtual_x		= 480,
+	.virtual_y		= 1600,
+	.width			= 48,
+	.height			= 80,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+#elif defined (CONFIG_LCD_LMS501KF03)
+static int lcd_power_on(struct lcd_device *ld, int enable)
+{
+	return 1;
+}
+
+static int reset_lcd(struct lcd_device *ld)
+{
+	int err = 0;
+
+	if (samsung_board_rev_is_0_1()) {
+		err = gpio_request_one(EXYNOS4212_GPM3(6),
+				GPIOF_OUT_INIT_HIGH, "GPM3");
+		if (err) {
+			printk(KERN_ERR "failed to request GPM3 for "
+					"lcd reset control\n");
+			return err;
+		}
+		gpio_set_value(EXYNOS4212_GPM3(6), 0);
+		mdelay(1);
+
+		gpio_set_value(EXYNOS4212_GPM3(6), 1);
+
+		gpio_free(EXYNOS4212_GPM3(6));
+	} else {
+		err = gpio_request_one(EXYNOS4_GPX1(5),
+				GPIOF_OUT_INIT_HIGH, "GPX1");
+		if (err) {
+			printk(KERN_ERR "failed to request GPX1 for "
+					"lcd reset control\n");
+			return err;
+		}
+		gpio_set_value(EXYNOS4_GPX1(5), 0);
+		mdelay(1);
+
+		gpio_set_value(EXYNOS4_GPX1(5), 1);
+
+		gpio_free(EXYNOS4_GPX1(5));
+	}
+
+	return 1;
+}
+
+static struct lcd_platform_data lms501kf03_platform_data = {
+	.reset			= reset_lcd,
+	.power_on		= lcd_power_on,
+	.lcd_enabled		= 0,
+	.reset_delay		= 100,	/* 100ms */
+};
+
+#define		LCD_BUS_NUM	3
+#define		DISPLAY_CS	EXYNOS4_GPB(5)
+#define		DISPLAY_CLK	EXYNOS4_GPB(4)
+#define		DISPLAY_SI	EXYNOS4_GPB(7)
+
+static struct spi_board_info spi_board_info[] __initdata = {
+	{
+		.modalias		= "lms501kf03",
+		.platform_data		= (void *)&lms501kf03_platform_data,
+		.max_speed_hz		= 1200000,
+		.bus_num		= LCD_BUS_NUM,
+		.chip_select		= 0,
+		.mode			= SPI_MODE_3,
+		.controller_data	= (void *)DISPLAY_CS,
+	}
+};
+
+static struct spi_gpio_platform_data lms501kf03_spi_gpio_data = {
+	.sck	= DISPLAY_CLK,
+	.mosi	= DISPLAY_SI,
+	.miso	= -1,
+	.num_chipselect = 1,
+};
+
+static struct platform_device s3c_device_spi_gpio = {
+	.name	= "spi_gpio",
+	.id	= LCD_BUS_NUM,
+	.dev	= {
+		.parent		= &s5p_device_fimd0.dev,
+		.platform_data	= &lms501kf03_spi_gpio_data,
+	},
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win0 = {
+	.win_mode = {
+		.left_margin	= 8,		/* HBPD */
+		.right_margin	= 8,		/* HFPD */
+		.upper_margin	= 6,	/* VBPD */
+		.lower_margin	= 6,		/* VFPD */
+		.hsync_len	= 6,		/* HSPW */
+		.vsync_len	= 4,		/* VSPW */
+		.xres		= 480,
+		.yres		= 800,
+	},
+	.virtual_x		= 480,
+	.virtual_y		= 1600,
+	.width			= 48,
+	.height			= 80,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win1 = {
+	.win_mode = {
+		.left_margin	= 8,		/* HBPD */
+		.right_margin	= 8,		/* HFPD */
+		.upper_margin	= 6,	/* VBPD */
+		.lower_margin	= 6,		/* VFPD */
+		.hsync_len	= 6,		/* HSPW */
+		.vsync_len	= 4,		/* VSPW */
+		.xres		= 480,
+		.yres		= 800,
+	},
+	.virtual_x		= 480,
+	.virtual_y		= 1600,
+	.width			= 48,
+	.height			= 80,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win2 = {
+	.win_mode = {
+		.left_margin	= 8,		/* HBPD */
+		.right_margin	= 8,		/* HFPD */
+		.upper_margin	= 6,	/* VBPD */
+		.lower_margin	= 6,		/* VFPD */
+		.hsync_len	= 6,		/* HSPW */
+		.vsync_len	= 4,		/* VSPW */
+		.xres		= 480,
+		.yres		= 800,
+	},
+	.virtual_x		= 480,
+	.virtual_y		= 1600,
+	.width			= 48,
+	.height			= 80,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+#elif defined(CONFIG_LCD_WA101S)
+static void lcd_wa101s_set_power(struct plat_lcd_data *pd,
+				   unsigned int power)
+{
+	if (power) {
+#if !defined(CONFIG_BACKLIGHT_PWM)
+		gpio_request_one(EXYNOS4_GPD0(1), GPIOF_OUT_INIT_HIGH, "GPD0");
+		gpio_free(EXYNOS4_GPD0(1));
+#endif
+	} else {
+#if !defined(CONFIG_BACKLIGHT_PWM)
+		gpio_request_one(EXYNOS4_GPD0(1), GPIOF_OUT_INIT_LOW, "GPD0");
+		gpio_free(EXYNOS4_GPD0(1));
+#endif
+	}
+}
+
+static struct plat_lcd_data smdk4x12_lcd_wa101s_data = {
+	.set_power		= lcd_wa101s_set_power,
+};
+
+static struct platform_device smdk4x12_lcd_wa101s = {
+	.name			= "platform-lcd",
+	.dev.parent		= &s5p_device_fimd0.dev,
+	.dev.platform_data      = &smdk4x12_lcd_wa101s_data,
+};
+#ifndef CONFIG_FB_S3C
+static struct s3c_fb_pd_win smdk4x12_fb_win0 = {
+	.win_mode = {
+		.left_margin	= 80,
+		.right_margin	= 48,
+		.upper_margin	= 14,
+		.lower_margin	= 3,
+		.hsync_len	= 32,
+		.vsync_len	= 5,
+		.xres		= 1360, /* real size : 1366 */
+		.yres		= 768,
+	},
+	.virtual_x		= 1360, /* real size : 1366 */
+	.virtual_y		= 768 * 2,
+	.width			= 223,
+	.height			= 125,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win1 = {
+	.win_mode = {
+		.left_margin	= 80,
+		.right_margin	= 48,
+		.upper_margin	= 14,
+		.lower_margin	= 3,
+		.hsync_len	= 32,
+		.vsync_len	= 5,
+		.xres		= 1360, /* real size : 1366 */
+		.yres		= 768,
+	},
+	.virtual_x		= 1360, /* real size : 1366 */
+	.virtual_y		= 768 * 2,
+	.width			= 223,
+	.height			= 125,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win2 = {
+	.win_mode = {
+		.left_margin	= 80,
+		.right_margin	= 48,
+		.upper_margin	= 14,
+		.lower_margin	= 3,
+		.hsync_len	= 32,
+		.vsync_len	= 5,
+		.xres		= 1360, /* real size : 1366 */
+		.yres		= 768,
+	},
+	.virtual_x		= 1360, /* real size : 1366 */
+	.virtual_y		= 768 * 2,
+	.width			= 223,
+	.height			= 125,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+#else
+
+static struct s3c_fb_pd_win smdk4x12_fb_win0 = {
+	.win_mode = {
+		.left_margin	= 30,
+		.right_margin	= 30,
+		.upper_margin	= 10,
+		.lower_margin	= 6,
+		.hsync_len	= 9,
+		.vsync_len	= 7,
+		.xres		= 1280, /* real size : 1366 */
+		.yres		= 800,
+	},
+	.virtual_x		= 1280, /* real size : 1366 */
+	.virtual_y		= 800 * 2,
+	.width			= 223,
+	.height			= 125,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win1 = {
+	.win_mode = {
+		.left_margin	= 30,
+		.right_margin	= 30,
+		.upper_margin	= 10,
+		.lower_margin	= 6,
+		.hsync_len	= 9,
+		.vsync_len	= 7,
+		.xres		= 1280, /* real size : 1366 */
+		.yres		= 800,
+	},
+	.virtual_x		= 1280, /* real size : 1366 */
+	.virtual_y		= 800 * 2,
+	.width			= 223,
+	.height			= 125,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win2 = {
+	.win_mode = {
+		.left_margin	= 30,
+		.right_margin	= 30,
+		.upper_margin	= 10,
+		.lower_margin	= 6,
+		.hsync_len	= 9,
+		.vsync_len	= 7,
+		.xres		= 1280, /* real size : 1366 */
+		.yres		= 800,
+	},
+	.virtual_x		= 1280, /* real size : 1366 */
+	.virtual_y		= 800 * 2,
+	.width			= 223,
+	.height			= 125,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+
+#endif
+
+
+#elif defined(CONFIG_LCD_LTE480WV)
+static void lcd_lte480wv_set_power(struct plat_lcd_data *pd,
+				   unsigned int power)
+{
+	if (power) {
+#if !defined(CONFIG_BACKLIGHT_PWM)
+		gpio_request_one(EXYNOS4_GPD0(1), GPIOF_OUT_INIT_HIGH, "GPD0");
+		gpio_free(EXYNOS4_GPD0(1));
+#endif
+		/* fire nRESET on power up */
+		gpio_request_one(EXYNOS4_GPX0(6), GPIOF_OUT_INIT_HIGH, "GPX0");
+		mdelay(100);
+
+		gpio_set_value(EXYNOS4_GPX0(6), 0);
+		mdelay(10);
+
+		gpio_set_value(EXYNOS4_GPX0(6), 1);
+		mdelay(10);
+
+		gpio_free(EXYNOS4_GPX0(6));
+	} else {
+#if !defined(CONFIG_BACKLIGHT_PWM)
+		gpio_request_one(EXYNOS4_GPD0(1), GPIOF_OUT_INIT_LOW, "GPD0");
+		gpio_free(EXYNOS4_GPD0(1));
+#endif
+	}
+}
+
+static struct plat_lcd_data smdk4x12_lcd_lte480wv_data = {
+	.set_power		= lcd_lte480wv_set_power,
+};
+
+static struct platform_device smdk4x12_lcd_lte480wv = {
+	.name			= "platform-lcd",
+	.dev.parent		= &s5p_device_fimd0.dev,
+	.dev.platform_data      = &smdk4x12_lcd_lte480wv_data,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win0 = {
+	.win_mode = {
+		.left_margin	= 13,
+		.right_margin	= 8,
+		.upper_margin	= 7,
+		.lower_margin	= 5,
+		.hsync_len	= 3,
+		.vsync_len	= 1,
+		.xres		= 800,
+		.yres		= 480,
+	},
+	.virtual_x		= 800,
+	.virtual_y		= 960,
+	.width			= 104,
+	.height			= 62,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win1 = {
+	.win_mode = {
+		.left_margin	= 13,
+		.right_margin	= 8,
+		.upper_margin	= 7,
+		.lower_margin	= 5,
+		.hsync_len	= 3,
+		.vsync_len	= 1,
+		.xres		= 800,
+		.yres		= 480,
+	},
+	.virtual_x		= 800,
+	.virtual_y		= 960,
+	.width			= 104,
+	.height			= 62,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win2 = {
+	.win_mode = {
+		.left_margin	= 13,
+		.right_margin	= 8,
+		.upper_margin	= 7,
+		.lower_margin	= 5,
+		.hsync_len	= 3,
+		.vsync_len	= 1,
+		.xres		= 800,
+		.yres		= 480,
+	},
+	.virtual_x		= 800,
+	.virtual_y		= 960,
+	.width			= 104,
+	.height			= 62,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+#elif defined(CONFIG_LCD_MIPI_S6E63M0)
+static void mipi_lcd_set_power(struct plat_lcd_data *pd,
+				unsigned int power)
+{
+	gpio_request_one(EXYNOS4_GPX2(7), GPIOF_OUT_INIT_HIGH, "GPX2");
+
+	mdelay(100);
+	if (power) {
+		/* fire nRESET on power up */
+		gpio_set_value(EXYNOS4_GPX2(7), 0);
+		mdelay(100);
+		gpio_set_value(EXYNOS4_GPX2(7), 1);
+		mdelay(100);
+		gpio_free(EXYNOS4_GPX2(7));
+	} else {
+		/* fire nRESET on power off */
+		gpio_set_value(EXYNOS4_GPX2(7), 0);
+		mdelay(100);
+		gpio_set_value(EXYNOS4_GPX2(7), 1);
+		mdelay(100);
+		gpio_free(EXYNOS4_GPX2(7));
+	}
+}
+
+static struct plat_lcd_data smdk4x12_mipi_lcd_data = {
+	.set_power	= mipi_lcd_set_power,
+};
+
+static struct platform_device smdk4x12_mipi_lcd = {
+	.name			= "platform-lcd",
+	.dev.parent		= &s5p_device_fimd0.dev,
+	.dev.platform_data	= &smdk4x12_mipi_lcd_data,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win0 = {
+	.win_mode = {
+		.left_margin	= 0x16,
+		.right_margin	= 0x16,
+		.upper_margin	= 0x1,
+		.lower_margin	= 0x28,
+		.hsync_len	= 0x2,
+		.vsync_len	= 0x3,
+		.xres		= 480,
+		.yres		= 800,
+	},
+	.virtual_x		= 480,
+	.virtual_y		= 1600,
+	.width			= 48,
+	.height			= 80,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win1 = {
+	.win_mode = {
+		.left_margin	= 0x16,
+		.right_margin	= 0x16,
+		.upper_margin	= 0x1,
+		.lower_margin	= 0x28,
+		.hsync_len	= 0x2,
+		.vsync_len	= 0x3,
+		.xres		= 480,
+		.yres		= 800,
+	},
+	.virtual_x		= 480,
+	.virtual_y		= 1600,
+	.width			= 48,
+	.height			= 80,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+
+static struct s3c_fb_pd_win smdk4x12_fb_win2 = {
+	.win_mode = {
+		.left_margin	= 0x16,
+		.right_margin	= 0x16,
+		.upper_margin	= 0x1,
+		.lower_margin	= 0x28,
+		.hsync_len	= 0x2,
+		.vsync_len	= 0x3,
+		.xres		= 480,
+		.yres		= 800,
+	},
+	.virtual_x		= 480,
+	.virtual_y		= 1600,
+	.width			= 48,
+	.height			= 80,
+	.max_bpp		= 32,
+	.default_bpp		= 24,
+};
+#endif
+
+static struct s3c_fb_platdata smdk4x12_lcd0_pdata __initdata = {
+#if defined(CONFIG_LCD_AMS369FG06) || defined(CONFIG_LCD_WA101S) || \
+	defined(CONFIG_LCD_LTE480WV) || defined(CONFIG_LCD_LMS501KF03) || \
+	defined(CONFIG_LCD_MIPI_S6E63M0)
+	.win[0]		= &smdk4x12_fb_win0,
+	.win[1]		= &smdk4x12_fb_win1,
+	.win[2]		= &smdk4x12_fb_win2,
+#endif
+	.default_win	= 2,
+	.vidcon0	= VIDCON0_VIDOUT_RGB | VIDCON0_PNRMODE_RGB,
+#if defined(CONFIG_LCD_AMS369FG06)
+	.vidcon1	= VIDCON1_INV_VCLK | VIDCON1_INV_VDEN |
+			  VIDCON1_INV_HSYNC | VIDCON1_INV_VSYNC,
+#elif defined(CONFIG_LCD_LMS501KF03)
+	.vidcon1	= VIDCON1_INV_HSYNC | VIDCON1_INV_VSYNC,
+#elif defined(CONFIG_LCD_WA101S)
+	.vidcon1	= VIDCON1_INV_VCLK | VIDCON1_INV_HSYNC |
+			  VIDCON1_INV_VSYNC,
+#elif defined(CONFIG_LCD_LTE480WV)
+	.vidcon1	= VIDCON1_INV_HSYNC | VIDCON1_INV_VSYNC,
+#endif
+	.setup_gpio	= exynos4_fimd0_gpio_setup_24bpp,
+};
+#endif
+
+#ifdef CONFIG_FB_S5P
+#ifdef CONFIG_FB_S5P_LMS501KF03
+static struct s3c_platform_fb lms501kf03_data __initdata = {
+	.hw_ver = 0x70,
+	.clk_name = "sclk_lcd",
+	.nr_wins = 5,
+	.default_win = CONFIG_FB_S5P_DEFAULT_WINDOW,
+	.swap = FB_SWAP_HWORD | FB_SWAP_WORD,
+};
+
+#define		LCD_BUS_NUM	3
+#define		DISPLAY_CS	EXYNOS4_GPB(5)
+#define		DISPLAY_CLK	EXYNOS4_GPB(4)
+#define		DISPLAY_SI	EXYNOS4_GPB(7)
+
+static struct spi_board_info spi_board_info[] __initdata = {
+	{
+		.modalias	= "lms501kf03",
+		.platform_data	= NULL,
+		.max_speed_hz	= 1200000,
+		.bus_num	= LCD_BUS_NUM,
+		.chip_select	= 0,
+		.mode		= SPI_MODE_3,
+		.controller_data = (void *)DISPLAY_CS,
+	}
+};
+static struct spi_gpio_platform_data lms501kf03_spi_gpio_data = {
+	.sck	= DISPLAY_CLK,
+	.mosi	= DISPLAY_SI,
+	.miso	= -1,
+	.num_chipselect = 1,
+};
+
+static struct platform_device s3c_device_spi_gpio = {
+	.name	= "spi_gpio",
+	.id	= LCD_BUS_NUM,
+	.dev	= {
+		.parent		= &s3c_device_fb.dev,
+		.platform_data	= &lms501kf03_spi_gpio_data,
+	},
+};
+#elif defined(CONFIG_FB_S5P_DUMMY_MIPI_LCD)
+#define		LCD_BUS_NUM	3
+#define		DISPLAY_CS	EXYNOS4_GPB(5)
+#define		DISPLAY_CLK	EXYNOS4_GPB(4)
+#define		DISPLAY_SI	EXYNOS4_GPB(7)
+
+static struct s3cfb_lcd dummy_mipi_lcd = {
+	.width = 480,
+	.height = 800,
+	.bpp = 24,
+
+	.freq = 60,
+
+	.timing = {
+		.h_fp = 0x16,
+		.h_bp = 0x16,
+		.h_sw = 0x2,
+		.v_fp = 0x28,
+		.v_fpe = 2,
+		.v_bp = 0x1,
+		.v_bpe = 1,
+		.v_sw = 3,
+		.cmd_allow_len = 0x4,
+	},
+
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 0,
+		.inv_vsync = 0,
+		.inv_vden = 0,
+	},
+};
+
+static struct s3c_platform_fb fb_platform_data __initdata = {
+	.hw_ver		= 0x70,
+	.clk_name	= "sclk_lcd",
+	.nr_wins	= 5,
+	.default_win	= CONFIG_FB_S5P_DEFAULT_WINDOW,
+	.swap		= FB_SWAP_HWORD | FB_SWAP_WORD,
+};
+
+static void lcd_cfg_gpio(void)
+{
+	return;
+}
+
+static int reset_lcd(void)
+{
+	int err = 0;
+
+	/* fire nRESET on power off */
+	err = gpio_request(EXYNOS4_GPX3(1), "GPX3");
+	if (err) {
+		printk(KERN_ERR "failed to request GPX0 for lcd reset control\n");
+		return err;
+	}
+
+#ifdef CONFIG_CPU_EXYNOS4212
+	gpio_direction_output(EXYNOS4_GPX2(7), 1);
+	mdelay(100);
+
+	gpio_set_value(EXYNOS4_GPX2(7), 0);
+	mdelay(100);
+	gpio_set_value(EXYNOS4_GPX2(7), 1);
+	mdelay(100);
+	gpio_free(EXYNOS4_GPX2(7));
+#else
+	gpio_direction_output(EXYNOS4_GPX3(1), 1);
+	mdelay(100);
+
+	gpio_set_value(EXYNOS4_GPX3(1), 0);
+	mdelay(100);
+	gpio_set_value(EXYNOS4_GPX3(1), 1);
+	mdelay(100);
+	gpio_free(EXYNOS4_GPX3(1));
+#endif
+	return 0;
+}
+
+static int lcd_power_on(void *pdev, int enable)
+{
+	return 1;
+}
+
+static void __init mipi_fb_init(void)
+{
+	struct s5p_platform_dsim *dsim_pd = NULL;
+	struct mipi_ddi_platform_data *mipi_ddi_pd = NULL;
+	struct dsim_lcd_config *dsim_lcd_info = NULL;
+
+	/* gpio pad configuration for rgb and spi interface. */
+	lcd_cfg_gpio();
+
+	/*
+	 * register lcd panel data.
+	 */
+	dsim_pd = (struct s5p_platform_dsim *)
+		s5p_device_dsim.dev.platform_data;
+
+	strcpy(dsim_pd->lcd_panel_name, "dummy_mipi_lcd");
+
+	dsim_lcd_info = dsim_pd->dsim_lcd_info;
+	dsim_lcd_info->lcd_panel_info = (void *)&dummy_mipi_lcd;
+
+	mipi_ddi_pd = (struct mipi_ddi_platform_data *)
+		dsim_lcd_info->mipi_ddi_pd;
+	mipi_ddi_pd->lcd_reset = reset_lcd;
+	mipi_ddi_pd->lcd_power_on = lcd_power_on;
+
+	platform_device_register(&s5p_device_dsim);
+
+	s3cfb_set_platdata(&fb_platform_data);
+
+	printk(KERN_INFO "platform data of %s lcd panel has been registered.\n",
+			dsim_pd->lcd_panel_name);
+}
+#endif
+#endif
+
+static int exynos4_notifier_call(struct notifier_block *this,
+					unsigned long code, void *_cmd)
+{
+	int mode = 0;
+
+	if ((code == SYS_RESTART) && _cmd)
+		if (!strcmp((char *)_cmd, "recovery"))
+			mode = 0xf;
+
+	__raw_writel(mode, REG_INFORM4);
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block exynos4_reboot_notifier = {
+	.notifier_call = exynos4_notifier_call,
+};
+
+#ifdef CONFIG_EXYNOS4_DEV_DWMCI
+static void exynos_dwmci_cfg_gpio(int width)
+{
+	unsigned int gpio;
+
+	for (gpio = EXYNOS4_GPK0(0); gpio < EXYNOS4_GPK0(2); gpio++) {
+		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
+		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+		s5p_gpio_set_drvstr(gpio, S5P_GPIO_DRVSTR_LV2);
+	}
+
+	switch (width) {
+	case 8:
+		for (gpio = EXYNOS4_GPK1(3); gpio <= EXYNOS4_GPK1(6); gpio++) {
+			s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(4));
+			s3c_gpio_setpull(gpio, S3C_GPIO_PULL_UP);
+			s5p_gpio_set_drvstr(gpio, S5P_GPIO_DRVSTR_LV2);
+		}
+	case 4:
+		for (gpio = EXYNOS4_GPK0(3); gpio <= EXYNOS4_GPK0(6); gpio++) {
+			s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
+			s3c_gpio_setpull(gpio, S3C_GPIO_PULL_UP);
+			s5p_gpio_set_drvstr(gpio, S5P_GPIO_DRVSTR_LV2);
+		}
+		break;
+	case 1:
+		gpio = EXYNOS4_GPK0(3);
+		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
+		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_UP);
+		s5p_gpio_set_drvstr(gpio, S5P_GPIO_DRVSTR_LV2);
+	default:
+		break;
+	}
+}
+
+static struct dw_mci_board exynos_dwmci_pdata __initdata = {
+	.num_slots		= 1,
+	.quirks			= DW_MCI_QUIRK_BROKEN_CARD_DETECTION | DW_MCI_QUIRK_HIGHSPEED,
+	.bus_hz			= 100 * 1000 * 1000,
+	.caps			= MMC_CAP_UHS_DDR50 | MMC_CAP_1_8V_DDR |
+				MMC_CAP_8_BIT_DATA | MMC_CAP_CMD23,
+	.fifo_depth		= 0x80,
+	.detect_delay_ms	= 200,
+	.hclk_name		= "dwmci",
+	.cclk_name		= "sclk_dwmci",
+	.cfg_gpio		= exynos_dwmci_cfg_gpio,
+};
+#endif
+
+#ifdef CONFIG_S3C_DEV_HSMMC
+static struct s3c_sdhci_platdata smdk4x12_hsmmc0_pdata __initdata = {
+	.cd_type		= S3C_SDHCI_CD_INTERNAL,
+	.clk_type		= S3C_SDHCI_CLK_DIV_EXTERNAL,
+#ifdef CONFIG_EXYNOS4_SDHCI_CH0_8BIT
+	.max_width		= 8,
+	.host_caps		= MMC_CAP_8_BIT_DATA,
+#endif
+};
+#endif
+
+#ifdef CONFIG_S3C_DEV_HSMMC1
+static struct s3c_sdhci_platdata smdk4x12_hsmmc1_pdata __initdata = {
+	.cd_type		= S3C_SDHCI_CD_INTERNAL,
+	.clk_type		= S3C_SDHCI_CLK_DIV_EXTERNAL,
+};
+#endif
+
+#ifdef CONFIG_S3C_DEV_HSMMC2
+static struct s3c_sdhci_platdata smdk4x12_hsmmc2_pdata __initdata = {
+	.cd_type		= S3C_SDHCI_CD_GPIO,//lisw sd    S3C_SDHCI_CD_INTERNAL,
+	.ext_cd_gpio            =EXYNOS4_GPX0(7), //lisw sd
+    	.ext_cd_gpio_invert     = 1,//lisw sd
+	.clk_type		= S3C_SDHCI_CLK_DIV_EXTERNAL,
+#ifdef CONFIG_EXYNOS4_SDHCI_CH2_8BIT
+	.max_width		= 8,
+	.host_caps		= MMC_CAP_8_BIT_DATA,
+#endif
+};
+#endif
+
+#ifdef CONFIG_S3C_DEV_HSMMC3
+static struct s3c_sdhci_platdata smdk4x12_hsmmc3_pdata __initdata = {
+	// SEMCO
+	#if 0
+	.cd_type		= S3C_SDHCI_CD_INTERNAL,
+	.clk_type		= S3C_SDHCI_CLK_DIV_EXTERNAL,
+	#else
+	.cd_type		= S3C_SDHCI_CD_PERMANENT,
+	.clk_type		= S3C_SDHCI_CLK_DIV_EXTERNAL,
+	#endif
+};
+#endif
+
+#ifdef CONFIG_S5P_DEV_MSHC
+static struct s3c_mshci_platdata exynos4_mshc_pdata __initdata = {
+	.cd_type		= S3C_MSHCI_CD_PERMANENT,
+	.clk_type		= S3C_MSHCI_CLK_DIV_EXTERNAL, //lisw ms
+	.has_wp_gpio		= true,
+	.wp_gpio		= 0xffffffff,
+#if defined(CONFIG_EXYNOS4_MSHC_8BIT) && \
+	defined(CONFIG_EXYNOS4_MSHC_DDR)
+	.max_width		= 8,
+	.host_caps		= MMC_CAP_8_BIT_DATA | MMC_CAP_1_8V_DDR |
+				  MMC_CAP_UHS_DDR50,
+#elif defined(CONFIG_EXYNOS4_MSHC_8BIT)
+	.max_width		= 8,
+	.host_caps		= MMC_CAP_8_BIT_DATA,
+#elif defined(CONFIG_EXYNOS4_MSHC_DDR)
+	.host_caps		= MMC_CAP_1_8V_DDR | MMC_CAP_UHS_DDR50,
+#endif
+};
+#endif
+
+#ifdef CONFIG_USB_EHCI_S5P
+static struct s5p_ehci_platdata smdk4x12_ehci_pdata;
+
+static void __init smdk4x12_ehci_init(void)
+{
+	struct s5p_ehci_platdata *pdata = &smdk4x12_ehci_pdata;
+
+	s5p_ehci_set_platdata(pdata);
+}
+// USB3503A, HSIC1 -> USB Host
+#define GPIO_HUB_RESET EXYNOS4_GPL2(2)
+#define GPIO_HUB_CONNECT EXYNOS4_GPK3(2)
+#ifndef CONFIG_TC4_DVT
+#define I2C_SDA6 EXYNOS4_GPC1(3)
+#define I2C_SCL6 EXYNOS4_GPC1(4)
+#endif
+void usb_hub_gpio_init()
+{
+	//printk("shengliang set HUB_RESET & HUB_CONNECT\n");
+	// HUB_RESET
+	gpio_request(GPIO_HUB_RESET, "GPIO_HUB_RESET");
+	gpio_direction_output(GPIO_HUB_RESET, 1);
+	s3c_gpio_setpull(GPIO_HUB_RESET, S3C_GPIO_PULL_NONE);
+	gpio_free(GPIO_HUB_RESET);
+
+	// HUB_CONNECT
+	gpio_request(GPIO_HUB_CONNECT, "GPIO_HUB_CONNECT");
+	gpio_direction_output(GPIO_HUB_CONNECT, 1);
+	s3c_gpio_setpull(GPIO_HUB_CONNECT, S3C_GPIO_PULL_NONE);
+	gpio_free(GPIO_HUB_CONNECT);
+
+#ifndef CONFIG_TC4_DVT
+	// I2C_SDA6
+	gpio_request(I2C_SDA6, "I2C_SDA6");
+	gpio_direction_output(I2C_SDA6,1);
+	s3c_gpio_setpull(I2C_SDA6, S3C_GPIO_PULL_NONE);
+	gpio_free(I2C_SDA6);
+
+	// I2C_SCL6
+	gpio_request(I2C_SCL6, "I2C_SCL6");
+	gpio_direction_output(I2C_SCL6,1);
+	s3c_gpio_setpull(I2C_SCL6, S3C_GPIO_PULL_NONE);
+	gpio_free(I2C_SCL6);
+#endif
+}
+#endif
+
+#ifdef CONFIG_USB_OHCI_S5P
+static struct s5p_ohci_platdata smdk4x12_ohci_pdata;
+
+static void __init smdk4x12_ohci_init(void)
+{
+	struct s5p_ohci_platdata *pdata = &smdk4x12_ohci_pdata;
+
+	s5p_ohci_set_platdata(pdata);
+}
+#endif
+
+/* USB GADGET */
+#ifdef CONFIG_USB_GADGET
+static struct s5p_usbgadget_platdata smdk4x12_usbgadget_pdata;
+
+static void __init smdk4x12_usbgadget_init(void)
+{
+	struct s5p_usbgadget_platdata *pdata = &smdk4x12_usbgadget_pdata;
+
+	s5p_usbgadget_set_platdata(pdata);
+}
+#endif
+
+/* NFC */
+#ifdef	CONFIG_S3FHRN2
+#ifdef	CONFIG_S3FHRN2_I2C_GPIO
+#define GPIO_NFC_SDA	EXYNOS4_GPL2(4)
+#define GPIO_NFC_SCL	EXYNOS4_GPL2(3)
+#else
+#define GPIO_NFC_I2C	EXYNOS4_GPB(0)
+#endif
+#define GPIO_NFC_IRQ	EXYNOS4_GPX1(1)
+#define GPIO_NFC_VEN	EXYNOS4_GPL0(3)
+#define GPIO_NFC_FIRM	EXYNOS4_GPL2(5)
+
+static void exynos4_init_nfc_gpio(struct platform_device *dev)
+{
+#ifdef CONFIG_S3FHRN2_I2C
+#ifdef CONFIG_S3FHRN2_I2C_GPIO
+	s3c_gpio_cfgpin(GPIO_NFC_SDA, S3C_GPIO_INPUT);
+	s3c_gpio_setpull(GPIO_NFC_SDA, S3C_GPIO_PULL_NONE);
+	s5p_gpio_set_drvstr(GPIO_NFC_SDA, S5P_GPIO_DRVSTR_LV1);
+
+	s3c_gpio_cfgpin(GPIO_NFC_SCL, S3C_GPIO_INPUT);
+	s3c_gpio_setpull(GPIO_NFC_SCL, S3C_GPIO_PULL_NONE);
+	s5p_gpio_set_drvstr(GPIO_NFC_SCL, S5P_GPIO_DRVSTR_LV1);
+#else
+	s3c_gpio_cfgall_range(GPIO_NFC_I2C, 2,
+		S3C_GPIO_SFN(3), S3C_GPIO_PULL_UP);
+#endif
+	s3c_gpio_cfgpin(GPIO_NFC_IRQ, S3C_GPIO_SFN(0xF));
+	s3c_gpio_setpull(GPIO_NFC_IRQ, S3C_GPIO_PULL_NONE);
+	s5p_gpio_set_drvstr(GPIO_NFC_IRQ, S5P_GPIO_DRVSTR_LV1);
+#endif
+	s3c_gpio_cfgpin(GPIO_NFC_VEN, S3C_GPIO_OUTPUT);
+	s3c_gpio_setpull(GPIO_NFC_VEN, S3C_GPIO_PULL_NONE);
+	s5p_gpio_set_drvstr(GPIO_NFC_VEN, S5P_GPIO_DRVSTR_LV1);
+	s5p_gpio_set_pd_cfg(GPIO_NFC_VEN, S5P_GPIO_PD_PREV_STATE);
+
+	s3c_gpio_cfgpin(GPIO_NFC_FIRM, S3C_GPIO_OUTPUT);
+	s3c_gpio_setpull(GPIO_NFC_FIRM, S3C_GPIO_PULL_NONE);
+	s5p_gpio_set_drvstr(GPIO_NFC_FIRM, S5P_GPIO_DRVSTR_LV1);
+	s5p_gpio_set_pd_cfg(GPIO_NFC_FIRM, S5P_GPIO_PD_PREV_STATE);
+}
+#endif
+
+static struct s3fhrn2_platform_data exynos4_nfc_info = {
+#ifdef CONFIG_S3FHRN2_I2C
+	.irq = GPIO_NFC_IRQ,
+	.ven = GPIO_NFC_VEN,
+	.firm = GPIO_NFC_FIRM,
+	.cfg_gpio = exynos4_init_nfc_gpio,
+#endif
+};
+
+#ifdef CONFIG_S3FHRN2_I2C_GPIO
+static struct i2c_gpio_platform_data i2c_nfc_platdata = {
+	.sda_pin	= GPIO_NFC_SDA,
+	.scl_pin	= GPIO_NFC_SCL,
+	.udelay		= 2,
+	.sda_is_open_drain	= 0,
+	.scl_is_open_drain	= 0,
+	.scl_is_output_only	= 0,
+};
+
+static struct platform_device s3c_device_i2c_nfc_gpio = {
+	.name		=  "i2c-gpio",
+	//.id		= 4,
+	.id	= 2,
+	.dev.platform_data	= &i2c_nfc_platdata,
+};
+#endif
+
+#ifdef CONFIG_S3FHRN2_UART
+static struct platform_device s3c_device_nfc_uart = {
+	.name		= S3FHRN2_DRIVER_NAME,
+	.dev.platform_data	= &exynos4_nfc_info,
+};
+#endif
+static struct regulator_consumer_supply max8952_supply =
+	REGULATOR_SUPPLY("vdd_mif", NULL);
+
+static struct regulator_init_data max8952_init_data = {
+	.constraints	= {
+		.name		= "vdd_mif range",
+		.min_uV		= 850000,
+		.max_uV		= 1050000,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE,
+		.state_mem	= {
+			.uV		= 1100000,
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &max8952_supply,
+};
+
+static struct max8649_platform_data exynos4_max8952_info = {
+	.mode		= 1,	/* VID1 = 0, VID0 = 1 */
+	.extclk		= 0,
+	.ramp_timing	= MAX8649_RAMP_32MV,
+	.regulator	= &max8952_init_data,
+};
+
+/* max8997 -- modified by yulu@111122*/
+
+static struct regulator_consumer_supply max8997_buck1 =
+	REGULATOR_SUPPLY("vdd_arm", NULL);
+
+static struct regulator_consumer_supply max8997_buck2 =
+	REGULATOR_SUPPLY("vdd_int", NULL);
+
+static struct regulator_consumer_supply max8997_buck3 =
+	REGULATOR_SUPPLY("vdd_g3d", NULL);
+
+static struct regulator_consumer_supply max8997_buck4 =
+	REGULATOR_SUPPLY("vdd12_5m", NULL);
+
+static struct regulator_consumer_supply max8997_buck5 =
+	REGULATOR_SUPPLY("vdd_m12", NULL);
+
+static struct regulator_consumer_supply max8997_buck6 =
+	REGULATOR_SUPPLY("vdd33_lcd", NULL);
+
+static struct regulator_consumer_supply max8997_buck7 =
+	REGULATOR_SUPPLY("vdd_buck7", NULL);
+
+static struct regulator_consumer_supply max8997_boost =
+	REGULATOR_SUPPLY("vdd_50", NULL);
+
+static struct regulator_consumer_supply __initdata ldo1_consumer =
+	REGULATOR_SUPPLY("vdd18_hsic", NULL);
+
+static struct regulator_consumer_supply __initdata ldo2_consumer =
+	REGULATOR_SUPPLY("vdd_alive", NULL);
+
+static struct regulator_consumer_supply __initdata ldo3_consumer =
+	REGULATOR_SUPPLY("vdd_ldo3", NULL);
+
+static struct regulator_consumer_supply __initdata ldo4_consumer =
+	REGULATOR_SUPPLY("vdd_ldo4", NULL);
+
+static struct regulator_consumer_supply __initdata ldo5_consumer =
+	REGULATOR_SUPPLY("vdd18_abb", NULL);
+
+static struct regulator_consumer_supply __initdata ldo6_consumer =
+	REGULATOR_SUPPLY("vddioap_18", NULL);
+
+static struct regulator_consumer_supply __initdata ldo7_consumer =
+	REGULATOR_SUPPLY("vddioperi_18", NULL);
+
+static struct regulator_consumer_supply __initdata ldo8_consumer =
+	REGULATOR_SUPPLY("vdd33_uotg", NULL);
+
+static struct regulator_consumer_supply __initdata ldo9_consumer =
+	REGULATOR_SUPPLY("vdd_sys", NULL);
+
+static struct regulator_consumer_supply __initdata ldo10_consumer =
+	REGULATOR_SUPPLY("vdd_pll", NULL);
+
+static struct regulator_consumer_supply __initdata ldo11_consumer =
+	REGULATOR_SUPPLY("vdd10_ush", NULL);
+
+static struct regulator_consumer_supply __initdata ldo12_consumer =
+	REGULATOR_SUPPLY("vdd18_cam", NULL);
+
+static struct regulator_consumer_supply __initdata ldo13_consumer =
+	REGULATOR_SUPPLY("vdd10_mipi", NULL);
+
+static struct regulator_consumer_supply __initdata ldo14_consumer =
+	REGULATOR_SUPPLY("vdd18_mipi", NULL);
+
+static struct regulator_consumer_supply __initdata ldo15_consumer =
+	REGULATOR_SUPPLY("vdd28_af", NULL);
+
+static struct regulator_consumer_supply __initdata ldo16_consumer =
+	REGULATOR_SUPPLY("vdd28_cam", NULL);
+
+static struct regulator_consumer_supply __initdata ldo17_consumer =
+	REGULATOR_SUPPLY("vdd33_a31", NULL);
+
+static struct regulator_consumer_supply __initdata ldo18_consumer =
+	REGULATOR_SUPPLY("vdd18_a31", NULL);
+
+static struct regulator_consumer_supply __initdata ldo21_consumer =
+	REGULATOR_SUPPLY("vddq_m12", NULL);
+
+
+/*#define REGULATOR_INIT(_ldo, _name, _min_uV, _max_uV, _always_on, _ops_mask,\
+		_disabled) \
+	static struct regulator_init_data _ldo##_init_data = {		\
+		.constraints = {					\
+			.name	= _name,				\
+			.min_uV = _min_uV,				\
+			.max_uV = _max_uV,				\
+			.always_on	= _always_on,			\
+			.boot_on	= _always_on,			\
+			.apply_uV	= 1,				\
+			.valid_ops_mask = _ops_mask,			\
+			.state_mem	= {				\
+				.disabled	= _disabled,		\
+				.enabled	= !(_disabled),		\
+			}						\
+		},							\
+		.num_consumer_supplies = ARRAY_SIZE(_ldo##_supply),	\
+		.consumer_supplies = &_ldo##_supply[0],			\
+	};
+*/
+
+static struct regulator_init_data __initdata max8997_ldo1_data = {
+	.constraints	= {
+		.name		= "vdd18_hsic",
+		.min_uV		= 1800000,
+		.max_uV		= 1800000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo1_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo2_data = {
+	.constraints	= {
+		.name		= "vdd_alive",
+		.min_uV		= 1000000,
+		.max_uV		= 1000000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 0,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo2_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo3_data = {
+	.constraints	= {
+		.name		= "vdd_ldo3",
+		.min_uV		= 1000000,
+		.max_uV		= 1000000,
+		.apply_uV	= 1,
+		.always_on	= 0,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo3_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo4_data = {
+	.constraints	= {
+		.name		= "vdd_ldo4",
+		.min_uV		= 1800000,
+		.max_uV		= 1800000,
+		.apply_uV	= 1,
+		.always_on	= 0,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo4_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo5_data = {
+	.constraints	= {
+		.name		= "vdd18_abb",
+		.min_uV		= 1800000,
+		.max_uV		= 1800000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo5_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo6_data = {
+	.constraints	= {
+		.name		= "vddioap_18",
+		.min_uV		= 1800000,
+		.max_uV		= 1800000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 0,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo6_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo7_data = {
+	.constraints	= {
+		.name		= "vddioperi_18",
+		.min_uV		= 1800000,
+		.max_uV		= 1800000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 0,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo7_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo8_data = {
+	.constraints	= {
+		.name		= "vdd33_uotg",
+		.min_uV		= 3300000,
+		.max_uV		= 3300000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo8_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo9_data = {
+	.constraints	= {
+		.name		= "vdd_sys",
+		.min_uV		= 3000000,
+		.max_uV		= 3000000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE|REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 0,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo9_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo10_data = {
+	.constraints	= {
+		.name		= "vdd_pll",
+		.min_uV		= 1000000,
+		.max_uV		= 1000000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo10_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo11_data = {
+	.constraints	= {
+		.name		= "vdd10_ush",
+		.min_uV		= 1000000,
+		.max_uV		= 1000000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo11_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo12_data = {
+	.constraints	= {
+		.name		= "vdd18_cam",
+		.min_uV		= 1800000,
+		.max_uV		= 1800000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo12_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo13_data = {
+	.constraints	= {
+		.name		= "vdd10_mipi",
+		.min_uV		= 1000000,
+		.max_uV		= 1000000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo13_consumer,
+};
+
+
+static struct regulator_init_data __initdata max8997_ldo14_data = {
+	.constraints	= {
+		.name		= "vdd18_mipi",
+		.min_uV		= 1800000,
+		.max_uV		= 1800000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo14_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo15_data = {
+	.constraints	= {
+		.name		= "vdd28_af",
+		.min_uV		= 2800000,
+		.max_uV		= 2800000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo15_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo16_data = {
+	.constraints	= {
+		.name		= "vdd28_cam",
+		.min_uV		= 2800000,
+		.max_uV		= 2800000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo16_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo17_data = {
+	.constraints	= {
+		.name		= "vdd33_a31",
+		.min_uV		= 3300000,
+		.max_uV		= 3300000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo17_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo18_data = {
+	.constraints	= {
+		.name		= "vdd18_a31",
+		.min_uV		= 1800000,
+		.max_uV		= 1800000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo18_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_ldo21_data = {
+	.constraints	= {
+		.name		= "vddq_m12",
+		.min_uV		= 1200000,
+		.max_uV		= 1200000,
+		.apply_uV	= 1,
+		.always_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &ldo21_consumer,
+};
+
+static struct regulator_init_data __initdata max8997_buck1_data = {
+	.constraints	= {
+		.name		= "vdd_arm range",
+		.min_uV		= 925000,
+		.max_uV		= 1400000,
+		.always_on	= 1,
+		.boot_on		= 1,
+		.apply_uV	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE|
+					REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.mode = REGULATOR_MODE_NORMAL,
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &max8997_buck1,
+};
+
+static struct regulator_init_data __initdata max8997_buck2_data = {
+	.constraints	= {
+		.name		= "vdd_int range",
+		.min_uV		= 950000,
+		.max_uV		= 1200000,
+		.always_on	= 1,
+		.boot_on		= 1,
+		.apply_uV	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE|
+					REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.mode = REGULATOR_MODE_NORMAL,
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &max8997_buck2,
+};
+
+static struct regulator_init_data __initdata max8997_buck3_data = {
+	.constraints	= {
+		.name		= "vdd_g3d",
+		.min_uV		= 1150000,			//1150000
+		.max_uV		= 1150000,
+		.always_on	= 1,
+		.boot_on		= 1,
+		.apply_uV	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.mode = REGULATOR_MODE_NORMAL,
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &max8997_buck3,
+};
+
+static struct regulator_init_data __initdata max8997_buck4_data = {
+	.constraints	= {
+		.name		= "vdd12_5m",
+		.min_uV		= 1200000,
+		.max_uV		= 1200000,
+		.always_on	= 1,
+		.boot_on		= 1,
+		.apply_uV	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &max8997_buck4,
+};
+
+static struct regulator_init_data __initdata max8997_buck5_data = {
+	.constraints	= {
+		.name		= "vdd_m12",
+		.min_uV		= 1200000,
+		.max_uV		= 1200000,
+		.always_on	= 1,
+		.boot_on		= 1,
+		.apply_uV	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.mode = REGULATOR_MODE_NORMAL,
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &max8997_buck5,
+};
+
+static struct regulator_init_data __initdata max8997_buck6_data = {
+	.constraints	= {
+		.name		= "vdd33_lcd",
+		.min_uV		= 3300000,
+		.max_uV		= 3300000,
+		.always_on	= 1,
+		.boot_on		= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.mode = REGULATOR_MODE_NORMAL,
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &max8997_buck6,
+};
+
+static struct regulator_init_data __initdata max8997_buck7_data = {
+	.constraints	= {
+		.name		= "vdd_buck7",
+		.min_uV		= 2000000,
+		.max_uV		= 2000000,
+		.always_on	= 1,
+		.boot_on		= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &max8997_buck7,
+};
+
+static struct regulator_init_data __initdata max8997_boost_data = {
+	.constraints	= {
+		.name		= "vdd_50",
+		.min_uA		= 23440,
+		.max_uA		= 750000,
+		.valid_ops_mask	= REGULATOR_CHANGE_CURRENT |
+				REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &max8997_boost,
+};
+
+
+
+static struct max8997_regulator_data __initdata max8997_regulators[] = {
+	{ MAX8997_LDO1, &max8997_ldo1_data, },	
+	{ MAX8997_LDO2, &max8997_ldo2_data, },
+	//{ MAX8997_LDO3, &max8997_ldo3_data, },
+	//{ MAX8997_LDO4, &max8997_ldo4_data, },
+	{ MAX8997_LDO5, &max8997_ldo5_data, },
+	{ MAX8997_LDO6, &max8997_ldo6_data, },	
+	{ MAX8997_LDO7, &max8997_ldo7_data, },
+	{ MAX8997_LDO8, &max8997_ldo8_data, },
+	//{ MAX8997_LDO9, &max8997_ldo9_data, },
+	{ MAX8997_LDO10, &max8997_ldo10_data, },
+	{ MAX8997_LDO11, &max8997_ldo11_data, },
+	{ MAX8997_LDO12, &max8997_ldo12_data, },
+	{ MAX8997_LDO13, &max8997_ldo13_data, },
+	{ MAX8997_LDO14, &max8997_ldo14_data, },
+	{ MAX8997_LDO15, &max8997_ldo15_data, },
+	{ MAX8997_LDO16, &max8997_ldo16_data, },
+	{ MAX8997_LDO17, &max8997_ldo17_data, },
+	{ MAX8997_LDO18, &max8997_ldo18_data, },
+	{ MAX8997_LDO21, &max8997_ldo21_data, },
+	{ MAX8997_BUCK1, &max8997_buck1_data, },
+	{ MAX8997_BUCK2, &max8997_buck2_data, },
+	{ MAX8997_BUCK3, &max8997_buck3_data, },
+	{ MAX8997_BUCK4, &max8997_buck4_data, },
+	{ MAX8997_BUCK5, &max8997_buck5_data, },
+	{ MAX8997_BUCK6, &max8997_buck6_data, },
+	{ MAX8997_BUCK7, &max8997_buck7_data, },	
+	{ MAX8997_BOOST, &max8997_boost_data, },		
+};
+
+static struct max8997_platform_data __initdata exynos4_max8997_info = {
+	.num_regulators = ARRAY_SIZE(max8997_regulators),
+	.regulators     = max8997_regulators,
+	//.irq_base	= IRQ_BOARD_START,	
+	//.wakeup		= 1,
+	#if 1
+	.buck1_voltage[0] = 1200000, /* 1.1V */
+	.buck1_voltage[1] = 1150000, /* 1.1V */
+	.buck1_voltage[2] = 1125000, /* 1.1V */
+	.buck1_voltage[3] = 1100000, /* 1.1V */
+	.buck1_voltage[4] = 1050000, /* 1.1V */
+	.buck1_voltage[5] = 1000000, /* 1.1V */
+	.buck1_voltage[6] = 950000, /* 1.0V */
+	.buck1_voltage[7] = 950000, /* 0.95V */
+
+	.buck2_voltage[0] = 1100000, /* 1.1V */
+	.buck2_voltage[1] = 1100000, /* 1.0V */
+	.buck2_voltage[2] = 1100000, /* 0.95V */
+	.buck2_voltage[3] = 1100000, /* 0.9V */
+	.buck2_voltage[4] = 1000000, /* 1.1V */
+	.buck2_voltage[5] = 1000000, /* 1.0V */
+	.buck2_voltage[6] = 1000000, /* 0.95V */
+	.buck2_voltage[7] = 1000000, /* 0.9V */
+
+	.buck5_voltage[0] = 1200000, /* 1.1V */
+	.buck5_voltage[1] = 1200000, /* 1.1V */
+	.buck5_voltage[2] = 1200000, /* 1.1V */
+	.buck5_voltage[3] = 1200000, /* 1.1V */
+	.buck5_voltage[4] = 1100000, /* 1.1V */
+	.buck5_voltage[5] = 1100000, /* 1.1V */
+	.buck5_voltage[6] = 1100000, /* 1.1V */
+	.buck5_voltage[7] = 1100000, /* 1.1V */
+	.buck1_gpiodvs = false,
+	.buck2_gpiodvs = false,
+	.buck5_gpiodvs = false,
+	.buck125_gpios[0] = EXYNOS4_GPB(5),
+	.buck125_gpios[1] = EXYNOS4_GPB(6),
+	.buck125_gpios[2] = EXYNOS4_GPB(7),
+#endif
+
+};
+static struct platform_device tc4_regulator_consumer = 
+	{	.name = "tc4-regulator-consumer",	
+		.id = -1,
+	};
+
+
+#ifdef CONFIG_REGULATOR_S5M8767
+/* S5M8767 Regulator */
+static int s5m_cfg_irq(void)
+{
+	/* AP_PMIC_IRQ: EINT15 */
+	s3c_gpio_cfgpin(EXYNOS4_GPX1(7), S3C_GPIO_SFN(0xF));
+	s3c_gpio_setpull(EXYNOS4_GPX1(7), S3C_GPIO_PULL_UP);
+	return 0;
+}
+static struct regulator_consumer_supply s5m8767_ldo1_supply[] = {
+	REGULATOR_SUPPLY("vdd_alive", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo2_supply[] = {
+	REGULATOR_SUPPLY("vddq_m12", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo3_supply[] = {
+	REGULATOR_SUPPLY("vddioap_18", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo4_supply[] = {
+	REGULATOR_SUPPLY("vddq_pre", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo5_supply[] = {
+	REGULATOR_SUPPLY("vdd18_2m", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo6_supply[] = {
+	REGULATOR_SUPPLY("vdd10_mpll", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo7_supply[] = {
+	REGULATOR_SUPPLY("vdd10_xpll", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo8_supply[] = {
+	REGULATOR_SUPPLY("vdd10_mipi", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo9_supply[] = {
+	REGULATOR_SUPPLY("vdd33_lcd", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo10_supply[] = {
+	REGULATOR_SUPPLY("vdd18_mipi", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo11_supply[] = {
+	REGULATOR_SUPPLY("vdd18_abb1", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo12_supply[] = {
+	REGULATOR_SUPPLY("vdd33_uotg", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo13_supply[] = {
+	REGULATOR_SUPPLY("vddioperi_18", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo14_supply[] = {
+	REGULATOR_SUPPLY("vdd18_abb02", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo15_supply[] = {
+	REGULATOR_SUPPLY("vdd10_ush", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo16_supply[] = {
+	REGULATOR_SUPPLY("vdd18_hsic", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo17_supply[] = {
+	REGULATOR_SUPPLY("vddioap_mmc012_28", NULL),
+};
+static struct regulator_consumer_supply s5m8767_ldo18_supply[] = {
+	REGULATOR_SUPPLY("vddioperi_28", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo19_supply[] = {
+	REGULATOR_SUPPLY("dvdd25", NULL),
+};
+
+
+static struct regulator_consumer_supply s5m8767_ldo20_supply[] = {
+	REGULATOR_SUPPLY("vdd28_cam", NULL),
+};
+static struct regulator_consumer_supply s5m8767_ldo21_supply[] = {
+	REGULATOR_SUPPLY("vdd28_af", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo22_supply[] = {
+	REGULATOR_SUPPLY("vdda28_2m", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo23_supply[] = {
+	REGULATOR_SUPPLY("vdd_tf", NULL),
+};
+
+
+static struct regulator_consumer_supply s5m8767_ldo24_supply[] = {
+	REGULATOR_SUPPLY("vdd33_a31", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo25_supply[] = {
+	REGULATOR_SUPPLY("vdd18_cam", NULL),
+};
+
+static struct regulator_consumer_supply s5m8767_ldo26_supply[] = {
+	REGULATOR_SUPPLY("vdd18_a31", NULL),
+};
+static struct regulator_consumer_supply s5m8767_ldo27_supply[] = {
+	REGULATOR_SUPPLY("gps_1v8", NULL),
+};
+static struct regulator_consumer_supply s5m8767_ldo28_supply[] = {
+	REGULATOR_SUPPLY("dvdd12", NULL),
+};
+
+
+static struct regulator_consumer_supply s5m8767_buck1_consumer =
+	REGULATOR_SUPPLY("vdd_mif", NULL);
+
+static struct regulator_consumer_supply s5m8767_buck2_consumer =
+	REGULATOR_SUPPLY("vdd_arm", NULL);
+
+static struct regulator_consumer_supply s5m8767_buck3_consumer =
+	REGULATOR_SUPPLY("vdd_int", NULL);
+
+static struct regulator_consumer_supply s5m8767_buck4_consumer =
+	REGULATOR_SUPPLY("vdd_g3d", NULL);
+
+static struct regulator_consumer_supply s5m8767_buck5_consumer =
+	REGULATOR_SUPPLY("vdd_m12", NULL);
+static struct regulator_consumer_supply s5m8767_buck6_consumer =
+	REGULATOR_SUPPLY("vdd12_5m", NULL);
+
+static struct regulator_consumer_supply s5m8767_buck9_consumer =
+	REGULATOR_SUPPLY("vddf28_emmc", NULL);
+
+
+
+#define REGULATOR_INIT(_ldo, _name, _min_uV, _max_uV, _always_on, _ops_mask,\
+		_disabled) \
+	static struct regulator_init_data s5m8767_##_ldo##_init_data = {		\
+		.constraints = {					\
+			.name	= _name,				\
+			.min_uV = _min_uV,				\
+			.max_uV = _max_uV,				\
+			.always_on	= _always_on,			\
+			.boot_on	= _always_on,			\
+			.apply_uV	= 1,				\
+			.valid_ops_mask = _ops_mask,			\
+			.state_mem	= {				\
+				.disabled	= _disabled,		\
+				.enabled	= !(_disabled),		\
+			}						\
+		},							\
+		.num_consumer_supplies = ARRAY_SIZE(s5m8767_##_ldo##_supply),	\
+		.consumer_supplies = &s5m8767_##_ldo##_supply[0],			\
+	};
+
+REGULATOR_INIT(ldo1, "VDD_ALIVE", 1100000, 1100000, 1,
+		REGULATOR_CHANGE_STATUS, 0);
+REGULATOR_INIT(ldo2, "VDDQ_M12", 1200000, 1200000, 1,
+		REGULATOR_CHANGE_STATUS, 1);//sleep controlled by pwren
+REGULATOR_INIT(ldo3, "VDDIOAP_18", 1800000, 1800000, 1,
+		REGULATOR_CHANGE_STATUS, 0);
+REGULATOR_INIT(ldo4, "VDDQ_PRE", 1800000, 1800000, 1,
+		REGULATOR_CHANGE_STATUS, 1); //sleep controlled by pwren
+
+REGULATOR_INIT(ldo5, "VDD18_2M", 1800000, 1800000, 0,
+		REGULATOR_CHANGE_STATUS, 1);
+REGULATOR_INIT(ldo6, "VDD10_MPLL", 1000000, 1000000, 1,
+		REGULATOR_CHANGE_STATUS, 1);//sleep controlled by pwren
+REGULATOR_INIT(ldo7, "VDD10_XPLL", 1000000, 1000000, 1,
+		REGULATOR_CHANGE_STATUS, 1);//sleep controlled by pwren
+REGULATOR_INIT(ldo8, "VDD10_MIPI", 1000000, 1000000, 0,
+		REGULATOR_CHANGE_STATUS, 1);
+REGULATOR_INIT(ldo9, "VDD33_LCD", 3300000, 3300000, 1,
+		REGULATOR_CHANGE_STATUS, 1);
+
+
+REGULATOR_INIT(ldo10, "VDD18_MIPI", 1800000, 1800000, 0,
+		REGULATOR_CHANGE_STATUS, 1);
+REGULATOR_INIT(ldo11, "VDD18_ABB1", 1800000, 1800000, 1,
+		REGULATOR_CHANGE_STATUS, 0); //???
+REGULATOR_INIT(ldo12, "VDD33_UOTG", 3300000, 3300000, 1,
+		REGULATOR_CHANGE_STATUS, 0);
+REGULATOR_INIT(ldo13, "VDDIOPERI_18", 1800000, 1800000, 1,
+		REGULATOR_CHANGE_STATUS, 0);//???
+REGULATOR_INIT(ldo14, "VDD18_ABB02", 1800000, 1800000, 1,
+		REGULATOR_CHANGE_STATUS, 0); //???
+REGULATOR_INIT(ldo15, "VDD10_USH", 1000000, 1000000, 1,
+		REGULATOR_CHANGE_STATUS, 1);
+
+//liang, VDD18_HSIC must be 1.8V, otherwise USB HUB 3503A can't be recognized
+REGULATOR_INIT(ldo16, "VDD18_HSIC", 1800000, 1800000, 1,
+		REGULATOR_CHANGE_STATUS, 1);
+REGULATOR_INIT(ldo17, "VDDIOAP_MMC012_28", 2800000, 2800000, 1,
+		REGULATOR_CHANGE_STATUS, 0); //???
+REGULATOR_INIT(ldo18, "VDDIOPERI_28", 2800000, 2800000, 1,
+		REGULATOR_CHANGE_STATUS, 0);//???
+REGULATOR_INIT(ldo19, "DVDD25", 2500000, 2500000, 0,
+		REGULATOR_CHANGE_STATUS, 1); //??
+REGULATOR_INIT(ldo20, "VDD28_CAM", 2800000, 2800000, 0,
+		REGULATOR_CHANGE_STATUS, 1);
+
+REGULATOR_INIT(ldo21, "VDD28_AF", 2800000, 2800000, 0,
+		REGULATOR_CHANGE_STATUS, 1);
+REGULATOR_INIT(ldo22, "VDDA28_2M", 2800000, 2800000, 0,
+		REGULATOR_CHANGE_STATUS, 1);
+REGULATOR_INIT(ldo23, "VDD28_TF", 2800000, 2800000, 1,
+		REGULATOR_CHANGE_STATUS, 1);//sleep controlled by pwren
+REGULATOR_INIT(ldo24, "VDD33_A31", 3300000, 3300000, 1,
+		REGULATOR_CHANGE_STATUS, 0);
+REGULATOR_INIT(ldo25, "VDD18_CAM", 1800000, 1800000, 0,
+		REGULATOR_CHANGE_STATUS, 1);
+REGULATOR_INIT(ldo26, "VDD18_A31", 1800000, 1800000, 1,
+		REGULATOR_CHANGE_STATUS, 0);
+REGULATOR_INIT(ldo27, "GPS_1V8", 1800000, 1800000, 1,
+		REGULATOR_CHANGE_STATUS, 1);
+REGULATOR_INIT(ldo28, "DVDD12", 1200000, 1200000, 0,
+		REGULATOR_CHANGE_STATUS, 1);
+
+
+static struct regulator_init_data s5m8767_buck1_data = {
+	.constraints	= {
+		.name		= "vdd_mif range",
+		.min_uV		= 900000,
+		.max_uV		= 1100000,
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE |
+				  REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &s5m8767_buck1_consumer,
+};
+
+static struct regulator_init_data s5m8767_buck2_data = {
+	.constraints	= {
+		.name		= "vdd_arm range",
+		.min_uV		=  850000,
+		.max_uV		= 1450000,
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE |
+				  REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &s5m8767_buck2_consumer,
+};
+
+static struct regulator_init_data s5m8767_buck3_data = {
+	.constraints	= {
+		.name		= "vdd_int range",
+		.min_uV		=  875000,
+		.max_uV		= 1200000,
+		.apply_uV	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE |
+				REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			//.uV		= 1100000,
+			.mode		= REGULATOR_MODE_NORMAL,
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &s5m8767_buck3_consumer,
+};
+
+static struct regulator_init_data s5m8767_buck4_data = {
+	.constraints	= {
+		.name		= "vdd_g3d range",
+		.min_uV		= 750000,
+		.max_uV		= 1500000,
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE |
+				REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies = 1,
+	.consumer_supplies = &s5m8767_buck4_consumer,
+};
+
+static struct regulator_init_data s5m8767_buck5_data = {
+	.constraints	= {
+		.name		= "vdd_m12 range",
+		.min_uV		= 750000,
+		.max_uV		= 1500000,
+		.apply_uV	= 1,
+		.boot_on	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE |
+				REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.enabled	= 1,
+		},
+	},
+	.num_consumer_supplies = 1,
+	.consumer_supplies = &s5m8767_buck5_consumer,
+};
+static struct regulator_init_data s5m8767_buck6_data = {
+	.constraints	= {
+		.name		= "vdd12_5m range",
+		.min_uV		= 750000,
+		.max_uV		= 1500000,
+		.boot_on	= 0,
+		.apply_uV	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE |
+				REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies = 1,
+	.consumer_supplies = &s5m8767_buck6_consumer,
+};
+static struct regulator_init_data s5m8767_buck9_data = {
+	.constraints	= {
+		.name		= "vddf28_emmc range",
+		.min_uV		= 750000,
+		.max_uV		= 3000000,
+		.boot_on	= 1,
+		.apply_uV	= 1,
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE |
+				REGULATOR_CHANGE_STATUS,
+		.state_mem	= {
+			.disabled	= 1,
+		},
+	},
+	.num_consumer_supplies = 1,
+	.consumer_supplies = &s5m8767_buck9_consumer,
+};
+
+
+
+
+static struct s5m_regulator_data pegasus_regulators[] = {
+	{ S5M8767_BUCK1, &s5m8767_buck1_data },
+	{ S5M8767_BUCK2, &s5m8767_buck2_data },
+	{ S5M8767_BUCK3, &s5m8767_buck3_data },
+	{ S5M8767_BUCK4, &s5m8767_buck4_data },
+	{ S5M8767_BUCK5, &s5m8767_buck5_data },
+	{ S5M8767_BUCK6, &s5m8767_buck6_data },
+	{ S5M8767_BUCK9, &s5m8767_buck9_data },
+
+	{ S5M8767_LDO1, &s5m8767_ldo1_init_data },
+	{ S5M8767_LDO2, &s5m8767_ldo2_init_data },
+	{ S5M8767_LDO3, &s5m8767_ldo3_init_data },
+	{ S5M8767_LDO4, &s5m8767_ldo4_init_data },
+	{ S5M8767_LDO5, &s5m8767_ldo5_init_data },
+	{ S5M8767_LDO6, &s5m8767_ldo6_init_data },
+	{ S5M8767_LDO7, &s5m8767_ldo7_init_data },
+	{ S5M8767_LDO8, &s5m8767_ldo8_init_data },
+	{ S5M8767_LDO9, &s5m8767_ldo9_init_data },
+	{ S5M8767_LDO10, &s5m8767_ldo10_init_data },
+
+	{ S5M8767_LDO11, &s5m8767_ldo11_init_data },
+	{ S5M8767_LDO12, &s5m8767_ldo12_init_data },
+	{ S5M8767_LDO13, &s5m8767_ldo13_init_data },
+	{ S5M8767_LDO14, &s5m8767_ldo14_init_data },
+	{ S5M8767_LDO15, &s5m8767_ldo15_init_data },
+	{ S5M8767_LDO16, &s5m8767_ldo16_init_data },
+	{ S5M8767_LDO17, &s5m8767_ldo17_init_data },
+	{ S5M8767_LDO18, &s5m8767_ldo18_init_data },
+	{ S5M8767_LDO19, &s5m8767_ldo19_init_data },
+	{ S5M8767_LDO20, &s5m8767_ldo20_init_data },
+
+	{ S5M8767_LDO21, &s5m8767_ldo21_init_data },
+	{ S5M8767_LDO22, &s5m8767_ldo22_init_data },
+	{ S5M8767_LDO23, &s5m8767_ldo23_init_data },
+	{ S5M8767_LDO24, &s5m8767_ldo24_init_data },
+	{ S5M8767_LDO25, &s5m8767_ldo25_init_data },
+	{ S5M8767_LDO26, &s5m8767_ldo26_init_data },
+	{ S5M8767_LDO27, &s5m8767_ldo27_init_data },
+	{ S5M8767_LDO28, &s5m8767_ldo28_init_data },
+	
+	
+};
+
+static struct s5m_platform_data exynos4_s5m8767_pdata = {
+	.device_type		= S5M8767X,
+	.irq_base		= IRQ_BOARD_START,
+	.num_regulators		= ARRAY_SIZE(pegasus_regulators),
+	.regulators		= pegasus_regulators,
+	.cfg_pmic_irq		= s5m_cfg_irq,
+
+	.buck2_voltage[0]	= 1250000,
+	.buck2_voltage[1]	= 1200000,
+	.buck2_voltage[2]	= 1200000,
+	.buck2_voltage[3]	= 1200000,
+	.buck2_voltage[4]	= 1200000,
+	.buck2_voltage[5]	= 1200000,
+	.buck2_voltage[6]	=  1200000,
+	.buck2_voltage[7]	=  1200000,
+
+	.buck3_voltage[0]	= 1100000,
+	.buck3_voltage[1]	= 1100000,
+	.buck3_voltage[2]	= 1100000,
+	.buck3_voltage[3]	= 1100000,
+	.buck3_voltage[4]	= 1100000,
+	.buck3_voltage[5]	= 1100000,
+	.buck3_voltage[6]	= 1100000,
+	.buck3_voltage[7]	= 1100000,
+
+	.buck4_voltage[0]	= 1200000,
+	.buck4_voltage[1]	= 1200000,
+	.buck4_voltage[2]	= 1200000,
+	.buck4_voltage[3]	= 1200000,
+	.buck4_voltage[4]	= 1200000,
+	.buck4_voltage[5]	= 1200000,
+	.buck4_voltage[6]	= 1200000,
+	.buck4_voltage[7]	= 1200000,
+
+	.buck_default_idx	= 3,
+	.buck_gpios[0]		= EXYNOS4_GPX2(5),
+	.buck_gpios[1]		= EXYNOS4_GPX2(6),
+	.buck_gpios[2]		= EXYNOS4_GPX2(7),
+
+	.buck_ramp_delay        = 10,
+	.buck2_ramp_enable      = true,
+	.buck3_ramp_enable      = true,
+	.buck4_ramp_enable      = true,
+};
+/* End of S5M8767 */
+#endif
+
+#ifdef CONFIG_VIDEO_S5P_MIPI_CSIS
+static struct regulator_consumer_supply mipi_csi_fixed_voltage_supplies[] = {
+	REGULATOR_SUPPLY("mipi_csi", "s5p-mipi-csis.0"),
+	REGULATOR_SUPPLY("mipi_csi", "s5p-mipi-csis.1"),
+};
+
+static struct regulator_init_data mipi_csi_fixed_voltage_init_data = {
+	.constraints = {
+		.always_on = 1,
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(mipi_csi_fixed_voltage_supplies),
+	.consumer_supplies	= mipi_csi_fixed_voltage_supplies,
+};
+
+static struct fixed_voltage_config mipi_csi_fixed_voltage_config = {
+	.supply_name	= "DC_5V",
+	.microvolts	= 5000000,
+	.gpio		= -EINVAL,
+	.init_data	= &mipi_csi_fixed_voltage_init_data,
+};
+
+static struct platform_device mipi_csi_fixed_voltage = {
+	.name		= "reg-fixed-voltage",
+	.id		= 3,
+	.dev		= {
+		.platform_data	= &mipi_csi_fixed_voltage_config,
+	},
+};
+#endif
+
+#ifdef CONFIG_VIDEO_M5MOLS
+static struct regulator_consumer_supply m5mols_fixed_voltage_supplies[] = {
+	REGULATOR_SUPPLY("core", NULL),
+	REGULATOR_SUPPLY("dig_18", NULL),
+	REGULATOR_SUPPLY("d_sensor", NULL),
+	REGULATOR_SUPPLY("dig_28", NULL),
+	REGULATOR_SUPPLY("a_sensor", NULL),
+	REGULATOR_SUPPLY("dig_12", NULL),
+};
+
+static struct regulator_init_data m5mols_fixed_voltage_init_data = {
+	.constraints = {
+		.always_on = 1,
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(m5mols_fixed_voltage_supplies),
+	.consumer_supplies	= m5mols_fixed_voltage_supplies,
+};
+
+static struct fixed_voltage_config m5mols_fixed_voltage_config = {
+	.supply_name	= "CAM_SENSOR",
+	.microvolts	= 1800000,
+	.gpio		= -EINVAL,
+	.init_data	= &m5mols_fixed_voltage_init_data,
+};
+
+static struct platform_device m5mols_fixed_voltage = {
+	.name		= "reg-fixed-voltage",
+	.id		= 4,
+	.dev		= {
+		.platform_data	= &m5mols_fixed_voltage_config,
+	},
+};
+#endif
+
+static struct regulator_consumer_supply wm8994_fixed_voltage0_supplies[] = {
+	REGULATOR_SUPPLY("AVDD2", "4-001a"),
+	REGULATOR_SUPPLY("CPVDD", "4-001a"),
+};
+
+static struct regulator_consumer_supply wm8994_fixed_voltage1_supplies[] = {
+	REGULATOR_SUPPLY("SPKVDD1", "4-001a"),
+	REGULATOR_SUPPLY("SPKVDD2", "4-001a"),
+};
+
+static struct regulator_consumer_supply wm8994_fixed_voltage2_supplies =
+	REGULATOR_SUPPLY("DBVDD", "4-001a");
+
+static struct regulator_init_data wm8994_fixed_voltage0_init_data = {
+	.constraints = {
+		.always_on = 1,
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(wm8994_fixed_voltage0_supplies),
+	.consumer_supplies	= wm8994_fixed_voltage0_supplies,
+};
+
+static struct regulator_init_data wm8994_fixed_voltage1_init_data = {
+	.constraints = {
+		.always_on = 1,
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(wm8994_fixed_voltage1_supplies),
+	.consumer_supplies	= wm8994_fixed_voltage1_supplies,
+};
+
+static struct regulator_init_data wm8994_fixed_voltage2_init_data = {
+	.constraints = {
+		.always_on = 1,
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &wm8994_fixed_voltage2_supplies,
+};
+
+static struct fixed_voltage_config wm8994_fixed_voltage0_config = {
+	.supply_name	= "VDD_1.8V",
+	.microvolts	= 1800000,
+	.gpio		= -EINVAL,
+	.init_data	= &wm8994_fixed_voltage0_init_data,
+};
+
+static struct fixed_voltage_config wm8994_fixed_voltage1_config = {
+	.supply_name	= "DC_5V",
+	.microvolts	= 5000000,
+	.gpio		= -EINVAL,
+	.init_data	= &wm8994_fixed_voltage1_init_data,
+};
+
+static struct fixed_voltage_config wm8994_fixed_voltage2_config = {
+	.supply_name	= "VDD_3.3V",
+	.microvolts	= 3300000,
+	.gpio		= -EINVAL,
+	.init_data	= &wm8994_fixed_voltage2_init_data,
+};
+
+static struct platform_device wm8994_fixed_voltage0 = {
+	.name		= "reg-fixed-voltage",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &wm8994_fixed_voltage0_config,
+	},
+};
+
+static struct platform_device wm8994_fixed_voltage1 = {
+	.name		= "reg-fixed-voltage",
+	.id		= 1,
+	.dev		= {
+		.platform_data	= &wm8994_fixed_voltage1_config,
+	},
+};
+
+static struct platform_device wm8994_fixed_voltage2 = {
+	.name		= "reg-fixed-voltage",
+	.id		= 2,
+	.dev		= {
+		.platform_data	= &wm8994_fixed_voltage2_config,
+	},
+};
+
+static struct regulator_consumer_supply wm8994_avdd1_supply =
+	REGULATOR_SUPPLY("AVDD1", "4-001a");
+
+static struct regulator_consumer_supply wm8994_dcvdd_supply =
+	REGULATOR_SUPPLY("DCVDD", "4-001a");
+
+static struct regulator_init_data wm8994_ldo1_data = {
+	.constraints	= {
+		.name		= "AVDD1",
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &wm8994_avdd1_supply,
+};
+
+static struct regulator_init_data wm8994_ldo2_data = {
+	.constraints	= {
+		.name		= "DCVDD",
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &wm8994_dcvdd_supply,
+};
+
+static struct wm8994_pdata wm8994_platform_data = {
+	/* configure gpio1 function: 0x0001(Logic level input/output) */
+	.gpio_defaults[0] = 0x0001,
+	/* configure gpio3/4/5/7 function for AIF2 voice */
+	.gpio_defaults[2] = 0x8100,/* BCLK2 in */
+	.gpio_defaults[3] = 0x8100,/* LRCLK2 in */
+	.gpio_defaults[4] = 0x8100,/* DACDAT2 in */
+	/* configure gpio6 function: 0x0001(Logic level input/output) */
+	.gpio_defaults[5] = 0x0001,
+	.gpio_defaults[6] = 0x0100,/* ADCDAT2 out */
+	.ldo[0] = { 0, NULL, &wm8994_ldo1_data },
+	.ldo[1] = { 0, NULL, &wm8994_ldo2_data },
+};
+
+/* ly 20111102 : i2c devs mapping: 
+  * i2c0 : HDMI
+  * i2c1 : max8997: PMIC & RTC & motor
+  * i2c2 : not used
+  * i2c3 : touch
+  * i2c4 : max8997 fuel gauge & wm8994
+  * i2c5 : sensor: MPU3050
+  * i2c6 : camera & HSIC
+  * i2c7 : light sensor
+  */
+static struct i2c_board_info i2c_devs0[] __initdata = {
+#ifdef CONFIG_VIDEO_TVOUT
+	{
+		I2C_BOARD_INFO("s5p_ddc", (0x74 >> 1)),    
+		//.platform_data=&hdmi_i2c_en_pdata,            //yqf 20110608, move to s5p_hdmi_ctrl_init_private()
+	},
+#endif
+};
+
+static struct i2c_board_info i2c_devs1[] __initdata = {
+	{
+#ifdef CONFIG_REGULATOR_S5M8767
+
+		I2C_BOARD_INFO("s5m87xx", 0xCC >> 1),
+		.platform_data = &exynos4_s5m8767_pdata,
+		.irq		= IRQ_EINT(15),
+
+#else
+		I2C_BOARD_INFO(MAX8997_I2C_NAME, MAX8997_ADDR),
+#ifdef CONFIG_REGULATOR_MAX8997
+		.platform_data = &exynos4_max8997_info,
+#endif
+#endif
+	},
+#ifdef CONFIG_VIBRATOR
+
+#ifndef CONFIG_REGULATOR_S5M8767
+
+	{
+		I2C_BOARD_INFO(MOTOR8997_I2C_NAME, MOTOR8997_ADDR),
+	},
+#endif
+
+#endif
+
+#ifdef CONFIG_RTC_MAX8997
+	{
+		I2C_BOARD_INFO(RTC8997_I2C_NAME, RTC8997_I2C_ADDR),
+	},
+#endif
+
+#ifdef CONFIG_BATTERY_MAX17040
+	{
+		I2C_BOARD_INFO(MAX17040_I2C_NAME, MAX17040_I2C_ADDR),
+	},
+#endif
+
+};
+#if 1 //iic 2 : nfc
+static struct i2c_board_info i2c_devs2[] __initdata = {
+
+#ifdef CONFIG_S3FHRN2_I2C
+	{
+		I2C_BOARD_INFO(S3FHRN2_DRIVER_NAME, SNFC_I2C_ADDR),
+		.platform_data  = &exynos4_nfc_info,
+		.irq		= IRQ_EINT(SNFC_EINT_NUM),
+	},
+#endif
+};
+#endif
+// For S5K4EC(using i2c6)
+static struct i2c_board_info i2c_devs6[] __initdata = {
+
+};
+#if defined(CONFIG_TOUCHSCREEN_EGALAX)	// Egalax I2C TS
+struct egalax_i2c_platform_data egalax_eeti_pdata = {
+	.gpio_int = EXYNOS4_GPX0(4),
+	.gpio_en = EXYNOS4_GPL0(2),
+	//.gpio_rst = S5PV310_GPA1(4),
+};
+#endif
+
+static struct i2c_board_info i2c_devs3[] __initdata = {
+#if defined(CONFIG_TOUCHSCREEN_EGALAX)	// Egalax I2C TS
+	{
+		I2C_BOARD_INFO(EGALAX_I2C_NAME, EGALAX_I2C_ADDR),
+		.irq = EGALAX_IRQ,
+		//.irq = gpio_to_irq(egalax_eeti_pdata.gpio),
+		.platform_data = &egalax_eeti_pdata,
+	},
+#endif
+};
+
+/* I2C4 */
+static struct i2c_board_info i2c_devs4[] __initdata = {
+/*Fri Aug 26 18:26:55 CST 2011 add by cwp:move codec i2c from controller 6 to 4*/
+#if defined(CONFIG_SND_SOC_WM8994) || defined(CONFIG_SND_SOC_WM8994_MODULE)
+	{
+		I2C_BOARD_INFO("wm8994", 0x34>>1),
+		.platform_data	= &wm8994_platform_data,
+	},
+#endif
+#ifdef CONFIG_BATTERY_MAX8997//ly
+	{
+		I2C_BOARD_INFO(FG8997_I2C_NAME, FG8997_I2C_ADDR),
+	},
+#endif
+
+};
+
+#ifdef CONFIG_S3FHRN2_I2C
+static struct s3c2410_platform_i2c i2c_data4 __initdata = {
+	.flags		= 0,
+	.slave_addr	= SNFC_I2C_ADDR,
+	.frequency	= 200*1000,
+	.sda_delay	= 50,
+	.bus_num 	= 4,
+	.cfg_gpio	= exynos4_init_nfc_gpio,
+};
+#endif
+
+#if defined(CONFIG_SENSOR_ST_LSM303DLHC)	// G/M sensor
+struct lsm303dlhc_acc_platform_data lsm303dlhc_g_pdata = {
+	.poll_interval = 10,
+	.min_interval = 0,
+	.g_range = LSM303DLHC_ACC_G_2G,
+	.axis_map_x = GM_AXIS_MAP_X,
+	.axis_map_y = GM_AXIS_MAP_Y,
+	.axis_map_z = GM_AXIS_MAP_Z,
+	.negate_x = GM_NEGATE_X,
+	.negate_y = GM_NEGATE_Y,
+	.negate_z = GM_NEGATE_Z,
+	.gpio_int1 = EXYNOS4_GPX3(0),
+	.gpio_int2 = EXYNOS4_GPX3(1),
+};
+struct lsm303dlhc_mag_platform_data lsm303dlhc_m_pdata = {
+	.poll_interval = 13,
+	.min_interval = 0,
+	.h_range = LSM303DLHC_H_8_1G,
+	.axis_map_x = GM_AXIS_MAP_X,
+	.axis_map_y = GM_AXIS_MAP_Y,
+	.axis_map_z = GM_AXIS_MAP_Z,
+	.negate_x = GM_NEGATE_X,
+	.negate_y = GM_NEGATE_Y,
+	.negate_z = GM_NEGATE_Z,
+};
+#endif
+/* I2C5 */
+static struct i2c_board_info i2c_devs5[] __initdata = {
+#if defined(CONFIG_SENSOR_ST_LSM303DLHC)	// G/M sensor
+	{
+		I2C_BOARD_INFO(LSM303DLHC_ACC_DEV_NAME, LSM303DLHC_ACC_I2C_ADDR),
+		.platform_data  = &lsm303dlhc_g_pdata,
+	},
+	{
+		I2C_BOARD_INFO(LSM303DLHC_MAG_DEV_NAME, LSM303DLHC_MAG_I2C_ADDR),
+		.platform_data  = &lsm303dlhc_m_pdata,
+	},
+#endif
+#ifdef CONFIG_TC4_GB// liang
+#if defined(CONFIG_MPU_SENSORS_MPU3050) || defined(CONFIG_MPU_SENSORS_MPU3050_MODULE)
+	// liang
+	{
+		I2C_BOARD_INFO(SENSOR_MPU_NAME, 0x68),
+		//.irq = gpio_to_irq(MPUGPIO),
+		.irq = IRQ_EINT(27),
+		.platform_data = &mpu_data,
+	},
+#endif  //yulu for test sleep
+#endif
+#ifdef CONFIG_TC4_ICS
+	// gyro
+	{
+		I2C_BOARD_INFO(MPU_NAME, 0x68),
+		.irq = IRQ_EINT(27),
+		.platform_data = &mpu3050_data,
+	},
+	// compass
+	{
+		I2C_BOARD_INFO("hmc5883", (0x3c>>1)),
+		//.irq = IRQ_EINT(28),
+		.platform_data = &inv_mpu_hmc5883_data,
+	},
+	// accel
+	{
+		I2C_BOARD_INFO("bma250", (0x30>>1)),
+		//.irq = IRQ_EINT(24),// 25?
+		.platform_data = &inv_mpu_bma250_data,
+	},
+#endif
+};
+
+#if defined(CONFIG_SENSOR_ST_L3G4200D)	// Gyroscope sensor
+struct l3g4200d_gyr_platform_data l3g4200d_gyro_pdata = {
+	.poll_interval = 10,
+	.min_interval = 0,
+	.fs_range = L3G4200D_FS_2000DPS,
+	.axis_map_x = GYRO_AXIS_MAP_X,
+	.axis_map_y = GYRO_AXIS_MAP_Y,
+	.axis_map_z = GYRO_AXIS_MAP_Z,
+	.negate_x = GYRO_NEGATE_X,
+	.negate_y = GYRO_NEGATE_Y,
+	.negate_z = GYRO_NEGATE_Z,
+};
+#endif
+#if defined(CONFIG_SENSOR_ROHM_BH1721)	// Light sensor
+struct ROHM_I2C_platform_data rohm_bh1721_pdata = {
+};
+#endif
+
+/* I2C7 */
+static struct i2c_board_info i2c_devs7[] __initdata = {
+#if defined(CONFIG_SENSOR_ST_L3G4200D)	// Gyroscope sensor
+	{
+		I2C_BOARD_INFO(L3G4200D_DEV_NAME, L3G4200D_I2C_ADDR),
+		.platform_data  = &l3g4200d_gyro_pdata,
+	},
+#endif
+#if defined(CONFIG_SENSOR_ROHM_BH1721)	// Light sensor
+	{
+		I2C_BOARD_INFO(ROHM_I2C_NAME, ROHM_I2C_ADDR),
+		.platform_data = &rohm_bh1721_pdata,
+	},
+#endif
+};
+
+
+#ifdef CONFIG_ANDROID_PMEM
+static struct android_pmem_platform_data pmem_pdata = {
+	.name		= "pmem",
+	.no_allocator	= 1,
+	.cached		= 0,
+	.start		= 0,
+	.size		= 0
+};
+
+static struct android_pmem_platform_data pmem_gpu1_pdata = {
+	.name		= "pmem_gpu1",
+	.no_allocator	= 1,
+	.cached		= 0,
+	.start		= 0,
+	.size		= 0,
+};
+
+static struct platform_device pmem_device = {
+	.name	= "android_pmem",
+	.id	= 0,
+	.dev	= {
+		.platform_data = &pmem_pdata
+	},
+};
+
+static struct platform_device pmem_gpu1_device = {
+	.name	= "android_pmem",
+	.id	= 1,
+	.dev	= {
+		.platform_data = &pmem_gpu1_pdata
+	},
+};
+
+static void __init android_pmem_set_platdata(void)
+{
+#if defined(CONFIG_S5P_MEM_CMA)
+	pmem_pdata.size = CONFIG_ANDROID_PMEM_MEMSIZE_PMEM * SZ_1K;
+	pmem_gpu1_pdata.size = CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_GPU1 * SZ_1K;
+#endif
+}
+#endif
+
+#ifdef CONFIG_BATTERY_SAMSUNG
+static struct platform_device samsung_device_battery = {
+	.name	= "samsung-fake-battery",
+	.id	= -1,
+};
+#endif
+
+/* s5p-pmic interface */
+static struct resource s5p_pmic_resource[] = {
+
+};
+
+
+struct platform_device s5p_device_pmic = {
+  .name             = "s5p-pmic",
+  .id               = -1,
+  .num_resources    = ARRAY_SIZE(s5p_pmic_resource),
+  .resource         = s5p_pmic_resource,
+
+
+  
+};
+
+EXPORT_SYMBOL(s5p_device_pmic);
+
+#ifdef CONFIG_SWITCH_GPIO
+#include <linux/switch.h>
+static struct gpio_switch_platform_data headset_switch_data = {
+       .name = "h2w",
+       .gpio = EXYNOS4_GPX2(2), // "GPX2"
+};
+
+static struct resource switch_gpio_resource[] = {
+        [0] = {
+                .start  = IRQ_EINT(18), // WAKEUP_INT2[2]
+                .end    = IRQ_EINT(18),
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device headset_switch_device = {
+        .name             = "switch-gpio",
+        .dev = {
+                .platform_data    = &headset_switch_data,
+        },
+        .num_resources  = ARRAY_SIZE(switch_gpio_resource),
+        .resource = switch_gpio_resource,
+};
+#endif
+
+#if 0
+static struct gpio_event_direct_entry smdk4x12_keypad_key_map[] = {
+	{
+		.gpio   = EXYNOS4_GPX0(0),
+		.code   = KEY_POWER,
+	}
+};
+
+static struct gpio_event_input_info smdk4x12_keypad_key_info = {
+	.info.func              = gpio_event_input_func,
+	.info.no_suspend        = true,
+	.debounce_time.tv64	= 5 * NSEC_PER_MSEC,
+	.type                   = EV_KEY,
+	.keymap                 = smdk4x12_keypad_key_map,
+	.keymap_size            = ARRAY_SIZE(smdk4x12_keypad_key_map)
+};
+
+static struct gpio_event_info *smdk4x12_input_info[] = {
+	&smdk4x12_keypad_key_info.info,
+};
+
+static struct gpio_event_platform_data smdk4x12_input_data = {
+	.names  = {
+		"smdk4x12-keypad",
+		NULL,
+	},
+	.info           = smdk4x12_input_info,
+	.info_count     = ARRAY_SIZE(smdk4x12_input_info),
+};
+
+static struct platform_device smdk4x12_input_device = {
+	.name   = GPIO_EVENT_DEV_NAME,
+	.id     = 0,
+	.dev    = {
+		.platform_data = &smdk4x12_input_data,
+	},
+};
+#endif
+static void __init smdk4x12_gpio_power_init(void)
+{
+	int err = 0;
+
+	err = gpio_request_one(EXYNOS4_GPX0(0), 0, "GPX0");
+	if (err) {
+		printk(KERN_ERR "failed to request GPX0 for "
+				"suspend/resume control\n");
+		return;
+	}
+	s3c_gpio_setpull(EXYNOS4_GPX0(0), S3C_GPIO_PULL_NONE);
+
+	gpio_free(EXYNOS4_GPX0(0));
+}
+
+static uint32_t smdk4x12_keymap[] __initdata = {
+	/* KEY(row, col, keycode) */
+	KEY(0, 0, KEY_VOLUMEDOWN), KEY(0, 1, KEY_VOLUMEUP), KEY(0, 2, KEY_HOME), KEY(0, 3, KEY_MENU), KEY(0, 4, KEY_BACK),KEY(0, 5, KEY_POWER)	//volume up ---volume down
+};
+
+static struct matrix_keymap_data smdk4x12_keymap_data __initdata = {
+	.keymap		= smdk4x12_keymap,
+	.keymap_size	= ARRAY_SIZE(smdk4x12_keymap),
+};
+
+static struct samsung_keypad_platdata smdk4x12_keypad_data __initdata = {
+	.keymap_data	= &smdk4x12_keymap_data,
+	.rows		= 2,
+	.cols		= 1,
+};
+
+#ifdef CONFIG_WAKEUP_ASSIST
+static struct platform_device wakeup_assist_device = {
+	.name   = "wakeup_assist",
+};
+#endif
+
+#ifdef CONFIG_VIDEO_FIMG2D
+static struct fimg2d_platdata fimg2d_data __initdata = {
+	.hw_ver = 0x41,
+	.parent_clkname = "mout_g2d0",
+	.clkname = "sclk_fimg2d",
+	.gate_clkname = "fimg2d",
+	.clkrate = 267 * 1000000,	/* 266 Mhz */
+};
+#endif
+
+#ifdef CONFIG_EXYNOS_C2C
+struct exynos_c2c_platdata smdk4x12_c2c_pdata = {
+	.setup_gpio	= NULL,
+	.shdmem_addr	= C2C_SHAREDMEM_BASE,
+	.shdmem_size	= C2C_MEMSIZE_64,
+	.ap_sscm_addr	= NULL,
+	.cp_sscm_addr	= NULL,
+	.rx_width	= C2C_BUSWIDTH_16,
+	.tx_width	= C2C_BUSWIDTH_16,
+	.clk_opp100	= 400,
+	.clk_opp50	= 266,
+	.clk_opp25	= 0,
+	.default_opp_mode	= C2C_OPP50,
+	.get_c2c_state	= NULL,
+	.c2c_sysreg	= S5P_VA_CMU + 0x12000,
+};
+#endif
+
+#ifdef CONFIG_USB_EXYNOS_SWITCH
+static struct s5p_usbswitch_platdata smdk4x12_usbswitch_pdata;
+
+static void __init smdk4x12_usbswitch_init(void)
+{
+	struct s5p_usbswitch_platdata *pdata = &smdk4x12_usbswitch_pdata;
+	int err;
+
+	pdata->gpio_host_detect = EXYNOS4_GPX3(5); /* low active */
+	err = gpio_request_one(pdata->gpio_host_detect, GPIOF_IN, "HOST_DETECT");
+	if (err) {
+		printk(KERN_ERR "failed to request gpio_host_detect\n");
+		return;
+	}
+
+	s3c_gpio_cfgpin(pdata->gpio_host_detect, S3C_GPIO_SFN(0xF));
+	s3c_gpio_setpull(pdata->gpio_host_detect, S3C_GPIO_PULL_NONE);
+	gpio_free(pdata->gpio_host_detect);
+
+	pdata->gpio_device_detect = EXYNOS4_GPX3(4); /* high active */
+	err = gpio_request_one(pdata->gpio_device_detect, GPIOF_IN, "DEVICE_DETECT");
+	if (err) {
+		printk(KERN_ERR "failed to request gpio_host_detect for\n");
+		return;
+	}
+
+	s3c_gpio_cfgpin(pdata->gpio_device_detect, S3C_GPIO_SFN(0xF));
+	s3c_gpio_setpull(pdata->gpio_device_detect, S3C_GPIO_PULL_NONE);
+	gpio_free(pdata->gpio_device_detect);
+
+	if (samsung_board_rev_is_0_0())
+		pdata->gpio_host_vbus = 0;
+	else {
+		pdata->gpio_host_vbus = EXYNOS4_GPL2(0);
+		err = gpio_request_one(pdata->gpio_host_vbus, GPIOF_OUT_INIT_LOW, "HOST_VBUS_CONTROL");
+		if (err) {
+			printk(KERN_ERR "failed to request gpio_host_vbus\n");
+			return;
+		}
+
+		s3c_gpio_setpull(pdata->gpio_host_vbus, S3C_GPIO_PULL_NONE);
+		gpio_free(pdata->gpio_host_vbus);
+	}
+	s5p_usbswitch_set_platdata(pdata);
+}
+#endif
+
+#ifdef CONFIG_BUSFREQ_OPP
+/* BUSFREQ to control memory/bus*/
+static struct device_domain busfreq;
+#endif
+
+static struct platform_device exynos4_busfreq = {
+	.id = -1,
+	.name = "exynos-busfreq",
+};
+
+// SEMCO
+/* The sdhci_s3c_sdio_card_detect function is used for detecting
+   the WiFi/BT module when the menu for enabling the WiFi is
+   selected.
+   The semco_a31_detection function is called by ar6000's probe function.
+
+   The call sequence is
+
+   ar6000_pm_probe() -> plat_setup_power_for_onoff() -> detect_semco_wlan_for_onoff()
+   -> setup_semco_wlan_power_onoff() -> semco_a31_detection()
+
+   The mmc_semco_a31_sdio_remove function is used for removing the mmc driver
+   when the menu for disabling the WiFi is selected.
+   The semco_a31_removal function is called by ar6000's remove function.
+
+   The call sequence is
+
+   ar6000_pm_remove() -> plat_setup_power_for_onoff() -> detect_semco_wlan_for_onoff()
+   -> setup_semco_wlan_power_onoff() -> semco_a31_removal()
+
+   The setup_semco_wlan_power function is only used for sleep/wakeup. It controls only 
+   the power of A31 module only(Do not card detection/removal function)
+*/
+   
+extern void sdhci_s3c_sdio_card_detect(struct platform_device *pdev);
+void semco_a31_detection(void)
+{
+	sdhci_s3c_sdio_card_detect(&s3c_device_hsmmc3);
+}
+EXPORT_SYMBOL(semco_a31_detection);
+
+
+extern void mmc_semco_a31_sdio_remove(void);
+void semco_a31_removal(void)
+{
+	mmc_semco_a31_sdio_remove();
+}
+EXPORT_SYMBOL(semco_a31_removal);
+
+static struct platform_device s3c_wlan_ar6000_pm_device = {
+        .name           = "wlan_ar6000_pm_dev",
+        .id             = 1,
+        .num_resources  = 0,
+        .resource       = NULL,
+};
+
+static struct platform_device bt_sysfs = {
+        .name = "bt-sysfs",
+        .id = -1,
+};
+// END SEMCO
+
+struct platform_device s3c_device_gps = {
+        .name   = "si_gps",
+        .id             = -1,
+};
+
+static  struct  i2c_gpio_platform_data  i2c0_platdata = {
+        .sda_pin                = EXYNOS4_GPD1(0),
+        .scl_pin                = EXYNOS4_GPD1(1),
+        .udelay                 = 1 ,  
+        .sda_is_open_drain      = 0,
+        .scl_is_open_drain      = 0,
+        .scl_is_output_only     = 0,
+//      .scl_is_output_only     = 1,
+      };
+
+static struct platform_device s3c_device_i2c0_gpio = {
+        .name                           = "i2c-gpio",
+        .id                                     = 0,
+        .dev.platform_data      = &i2c0_platdata,
+};
+
+#ifdef CONFIG_GPIO_SMM6260
+//shengliang
+struct platform_device smm6260_device = {
+	.name	= "smm6260-gpio",
+	.id	= -1,
+};
+#endif
+
+#ifdef CONFIG_VIBRATOR
+struct platform_device s5p_vib_dev = {
+	.name	= "s5p-vib",
+	.id	= -1,
+};
+#endif
+
+#if defined (CONFIG_S5P_SYSTEM_MMU) && defined(CONFIG_TC4_GB)
+
+extern struct platform_device s5p_device_sysmmu;
+#endif
+static struct platform_device *smdk4412_devices[] __initdata = {
+	&s3c_device_adc,
+};
+
+static struct platform_device *smdk4x12_devices[] __initdata = {
+#ifdef CONFIG_ANDROID_PMEM
+	&pmem_device,
+	&pmem_gpu1_device,
+#endif
+	/* Samsung Power Domain */
+	&exynos4_device_pd[PD_MFC],
+	&exynos4_device_pd[PD_G3D],
+	&exynos4_device_pd[PD_LCD0],
+	&exynos4_device_pd[PD_CAM],
+	&exynos4_device_pd[PD_TV],
+	&exynos4_device_pd[PD_GPS],
+	&exynos4_device_pd[PD_GPS_ALIVE],
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_IS
+	&exynos4_device_pd[PD_ISP],
+#endif
+#ifdef CONFIG_FB_MIPI_DSIM
+	&s5p_device_mipi_dsim,
+#endif
+/* mainline fimd */
+#ifdef CONFIG_FB_S3C
+	&s5p_device_fimd0,
+#if defined(CONFIG_LCD_AMS369FG06) || defined(CONFIG_LCD_LMS501KF03)
+	&s3c_device_spi_gpio,
+#elif defined(CONFIG_LCD_WA101S)
+	&smdk4x12_lcd_wa101s,
+#elif defined(CONFIG_LCD_LTE480WV)
+	&smdk4x12_lcd_lte480wv,
+#elif defined(CONFIG_LCD_MIPI_S6E63M0)
+	&smdk4x12_mipi_lcd,
+#endif
+#endif
+	/* legacy fimd */
+#ifdef CONFIG_FB_S5P
+	&s3c_device_fb,
+#ifdef CONFIG_FB_S5P_LMS501KF03
+	&s3c_device_spi_gpio,
+#endif
+#endif
+	&s3c_device_wdt,
+	&s3c_device_rtc,
+	//&s3c_device_i2c0,
+	&s3c_device_i2c0_gpio, //added yqf 
+	&s3c_device_i2c1,
+	//&s3c_device_i2c2,
+	&s3c_device_i2c3,
+	&s3c_device_i2c4,
+	&s3c_device_i2c5,
+	&s3c_device_i2c6,//For S5K4EC
+	&s3c_device_i2c7,
+
+#if !defined(CONFIG_REGULATOR_MAX8997)	
+	&s5p_device_pmic,
+#endif	
+
+	&tc4_regulator_consumer,
+
+	//robin, no need&s3c_device_adc,//wenpin.cui
+#ifdef CONFIG_S3FHRN2_I2C_GPIO
+	&s3c_device_i2c_nfc_gpio,
+#endif
+#ifdef CONFIG_S3FHRN2_UART
+	&s3c_device_nfc_uart,
+#endif
+
+#ifdef CONFIG_USB_EHCI_S5P
+	&s5p_device_ehci,
+#endif
+#ifdef CONFIG_USB_OHCI_S5P
+	&s5p_device_ohci,
+#endif
+#ifdef CONFIG_USB_GADGET
+	&s3c_device_usbgadget,
+#endif
+#ifdef CONFIG_USB_ANDROID_RNDIS
+	&s3c_device_rndis,
+#endif
+#ifdef CONFIG_USB_ANDROID
+	&s3c_device_android_usb,
+	&s3c_device_usb_mass_storage,
+#endif
+// SEMCO
+    &s3c_wlan_ar6000_pm_device,
+    &bt_sysfs,
+// END SEMCO
+
+#ifdef CONFIG_S5P_DEV_MSHC
+	&s3c_device_mshci,//lisw sd mshci should be probe before hsmmc
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC
+//	&s3c_device_hsmmc0,
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC1
+//	&s3c_device_hsmmc1,
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC2
+	&s3c_device_hsmmc2,
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC3
+	&s3c_device_hsmmc3,
+#endif
+#ifdef CONFIG_EXYNOS4_DEV_DWMCI
+	&exynos_device_dwmci,
+#endif
+#ifdef CONFIG_SND_SAMSUNG_AC97
+	&exynos_device_ac97,
+#endif
+#ifdef CONFIG_SND_SAMSUNG_I2S
+	&exynos_device_i2s0,
+#endif
+#ifdef CONFIG_SND_SAMSUNG_PCM
+	&exynos_device_pcm0,
+#endif
+#ifdef CONFIG_SND_SAMSUNG_SPDIF
+	&exynos_device_spdif,
+#endif
+#if defined(CONFIG_SND_SAMSUNG_RP) || defined(CONFIG_SND_SAMSUNG_ALP)
+	&exynos_device_srp,
+#endif
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_IS
+	&exynos4_device_fimc_is,
+#endif
+#ifdef CONFIG_VIDEO_TVOUT
+	&s5p_device_tvout,
+	&s5p_device_cec,
+	&s5p_device_hpd,
+#endif
+#ifdef CONFIG_VIDEO_EXYNOS_TV
+	&s5p_device_i2c_hdmiphy,
+	&s5p_device_hdmi,
+	&s5p_device_sdo,
+	&s5p_device_mixer,
+	&s5p_device_cec,
+#endif
+#if defined(CONFIG_VIDEO_FIMC)
+	&s3c_device_fimc0,
+	&s3c_device_fimc1,
+	&s3c_device_fimc2,
+	&s3c_device_fimc3,
+/* CONFIG_VIDEO_SAMSUNG_S5P_FIMC is the feature for mainline */
+#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
+	&s5p_device_fimc0,
+	&s5p_device_fimc1,
+	&s5p_device_fimc2,
+	&s5p_device_fimc3,
+#endif
+#if defined(CONFIG_VIDEO_FIMC_MIPI)
+	&s3c_device_csis0,
+	&s3c_device_csis1,
+#elif defined(CONFIG_VIDEO_S5P_MIPI_CSIS)
+	&s5p_device_mipi_csis0,
+	&s5p_device_mipi_csis1,
+#endif
+#ifdef CONFIG_VIDEO_S5P_MIPI_CSIS
+	&mipi_csi_fixed_voltage,
+#endif
+#ifdef CONFIG_VIDEO_M5MOLS
+	&m5mols_fixed_voltage,
+#endif
+
+#if defined(CONFIG_VIDEO_MFC5X) || defined(CONFIG_VIDEO_SAMSUNG_S5P_MFC)
+	&s5p_device_mfc,
+#endif
+#ifdef CONFIG_S5P_SYSTEM_MMU
+#ifdef CONFIG_TC4_GB
+	&s5p_device_sysmmu,
+#else
+	&SYSMMU_PLATDEV(g2d_acp),
+	&SYSMMU_PLATDEV(fimc0),
+	&SYSMMU_PLATDEV(fimc1),
+	&SYSMMU_PLATDEV(fimc2),
+	&SYSMMU_PLATDEV(fimc3),
+	&SYSMMU_PLATDEV(jpeg),
+	&SYSMMU_PLATDEV(mfc_l),
+	&SYSMMU_PLATDEV(mfc_r),
+	&SYSMMU_PLATDEV(tv),
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_IS
+	&SYSMMU_PLATDEV(is_isp),
+	&SYSMMU_PLATDEV(is_drc),
+	&SYSMMU_PLATDEV(is_fd),
+	&SYSMMU_PLATDEV(is_cpu),
+#endif
+#endif //CONIG_TC4_GB
+#endif /* CONFIG_S5P_SYSTEM_MMU */
+
+#ifdef CONFIG_ION_EXYNOS
+	&exynos_device_ion,
+#endif
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_LITE
+	&exynos_device_flite0,
+	&exynos_device_flite1,
+#endif
+#ifdef CONFIG_VIDEO_FIMG2D
+	&s5p_device_fimg2d,
+#endif
+#ifdef CONFIG_EXYNOS_MEDIA_DEVICE
+	&exynos_device_md0,
+#endif
+#if	defined(CONFIG_VIDEO_JPEG_V2X) || defined(CONFIG_VIDEO_JPEG)
+
+	&s5p_device_jpeg,
+#endif
+	&wm8994_fixed_voltage0,
+	&wm8994_fixed_voltage1,
+	&wm8994_fixed_voltage2,
+	&samsung_asoc_dma,
+	&samsung_asoc_idma,
+#ifdef CONFIG_BATTERY_SAMSUNG
+	&samsung_device_battery,
+#endif
+	&samsung_device_keypad,
+#ifdef CONFIG_WAKEUP_ASSIST
+	&wakeup_assist_device,
+#endif
+#ifdef CONFIG_EXYNOS_C2C
+	&exynos_device_c2c,
+#endif
+	//&smdk4x12_input_device, yulu
+	&smdk4x12_smsc911x,
+#ifdef CONFIG_S3C64XX_DEV_SPI
+	&exynos_device_spi0,
+#ifndef CONFIG_FB_S5P_LMS501KF03
+	&exynos_device_spi1,
+#endif
+	&exynos_device_spi2,
+#endif
+#ifdef CONFIG_EXYNOS_SETUP_THERMAL
+	&exynos_device_tmu,
+#endif
+#ifdef CONFIG_S5P_DEV_ACE
+	&s5p_device_ace,
+#endif
+	&exynos4_busfreq,
+#ifdef CONFIG_SWITCH_GPIO
+        &headset_switch_device,
+#endif
+	&s3c_device_gps,
+	//&xmm6260_modem,
+#ifdef CONFIG_GPIO_SMM6260
+	&smm6260_device,//liang
+#endif
+#ifdef CONFIG_SMM6260_MODEM
+	&xmm6260_modem,
+#endif	
+#ifdef CONFIG_VIBRATOR
+	&s5p_vib_dev,
+#endif
+};
+#ifdef CONFIG_EXYNOS_SETUP_THERMAL
+/* below temperature base on the celcius degree */
+struct tmu_data exynos_tmu_data __initdata = {
+	.ts = {
+		.stop_throttle  = 82,
+		.start_throttle = 85,
+		.stop_warning  = 95,
+		.start_warning = 103,
+		.start_tripping = 110, /* temp to do tripping */
+	},
+	.efuse_value = 55,
+	.slope = 0x10008802,
+	.mode = 0,
+};
+#endif
+
+
+#if defined(CONFIG_VIDEO_TVOUT)
+static struct s5p_platform_hpd hdmi_hpd_data __initdata = {
+
+};
+static struct s5p_platform_cec hdmi_cec_data __initdata = {
+
+};
+#endif
+#ifdef CONFIG_VIDEO_EXYNOS_HDMI_CEC
+static struct s5p_platform_cec hdmi_cec_data __initdata = {
+
+};
+#endif
+
+#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+static struct s5p_fimc_isp_info isp_info[] = {
+
+#if defined(CONFIG_SOC_CAMERA_MT9D115)
+	{
+		.board_info	= &mt9d115_i2c_info,
+		.clk_frequency  = 24000000UL,
+		.bus_type	= FIMC_ITU_601,//CAM_TYPE_ITU,
+		.i2c_bus_num	= 7,
+		.mux_id	= 0, /* A-Port : 0, B-Port : 1 */
+		.flags		= FIMC_CLK_INV_VSYNC,
+		.csi_data_align = 32,
+	},
+#endif
+
+
+#if defined(CONFIG_VIDEO_S5K4ECGX)	//yulu
+	{
+		.board_info	= &s5k4ecgx_i2c_info,
+		.clk_frequency  = 24000000UL,
+		.bus_type	= FIMC_MIPI_CSI2,//CAM_TYPE_MIPI,
+		.i2c_bus_num	= 6,
+		.mux_id	= 0, /* A-Port : 0, B-Port : 1 */
+		.flags		= FIMC_CLK_INV_VSYNC,
+		.csi_data_align = 32,
+		/*.cam_power = ,*/
+	},
+#endif
+
+
+
+
+
+#if defined(CONFIG_VIDEO_S5K4BA)
+	{
+		.board_info	= &s5k4ba_info,
+		.clk_frequency  = 24000000UL,
+		.bus_type	= FIMC_ITU_601,
+#ifdef CONFIG_ITU_A
+		.i2c_bus_num	= 0,
+		.mux_id		= 0, /* A-Port : 0, B-Port : 1 */
+#endif
+#ifdef CONFIG_ITU_B
+		.i2c_bus_num	= 1,
+		.mux_id		= 1, /* A-Port : 0, B-Port : 1 */
+#endif
+		.flags		= FIMC_CLK_INV_VSYNC,
+	},
+#endif
+#if defined(CONFIG_VIDEO_S5K4EA)
+	{
+		.board_info	= &s5k4ea_info,
+		.clk_frequency  = 24000000UL,
+		.bus_type	= FIMC_MIPI_CSI2,
+#ifdef CONFIG_CSI_C
+		.i2c_bus_num	= 0,
+		.mux_id		= 0, /* A-Port : 0, B-Port : 1 */
+#endif
+#ifdef CONFIG_CSI_D
+		.i2c_bus_num	= 1,
+		.mux_id		= 1, /* A-Port : 0, B-Port : 1 */
+#endif
+		.flags		= FIMC_CLK_INV_VSYNC,
+		.csi_data_align = 32,
+	},
+#endif
+#if defined(CONFIG_VIDEO_M5MOLS)
+	{
+		.board_info	= &m5mols_board_info,
+		.clk_frequency  = 24000000UL,
+		.bus_type	= FIMC_MIPI_CSI2,
+#ifdef CONFIG_CSI_C
+		.i2c_bus_num	= 4,
+		.mux_id		= 0, /* A-Port : 0, B-Port : 1 */
+#endif
+#ifdef CONFIG_CSI_D
+		.i2c_bus_num	= 5,
+		.mux_id		= 1, /* A-Port : 0, B-Port : 1 */
+#endif
+		.flags		= FIMC_CLK_INV_PCLK | FIMC_CLK_INV_VSYNC,
+		.csi_data_align = 32,
+	},
+#endif
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_IS
+#if defined(CONFIG_VIDEO_S5K3H2)
+	{
+		.board_info	= &s5k3h2_sensor_info,
+		.clk_frequency  = 24000000UL,
+		.bus_type	= FIMC_MIPI_CSI2,
+#ifdef CONFIG_S5K3H2_CSI_C
+		.i2c_bus_num	= 0,
+		.mux_id		= 0, /* A-Port : 0, B-Port : 1 */
+		.flite_id	= FLITE_IDX_A,
+		.cam_power	= smdk4x12_cam0_reset,
+#endif
+#ifdef CONFIG_S5K3H2_CSI_D
+		.i2c_bus_num	= 1,
+		.mux_id		= 1, /* A-Port : 0, B-Port : 1 */
+		.flite_id	= FLITE_IDX_B,
+		.cam_power	= smdk4x12_cam1_reset,
+#endif
+		.flags		= 0,
+		.csi_data_align = 24,
+		.use_isp	= true,
+	},
+#endif
+#if defined(CONFIG_VIDEO_S5K3H7)
+	{
+		.board_info	= &s5k3h7_sensor_info,
+		.clk_frequency  = 24000000UL,
+		.bus_type	= FIMC_MIPI_CSI2,
+#ifdef CONFIG_S5K3H7_CSI_C
+		.i2c_bus_num	= 0,
+		.mux_id		= 0, /* A-Port : 0, B-Port : 1 */
+		.flite_id	= FLITE_IDX_A,
+		.cam_power	= smdk4x12_cam0_reset,
+#endif
+#ifdef CONFIG_S5K3H7_CSI_D
+		.i2c_bus_num	= 1,
+		.mux_id		= 1, /* A-Port : 0, B-Port : 1 */
+		.flite_id	= FLITE_IDX_B,
+		.cam_power	= smdk4x12_cam1_reset,
+#endif
+		.csi_data_align = 24,
+		.use_isp	= true,
+	},
+#endif
+#if defined(CONFIG_VIDEO_S5K4E5)
+	{
+		.board_info	= &s5k4e5_sensor_info,
+		.clk_frequency  = 24000000UL,
+		.bus_type	= FIMC_MIPI_CSI2,
+#ifdef CONFIG_S5K4E5_CSI_C
+		.i2c_bus_num	= 0,
+		.mux_id		= 0, /* A-Port : 0, B-Port : 1 */
+		.flite_id	= FLITE_IDX_A,
+		.cam_power	= smdk4x12_cam0_reset,
+#endif
+#ifdef CONFIG_S5K4E5_CSI_D
+		.i2c_bus_num	= 1,
+		.mux_id		= 1, /* A-Port : 0, B-Port : 1 */
+		.flite_id	= FLITE_IDX_B,
+		.cam_power	= smdk4x12_cam1_reset,
+#endif
+		.csi_data_align = 24,
+		.use_isp	= true,
+	},
+#endif
+#if defined(CONFIG_VIDEO_S5K6A3)
+	{
+		.board_info	= &s5k6a3_sensor_info,
+		.clk_frequency  = 12000000UL,
+		.bus_type	= FIMC_MIPI_CSI2,
+#ifdef CONFIG_S5K6A3_CSI_C
+		.i2c_bus_num	= 0,
+		.mux_id		= 0, /* A-Port : 0, B-Port : 1 */
+		.flite_id	= FLITE_IDX_A,
+		.cam_power	= smdk4x12_cam0_reset,
+#endif
+#ifdef CONFIG_S5K6A3_CSI_D
+		.i2c_bus_num	= 1,
+		.mux_id		= 1, /* A-Port : 0, B-Port : 1 */
+		.flite_id	= FLITE_IDX_B,
+		.cam_power	= smdk4x12_cam1_reset,
+#endif
+		.flags		= 0,
+		.csi_data_align = 12,
+		.use_isp	= true,
+	},
+#endif
+#endif
+#if defined(WRITEBACK_ENABLED)
+	{
+		.board_info	= &writeback_info,
+		.bus_type	= FIMC_LCD_WB,
+		.i2c_bus_num	= 0,
+		.mux_id		= 0, /* A-Port : 0, B-Port : 1 */
+		.flags		= FIMC_CLK_INV_VSYNC,
+	},
+#endif
+};
+
+static void __init smdk4x12_subdev_config(void)
+{
+
+#if 0
+#if defined(CONFIG_VIDEO_S5K4ECGX)
+	s3c_fimc0_default_data.isp_info[0] = &isp_info[0];//&s5k4ec;
+	s3c_fimc0_default_data.isp_info[0]->use_cam = true;
+	//s3c_fimc0_default_data.cam[0] = &s5k4ecgx;
+	//exynos_flite0_default_data.cam[flite0_cam_index] = &s5k4ecgx;
+	//exynos_flite0_default_data.isp_info[flite0_cam_index] = &isp_info[0];//&s5k4ec;
+	//flite0_cam_index++;
+#endif
+
+#if defined(CONFIG_SOC_CAMERA_MT9D115)
+	s3c_fimc0_default_data.isp_info[1] = &isp_info[1];
+	s3c_fimc0_default_data.isp_info[1]->use_cam = true;
+	//exynos_flite1_default_data.cam[flite1_cam_index] = &mt9d115;
+	//exynos_flite1_default_data.isp_info[flite1_cam_index] = &isp_info[1];
+	//flite0_cam_index++;
+#endif
+
+#else
+
+#if defined(CONFIG_SOC_CAMERA_MT9D115)
+	s3c_fimc0_default_data.isp_info[0] = &isp_info[0];
+	s3c_fimc0_default_data.isp_info[0]->use_cam = true;
+	s3c_fimc1_default_data.isp_info[0] = &isp_info[0];
+	s3c_fimc1_default_data.isp_info[0]->use_cam = false;
+	//exynos_flite1_default_data.cam[flite1_cam_index] = &mt9d115;
+	//exynos_flite1_default_data.isp_info[flite1_cam_index] = &isp_info[1];
+	//flite0_cam_index++;
+#endif
+
+
+#if defined(CONFIG_VIDEO_S5K4ECGX)
+	s3c_fimc0_default_data.isp_info[1] = &isp_info[1];//&s5k4ec;
+	s3c_fimc0_default_data.isp_info[1]->use_cam = true;
+	s3c_fimc1_default_data.isp_info[1] = &isp_info[1];
+	s3c_fimc1_default_data.isp_info[1]->use_cam = false;
+	//s3c_fimc0_default_data.cam[0] = &s5k4ecgx;
+	//exynos_flite0_default_data.cam[flite0_cam_index] = &s5k4ecgx;
+	//exynos_flite0_default_data.isp_info[flite0_cam_index] = &isp_info[0];//&s5k4ec;
+	//flite0_cam_index++;
+#endif
+#endif
+
+
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_IS
+#ifdef CONFIG_VIDEO_S5K3H2
+#ifdef CONFIG_S5K3H2_CSI_C
+	s5p_mipi_csis0_default_data.clk_rate	= 160000000;
+	s5p_mipi_csis0_default_data.lanes	= 2;
+	s5p_mipi_csis0_default_data.alignment	= 24;
+	s5p_mipi_csis0_default_data.hs_settle	= 12;
+#endif
+#ifdef CONFIG_S5K3H2_CSI_D
+	s5p_mipi_csis1_default_data.clk_rate	= 160000000;
+	s5p_mipi_csis1_default_data.lanes	= 2;
+	s5p_mipi_csis1_default_data.alignment	= 24;
+	s5p_mipi_csis1_default_data.hs_settle	= 12;
+#endif
+#endif
+#ifdef CONFIG_VIDEO_S5K3H7
+#ifdef CONFIG_S5K3H7_CSI_C
+	s5p_mipi_csis0_default_data.clk_rate	= 160000000;
+	s5p_mipi_csis0_default_data.lanes	= 2;
+	s5p_mipi_csis0_default_data.alignment	= 24;
+	s5p_mipi_csis0_default_data.hs_settle	= 12;
+#endif
+#ifdef CONFIG_S5K3H7_CSI_D
+	s5p_mipi_csis1_default_data.clk_rate	= 160000000;
+	s5p_mipi_csis1_default_data.lanes	= 2;
+	s5p_mipi_csis1_default_data.alignment	= 24;
+	s5p_mipi_csis1_default_data.hs_settle	= 12;
+#endif
+#endif
+#ifdef CONFIG_VIDEO_S5K4E5
+#ifdef CONFIG_S5K4E5_CSI_C
+	s5p_mipi_csis0_default_data.clk_rate	= 160000000;
+	s5p_mipi_csis0_default_data.lanes	= 2;
+	s5p_mipi_csis0_default_data.alignment	= 24;
+	s5p_mipi_csis0_default_data.hs_settle	= 12;
+#endif
+#ifdef CONFIG_S5K4E5_CSI_D
+	s5p_mipi_csis1_default_data.clk_rate	= 160000000;
+	s5p_mipi_csis1_default_data.lanes	= 2;
+	s5p_mipi_csis1_default_data.alignment	= 24;
+	s5p_mipi_csis1_default_data.hs_settle	= 12;
+#endif
+#endif
+#ifdef CONFIG_VIDEO_S5K6A3
+#ifdef CONFIG_S5K6A3_CSI_C
+	s5p_mipi_csis0_default_data.clk_rate	= 160000000;
+	s5p_mipi_csis0_default_data.lanes 	= 1;
+	s5p_mipi_csis0_default_data.alignment	= 24;
+	s5p_mipi_csis0_default_data.hs_settle	= 12;
+#endif
+#ifdef CONFIG_S5K6A3_CSI_D
+	s5p_mipi_csis1_default_data.clk_rate	= 160000000;
+	s5p_mipi_csis1_default_data.lanes 	= 1;
+	s5p_mipi_csis1_default_data.alignment	= 24;
+	s5p_mipi_csis1_default_data.hs_settle	= 12;
+#endif
+#endif
+#endif
+}
+
+static void __init smdk4x12_camera_config(void)
+{
+	/* CAM A port(b0010) : PCLK, VSYNC, HREF, DATA[0-4] */
+	s3c_gpio_cfgrange_nopull(EXYNOS4212_GPJ0(0), 8, S3C_GPIO_SFN(2));
+	/* CAM A port(b0010) : DATA[5-7], CLKOUT(MIPI CAM also), FIELD */
+	s3c_gpio_cfgrange_nopull(EXYNOS4212_GPJ1(0), 5, S3C_GPIO_SFN(2));
+	/* CAM B port(b0011) : PCLK, DATA[0-6] */
+	s3c_gpio_cfgrange_nopull(EXYNOS4212_GPM0(0), 8, S3C_GPIO_SFN(3));
+	/* CAM B port(b0011) : FIELD, DATA[7]*/
+	s3c_gpio_cfgrange_nopull(EXYNOS4212_GPM1(0), 2, S3C_GPIO_SFN(3));
+	/* CAM B port(b0011) : VSYNC, HREF, CLKOUT*/
+	s3c_gpio_cfgrange_nopull(EXYNOS4212_GPM2(0), 3, S3C_GPIO_SFN(3));
+
+	/* note : driver strength to max is unnecessary */
+#ifdef CONFIG_VIDEO_M5MOLS
+	s3c_gpio_cfgpin(EXYNOS4_GPX2(6), S3C_GPIO_SFN(0xF));
+	s3c_gpio_setpull(EXYNOS4_GPX2(6), S3C_GPIO_PULL_NONE);
+#endif
+}
+#endif /* CONFIG_VIDEO_SAMSUNG_S5P_FIMC */
+
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_LITE
+static void __set_flite_camera_config(struct exynos_platform_flite *data,
+					u32 active_index, u32 max_cam)
+{
+	data->active_cam_index = active_index;
+	data->num_clients = max_cam;
+}
+
+static void __init smdk4x12_set_camera_flite_platdata(void)
+{
+	int flite0_cam_index = 0;
+	int flite1_cam_index = 0;
+#ifdef CONFIG_VIDEO_S5K3H2
+#ifdef CONFIG_S5K3H2_CSI_C
+	exynos_flite0_default_data.cam[flite0_cam_index++] = &s5k3h2;
+#endif
+#ifdef CONFIG_S5K3H2_CSI_D
+	exynos_flite1_default_data.cam[flite1_cam_index++] = &s5k3h2;
+#endif
+#endif
+#ifdef CONFIG_VIDEO_S5K3H7
+#ifdef CONFIG_S5K3H7_CSI_C
+	exynos_flite0_default_data.cam[flite0_cam_index++] = &s5k3h7;
+#endif
+#ifdef CONFIG_S5K3H7_CSI_D
+	exynos_flite1_default_data.cam[flite1_cam_index++] = &s5k3h7;
+#endif
+#endif
+#ifdef CONFIG_VIDEO_S5K4E5
+#ifdef CONFIG_S5K4E5_CSI_C
+	exynos_flite0_default_data.cam[flite0_cam_index++] = &s5k4e5;
+#endif
+#ifdef CONFIG_S5K4E5_CSI_D
+	exynos_flite1_default_data.cam[flite1_cam_index++] = &s5k4e5;
+#endif
+#endif
+
+#ifdef CONFIG_VIDEO_S5K6A3
+#ifdef CONFIG_S5K6A3_CSI_C
+	exynos_flite0_default_data.cam[flite0_cam_index++] = &s5k6a3;
+#endif
+#ifdef CONFIG_S5K6A3_CSI_D
+	exynos_flite1_default_data.cam[flite1_cam_index++] = &s5k6a3;
+#endif
+#endif
+	__set_flite_camera_config(&exynos_flite0_default_data, 0, flite0_cam_index);
+	__set_flite_camera_config(&exynos_flite1_default_data, 0, flite1_cam_index);
+}
+#endif
+
+#if defined(CONFIG_S5P_MEM_CMA)
+static void __init exynos4_cma_region_reserve(
+			struct cma_region *regions_normal,
+			struct cma_region *regions_secure)
+{
+	struct cma_region *reg;
+	phys_addr_t paddr_last = 0xFFFFFFFF;
+
+	for (reg = regions_normal; reg->size != 0; reg++) {
+		phys_addr_t paddr;
+
+		if (!IS_ALIGNED(reg->size, PAGE_SIZE)) {
+			pr_err("S5P/CMA: size of '%s' is NOT page-aligned\n",
+								reg->name);
+			reg->size = PAGE_ALIGN(reg->size);
+		}
+
+
+		if (reg->reserved) {
+			pr_err("S5P/CMA: '%s' alread reserved\n", reg->name);
+			continue;
+		}
+
+		if (reg->alignment) {
+			if ((reg->alignment & ~PAGE_MASK) ||
+				(reg->alignment & ~reg->alignment)) {
+				pr_err("S5P/CMA: Failed to reserve '%s': "
+						"incorrect alignment 0x%08x.\n",
+						reg->name, reg->alignment);
+				continue;
+			}
+		} else {
+			reg->alignment = PAGE_SIZE;
+		}
+
+		if (reg->start) {
+			if (!memblock_is_region_reserved(reg->start, reg->size)
+			    && (memblock_reserve(reg->start, reg->size) == 0))
+				reg->reserved = 1;
+			else
+				pr_err("S5P/CMA: Failed to reserve '%s'\n",
+								reg->name);
+
+			continue;
+		}
+
+		paddr = memblock_find_in_range(0, MEMBLOCK_ALLOC_ACCESSIBLE,
+						reg->size, reg->alignment);
+		if (paddr != MEMBLOCK_ERROR) {
+			if (memblock_reserve(paddr, reg->size)) {
+				pr_err("S5P/CMA: Failed to reserve '%s'\n",
+								reg->name);
+				continue;
+			}
+
+			reg->start = paddr;
+			reg->reserved = 1;
+		} else {
+			pr_err("S5P/CMA: No free space in memory for '%s'\n",
+								reg->name);
+		}
+
+		if (cma_early_region_register(reg)) {
+			pr_err("S5P/CMA: Failed to register '%s'\n",
+								reg->name);
+			memblock_free(reg->start, reg->size);
+		} else {
+			paddr_last = min(paddr, paddr_last);
+		}
+	}
+
+	if (regions_secure && regions_secure->size) {
+		size_t size_secure = 0;
+		size_t align_secure, size_region2, aug_size, order_region2;
+
+		for (reg = regions_secure; reg->size != 0; reg++)
+			size_secure += reg->size;
+
+		reg--;
+
+		/* Entire secure regions will be merged into 2
+		 * consecutive regions. */
+		align_secure = 1 <<
+			(get_order((size_secure + 1) / 2) + PAGE_SHIFT);
+		/* Calculation of a subregion size */
+		size_region2 = size_secure - align_secure;
+		order_region2 = get_order(size_region2) + PAGE_SHIFT;
+		if (order_region2 < 20)
+			order_region2 = 20; /* 1MB */
+		order_region2 -= 3; /* divide by 8 */
+		size_region2 = ALIGN(size_region2, 1 << order_region2);
+
+		aug_size = align_secure + size_region2 - size_secure;
+		if (aug_size > 0)
+			reg->size += aug_size;
+
+		size_secure = ALIGN(size_secure, align_secure);
+
+		if (paddr_last >= memblock.current_limit) {
+			paddr_last = memblock_find_in_range(0,
+					MEMBLOCK_ALLOC_ACCESSIBLE,
+					size_secure, reg->alignment);
+		} else {
+			paddr_last -= size_secure;
+			paddr_last = round_down(paddr_last, align_secure);
+		}
+
+		if (paddr_last) {
+			while (memblock_reserve(paddr_last, size_secure))
+				paddr_last -= align_secure;
+
+			do {
+				reg->start = paddr_last;
+				reg->reserved = 1;
+				paddr_last += reg->size;
+
+				if (cma_early_region_register(reg)) {
+					memblock_free(reg->start, reg->size);
+					pr_err("S5P/CMA: "
+					"Failed to register secure region "
+					"'%s'\n", reg->name);
+				} else {
+					size_secure -= reg->size;
+				}
+			} while (reg-- != regions_secure);
+
+			if (size_secure > 0)
+				memblock_free(paddr_last, size_secure);
+		} else {
+			pr_err("S5P/CMA: Failed to reserve secure regions\n");
+		}
+	}
+}
+
+static void __init exynos4_reserve_mem(void)
+{
+	static struct cma_region regions[] = {
+#ifdef CONFIG_ANDROID_PMEM_MEMSIZE_PMEM
+		{
+			.name = "pmem",
+			.size = CONFIG_ANDROID_PMEM_MEMSIZE_PMEM * SZ_1K,
+			.start = 0,
+		},
+#endif
+#ifdef CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_GPU1
+		{
+			.name = "pmem_gpu1",
+			.size = CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_GPU1 * SZ_1K,
+			.start = 0,
+		},
+#endif
+#ifndef CONFIG_VIDEOBUF2_ION
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_TV
+		{
+			.name = "tv",
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_TV * SZ_1K,
+			.start = 0
+		},
+#endif
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_JPEG
+		{
+			.name = "jpeg",
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_JPEG * SZ_1K,
+			.start = 0
+		},
+#endif
+#ifdef CONFIG_AUDIO_SAMSUNG_MEMSIZE_SRP
+		{
+			.name = "srp",
+			.size = CONFIG_AUDIO_SAMSUNG_MEMSIZE_SRP * SZ_1K,
+			.start = 0,
+		},
+#endif
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMG2D
+		{
+			.name = "fimg2d",
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMG2D * SZ_1K,
+			.start = 0
+		},
+#endif
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMD
+		{
+			.name = "fimd",
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMD * SZ_1K,
+			.start = 0
+		},
+#endif
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC0
+		{
+			.name = "fimc0",
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC0 * SZ_1K,
+			.start = 0
+		},
+#endif
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC2
+		{
+			.name = "fimc2",
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC2 * SZ_1K,
+			.start = 0
+		},
+#endif
+#if !defined(CONFIG_EXYNOS4_CONTENT_PATH_PROTECTION) && \
+	defined(CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC3)
+		{
+			.name = "fimc3",
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC3 * SZ_1K,
+		},
+#endif
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC1
+		{
+			.name = "fimc1",
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC1 * SZ_1K,
+			.start = 0
+		},
+#endif
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC1
+		{
+#ifdef CONFIG_EXYNOS4_CONTENT_PATH_PROTECTION
+			.name = "mfc-normal",
+#else
+			.name = "mfc1",
+#endif
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC1 * SZ_1K,
+			{ .alignment = 1 << 17 },
+		},
+#endif
+#if !defined(CONFIG_EXYNOS4_CONTENT_PATH_PROTECTION) && \
+	defined(CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC0)
+		{
+			.name = "mfc0",
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC0 * SZ_1K,
+			{ .alignment = 1 << 17 },
+		},
+#endif
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC
+		{
+			.name = "mfc",
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC * SZ_1K,
+			{ .alignment = 1 << 17 },
+		},
+#endif
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_IS
+		{
+			.name = "fimc_is",
+			.size = CONFIG_VIDEO_EXYNOS_MEMSIZE_FIMC_IS * SZ_1K,
+			{
+				.alignment = 1 << 26,
+			},
+			.start = 0
+		},
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_IS_BAYER
+		{
+			.name = "fimc_is_isp",
+			.size = CONFIG_VIDEO_EXYNOS_MEMSIZE_FIMC_IS_ISP * SZ_1K,
+			.start = 0
+		},
+#endif
+#endif
+#if !defined(CONFIG_EXYNOS4_CONTENT_PATH_PROTECTION) && \
+	defined(CONFIG_VIDEO_SAMSUNG_S5P_MFC)
+		{
+			.name		= "b2",
+			.size		= 32 << 20,
+			{ .alignment	= 128 << 10 },
+		},
+		{
+			.name		= "b1",
+			.size		= 32 << 20,
+			{ .alignment	= 128 << 10 },
+		},
+		{
+			.name		= "fw",
+			.size		= 1 << 20,
+			{ .alignment	= 128 << 10 },
+		},
+#endif
+#else /* !CONFIG_VIDEOBUF2_ION */
+#ifdef CONFIG_FB_S5P
+#error CONFIG_FB_S5P is defined. Select CONFIG_FB_S3C, instead
+#endif
+		{
+			.name	= "ion",
+			.size	= CONFIG_ION_EXYNOS_CONTIGHEAP_SIZE * SZ_1K,
+		},
+#endif /* !CONFIG_VIDEOBUF2_ION */
+		{
+			.size = 0
+		},
+	};
+#ifdef CONFIG_EXYNOS4_CONTENT_PATH_PROTECTION
+	static struct cma_region regions_secure[] = {
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMD_VIDEO
+		{
+			.name = "video",
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMD_VIDEO * SZ_1K,
+		},
+#endif
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC3
+		{
+			.name = "fimc3",
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC3 * SZ_1K,
+		},
+#endif
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC0
+		{
+			.name = "mfc-secure",
+			.size = CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC0 * SZ_1K,
+		},
+#endif
+		{
+			.name = "sectbl",
+			.size = SZ_1M,
+			{
+				.alignment = SZ_64M,
+			},
+		},
+		{
+			.size = 0
+		},
+	};
+#else /* !CONFIG_EXYNOS4_CONTENT_PATH_PROTECTION */
+	struct cma_region *regions_secure = NULL;
+#endif
+	static const char map[] __initconst =
+#ifdef CONFIG_EXYNOS_C2C
+		"samsung-c2c=c2c_shdmem;"
+#endif
+		"android_pmem.0=pmem;android_pmem.1=pmem_gpu1;"
+		"s3cfb.0/fimd=fimd;exynos4-fb.0/fimd=fimd;"
+#ifdef CONFIG_EXYNOS4_CONTENT_PATH_PROTECTION
+		"s3cfb.0/video=video;exynos4-fb.0/video=video;"
+#endif
+		"s3c-fimc.0=fimc0;s3c-fimc.1=fimc1;s3c-fimc.2=fimc2;s3c-fimc.3=fimc3;"
+		"exynos4210-fimc.0=fimc0;exynos4210-fimc.1=fimc1;exynos4210-fimc.2=fimc2;exynos4210-fimc.3=fimc3;"
+#ifdef CONFIG_VIDEO_MFC5X
+		"s3c-mfc/A=mfc0,mfc-secure;"
+		"s3c-mfc/B=mfc1,mfc-normal;"
+		"s3c-mfc/AB=mfc;"
+#endif
+#ifdef CONFIG_VIDEO_SAMSUNG_S5P_MFC
+		"s5p-mfc/f=fw;"
+		"s5p-mfc/a=b1;"
+		"s5p-mfc/b=b2;"
+#endif
+		"samsung-rp=srp;"
+		"s5p-jpeg=jpeg;"
+		"exynos4-fimc-is/f=fimc_is;"
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_IS_BAYER
+		"exynos4-fimc-is/i=fimc_is_isp;"
+#endif
+		"s5p-mixer=tv;"
+		"s5p-fimg2d=fimg2d;"
+		"ion-exynos=ion,fimd,fimc0,fimc1,fimc2,fimc3,fw,b1,b2;"
+#ifdef CONFIG_EXYNOS4_CONTENT_PATH_PROTECTION
+		"s5p-smem/video=video;"
+		"s5p-smem/sectbl=sectbl;"
+#endif
+		"s5p-smem/mfc=mfc0,mfc-secure;"
+		"s5p-smem/fimc=fimc3;"
+		"s5p-smem/mfc-shm=mfc1,mfc-normal;";
+
+	cma_set_defaults(NULL, map);
+
+	exynos4_cma_region_reserve(regions, regions_secure);
+}
+#endif
+
+/* LCD Backlight data */
+static struct samsung_bl_gpio_info smdk4x12_bl_gpio_info = {
+	.no = EXYNOS4_GPD0(1),
+	.func = S3C_GPIO_SFN(2),
+};
+
+static struct platform_pwm_backlight_data smdk4x12_bl_data = {
+	.pwm_id = 1,
+#ifdef CONFIG_FB_S5P_LMS501KF03
+	.pwm_period_ns  = 1000,
+#endif
+};
+
+static void __init smdk4x12_map_io(void)
+{
+	clk_xusbxti.rate = 24000000;
+	s5p_init_io(NULL, 0, S5P_VA_CHIPID);
+	s3c24xx_init_clocks(24000000);
+	s3c24xx_init_uarts(smdk4x12_uartcfgs, ARRAY_SIZE(smdk4x12_uartcfgs));
+
+#if defined(CONFIG_S5P_MEM_CMA)
+	exynos4_reserve_mem();
+#endif
+}
+
+static void __init smdk4x12_smsc911x_init(void)
+{
+	u32 cs1;
+
+	/* configure nCS1 width to 16 bits */
+	cs1 = __raw_readl(S5P_SROM_BW) &
+		~(S5P_SROM_BW__CS_MASK << S5P_SROM_BW__NCS1__SHIFT);
+	cs1 |= ((1 << S5P_SROM_BW__DATAWIDTH__SHIFT) |
+		(1 << S5P_SROM_BW__WAITENABLE__SHIFT) |
+		(1 << S5P_SROM_BW__BYTEENABLE__SHIFT)) <<
+		S5P_SROM_BW__NCS1__SHIFT;
+	__raw_writel(cs1, S5P_SROM_BW);
+
+	/* set timing for nCS1 suitable for ethernet chip */
+	__raw_writel((0x1 << S5P_SROM_BCX__PMC__SHIFT) |
+		     (0x9 << S5P_SROM_BCX__TACP__SHIFT) |
+		     (0xc << S5P_SROM_BCX__TCAH__SHIFT) |
+		     (0x1 << S5P_SROM_BCX__TCOH__SHIFT) |
+		     (0x6 << S5P_SROM_BCX__TACC__SHIFT) |
+		     (0x1 << S5P_SROM_BCX__TCOS__SHIFT) |
+		     (0x1 << S5P_SROM_BCX__TACS__SHIFT), S5P_SROM_BC1);
+}
+
+#ifndef CONFIG_TC4_GB
+static void __init exynos_sysmmu_init(void)
+{
+	ASSIGN_SYSMMU_POWERDOMAIN(fimc0, &exynos4_device_pd[PD_CAM].dev);
+	ASSIGN_SYSMMU_POWERDOMAIN(fimc1, &exynos4_device_pd[PD_CAM].dev);
+	ASSIGN_SYSMMU_POWERDOMAIN(fimc2, &exynos4_device_pd[PD_CAM].dev);
+	ASSIGN_SYSMMU_POWERDOMAIN(fimc3, &exynos4_device_pd[PD_CAM].dev);
+	ASSIGN_SYSMMU_POWERDOMAIN(jpeg, &exynos4_device_pd[PD_CAM].dev);
+	ASSIGN_SYSMMU_POWERDOMAIN(mfc_l, &exynos4_device_pd[PD_MFC].dev);
+	ASSIGN_SYSMMU_POWERDOMAIN(mfc_r, &exynos4_device_pd[PD_MFC].dev);
+	ASSIGN_SYSMMU_POWERDOMAIN(tv, &exynos4_device_pd[PD_TV].dev);
+#ifdef CONFIG_VIDEO_FIMG2D
+	sysmmu_set_owner(&SYSMMU_PLATDEV(g2d_acp).dev, &s5p_device_fimg2d.dev);
+#endif
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_MFC) || defined(CONFIG_VIDEO_MFC5X)
+	sysmmu_set_owner(&SYSMMU_PLATDEV(mfc_l).dev, &s5p_device_mfc.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(mfc_r).dev, &s5p_device_mfc.dev);
+#endif
+#if defined(CONFIG_VIDEO_FIMC)
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s3c_device_fimc0.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s3c_device_fimc1.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s3c_device_fimc2.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s3c_device_fimc3.dev);
+#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s5p_device_fimc0.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s5p_device_fimc1.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s5p_device_fimc2.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s5p_device_fimc3.dev);
+#endif
+#ifdef CONFIG_VIDEO_EXYNOS_TV
+	sysmmu_set_owner(&SYSMMU_PLATDEV(tv).dev, &s5p_device_mixer.dev);
+#endif
+#ifdef CONFIG_VIDEO_TVOUT
+	sysmmu_set_owner(&SYSMMU_PLATDEV(tv).dev, &s5p_device_tvout.dev);
+#endif
+#ifdef CONFIG_VIDEO_JPEG_V2X
+	sysmmu_set_owner(&SYSMMU_PLATDEV(jpeg).dev, &s5p_device_jpeg.dev);
+#endif
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_IS
+	ASSIGN_SYSMMU_POWERDOMAIN(is_isp, &exynos4_device_pd[PD_ISP].dev);
+	ASSIGN_SYSMMU_POWERDOMAIN(is_drc, &exynos4_device_pd[PD_ISP].dev);
+	ASSIGN_SYSMMU_POWERDOMAIN(is_fd, &exynos4_device_pd[PD_ISP].dev);
+	ASSIGN_SYSMMU_POWERDOMAIN(is_cpu, &exynos4_device_pd[PD_ISP].dev);
+
+	sysmmu_set_owner(&SYSMMU_PLATDEV(is_isp).dev,
+						&exynos4_device_fimc_is.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(is_drc).dev,
+						&exynos4_device_fimc_is.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(is_fd).dev,
+						&exynos4_device_fimc_is.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(is_cpu).dev,
+						&exynos4_device_fimc_is.dev);
+#endif
+}
+
+#endif
+// zsb: wait for i2c5 bus idle before software reset
+extern int wait_for_i2c_idle(struct platform_device *pdev);
+#if 1 //def CONFIG_TC4_EVT //mj
+extern int is_charger_online();
+#endif
+static void smdk4x12_power_off(void)
+{
+	int ret = 0;
+	
+//shengliang
+	gpio_set_value(EXYNOS4_GPC0(0), 0);// MD_PWON low
+	msleep(10);
+	gpio_set_value(EXYNOS4_GPC0(2), 0);// MD_RSTN low
+	gpio_set_value(EXYNOS4_GPL2(1), 0);// MD_RESETBB low
+	msleep(10);
+	#ifdef CONFIG_TC4_EVT
+	if (is_charger_online())
+	#else
+	if(0) //Robin, For TC4 DVT, when usb plug-in, the pmic still can power off...
+	#endif
+	{    
+		//Turn off some LDO&BUCKs, Will Implment later.
+		//max8997_pmic_off();//TBD,Robin Wang
+		ret = wait_for_i2c_idle(&s3c_device_i2c5);
+		if (ret != 0) 
+			printk(KERN_EMERG "%s : i2c5 bus is busy.\n", __func__);
+
+		writel(1,S5P_SWRESET);
+	}    
+	else 
+	{    
+		if (is_charger_online())//mj for charging while power off
+		{
+			printk(KERN_EMERG "%s : charging..\n", __func__);
+			writel(0xc2, S5P_INFORM5); //mj : power off-charging mode 
+			writel(1,S5P_SWRESET);
+		}
+		else
+		{
+			/* PS_HOLD --> Output Low */
+			printk(KERN_EMERG "%s : setting GPIO_PDA_PS_HOLD low.\n", __func__);
+			/* PS_HOLD output High --> Low  PS_HOLD_CONTROL, R/W, 0xE010_E81C */
+			writel(0x5200, S5P_PS_HOLD_CONTROL);
+		}
+	}    
+	while(1);
+
+	printk(KERN_EMERG "%s : should not reach here!\n", __func__);
+}
+
+#if 1
+extern void (*s3c_config_sleep_gpio_table)(void);
+#include <plat/gpio-core.h>
+
+int s3c_gpio_slp_cfgpin(unsigned int pin, unsigned int config)
+{
+	struct s3c_gpio_chip *chip = s3c_gpiolib_getchip(pin);
+	void __iomem *reg;
+	unsigned long flags;
+	int offset;
+	u32 con;
+	int shift;
+
+	if (!chip)
+		return -EINVAL;
+
+	if ((pin >= EXYNOS4_GPX0(0)) && (pin <= EXYNOS4_GPX3(7)))
+		return -EINVAL;
+
+	if (config > S3C_GPIO_SLP_PREV)
+		return -EINVAL;
+
+	reg = chip->base + 0x10;
+
+	offset = pin - chip->chip.base;
+	shift = offset * 2;
+
+	local_irq_save(flags);
+
+	con = __raw_readl(reg);
+	con &= ~(3 << shift);
+	con |= config << shift;
+	__raw_writel(con, reg);
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+int s3c_gpio_slp_setpull_updown(unsigned int pin, unsigned int config)
+{
+	struct s3c_gpio_chip *chip = s3c_gpiolib_getchip(pin);
+	void __iomem *reg;
+	unsigned long flags;
+	int offset;
+	u32 con;
+	int shift;
+
+	if (!chip)
+		return -EINVAL;
+
+	if ((pin >= EXYNOS4_GPX0(0)) && (pin <= EXYNOS4_GPX3(7)))
+		return -EINVAL;
+
+	if (config > S3C_GPIO_PULL_UP)
+		return -EINVAL;
+
+	reg = chip->base + 0x14;
+
+	offset = pin - chip->chip.base;
+	shift = offset * 2;
+
+	local_irq_save(flags);
+
+	con = __raw_readl(reg);
+	con &= ~(3 << shift);
+	con |= config << shift;
+	__raw_writel(con, reg);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static void config_sleep_gpio_table(int array_size, unsigned int (*gpio_table)[3])
+{
+        u32 i, gpio;
+
+        for (i = 0; i < array_size; i++) {
+                gpio = gpio_table[i][0];
+                s3c_gpio_slp_cfgpin(gpio, gpio_table[i][1]);
+                s3c_gpio_slp_setpull_updown(gpio, gpio_table[i][2]);
+        }
+}
+
+/*sleep gpio table for TC4*/
+static unsigned int tc4_sleep_gpio_table[][3] = {
+#if 1 //zhangdong reduce sleep current
+	{ EXYNOS4_GPA0(0),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //BT_TXD
+	{ EXYNOS4_GPA0(1),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //BT_RXD
+	{ EXYNOS4_GPA0(2),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //BT_RTS
+	{ EXYNOS4_GPA0(3),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //BT_CTS
+	
+	{ EXYNOS4_GPA0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //AC100_TXD,SMM6260
+	{ EXYNOS4_GPA0(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //AC100_RXD
+	{ EXYNOS4_GPA0(6),	S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE}, //AC100_RTS
+	{ EXYNOS4_GPA0(7),	S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE}, //AC100_CTS
+
+
+	{ EXYNOS4_GPA1(0),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //DEBUG
+	{ EXYNOS4_GPA1(1),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //DEBUG
+	{ EXYNOS4_GPA1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},  //I2C_SDA3
+	{ EXYNOS4_GPA1(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C_SCL3
+#ifdef CONFIG_TC4_EVT	
+	{ EXYNOS4_GPA1(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //TP1_RST
+	{ EXYNOS4_GPA1(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //TestPoint
+#endif
+#ifdef CONFIG_TC4_DVT
+	{ EXYNOS4_GPA1(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //GPS_TXD
+	{ EXYNOS4_GPA1(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //GPS_RXD
+#endif
+
+	{ EXYNOS4_GPB(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C_SDA4
+	{ EXYNOS4_GPB(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C_SCL4
+	{ EXYNOS4_GPB(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C_SDA5
+	{ EXYNOS4_GPB(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C_SCL5
+	{ EXYNOS4_GPB(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //GPS_RST
+	{ EXYNOS4_GPB(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //PMIC_SET1
+	{ EXYNOS4_GPB(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //PMIC_SET2
+	{ EXYNOS4_GPB(7),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //PMIC_SET3
+
+
+#ifdef CONFIG_SMM6260_MODEM
+	{ EXYNOS4_GPC0(0),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //MD_PWON
+#else
+	{ EXYNOS4_GPC0(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //MD_PWON
+#endif
+	{ EXYNOS4_GPC0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //VLED_ON
+	{ EXYNOS4_GPC0(2),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //MD_RSTN
+#ifdef CONFIG_SMM6260_MODEM
+	//{ EXYNOS4_GPC0(3),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //AP_SLEEP
+	{ EXYNOS4_GPC0(4),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //AP_WAKEUP_MD
+	{ EXYNOS4_GPX2(5),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //MD_WAKEUP_AP
+#else
+	{ EXYNOS4_GPC0(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //AP_SLEEP
+	{ EXYNOS4_GPC0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //AP_WAKEUP_MD
+#endif
+	
+	{ EXYNOS4_GPC1(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //UART_SW  config as hp  out1??
+	{ EXYNOS4_GPC1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //LED_EN18
+	{ EXYNOS4_GPC1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //VLED_EN
+	{ EXYNOS4_GPC1(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C6_SDA
+	{ EXYNOS4_GPC1(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C6_SCL
+
+	{ EXYNOS4_GPD0(0),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE}, // MOTOR-PWM
+	{ EXYNOS4_GPD0(1),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE}, //XPWMOUT1
+	{ EXYNOS4_GPD0(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},  //I2C7_SDA
+	{ EXYNOS4_GPD0(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C7_SCL
+
+	{ EXYNOS4_GPD1(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C0_SDA
+	{ EXYNOS4_GPD1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C0_SCL
+	{ EXYNOS4_GPD1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C1_SDA
+	{ EXYNOS4_GPD1(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C1_SCL
+
+	{ EXYNOS4_GPF0(0),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_HSYNC
+	{ EXYNOS4_GPF0(1),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_VSYNC
+	{ EXYNOS4_GPF0(2),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_VDEN
+	{ EXYNOS4_GPF0(3),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_VCLK
+	{ EXYNOS4_GPF0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//CAM2M_RST
+	{ EXYNOS4_GPF0(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//CAM2M_PWDN
+	{ EXYNOS4_GPF0(6),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_D2
+	{ EXYNOS4_GPF0(7),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_D3
+
+	{ EXYNOS4_GPF1(0),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_D4
+	{ EXYNOS4_GPF1(1),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_D5
+	{ EXYNOS4_GPF1(2),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D6
+	{ EXYNOS4_GPF1(3),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D7
+	{ EXYNOS4_GPF1(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//CAM5M_RST
+	{ EXYNOS4_GPF1(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//CAM5M_PWDN
+	{ EXYNOS4_GPF1(6),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D10
+	{ EXYNOS4_GPF1(7),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D11
+
+	{ EXYNOS4_GPF2(0),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D12
+	{ EXYNOS4_GPF2(1),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D13
+	{ EXYNOS4_GPF2(2),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D14
+	{ EXYNOS4_GPF2(3),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D15
+	{ EXYNOS4_GPF2(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPF2(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPF2(6),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D18
+	{ EXYNOS4_GPF2(7),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D19
+	
+	{ EXYNOS4_GPF3(0),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D20
+	{ EXYNOS4_GPF3(1),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D21
+	{ EXYNOS4_GPF3(2),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D22
+	{ EXYNOS4_GPF3(3),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D23
+	{ EXYNOS4_GPF3(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPF3(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//MD_G15
+
+	{ EXYNOS4212_GPJ0(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//CAM_CLK
+	{ EXYNOS4212_GPJ0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//CAM_VSYNC
+	{ EXYNOS4212_GPJ0(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//CAM_HREF
+	{ EXYNOS4212_GPJ0(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA0
+	{ EXYNOS4212_GPJ0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA1
+	{ EXYNOS4212_GPJ0(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA2
+	{ EXYNOS4212_GPJ0(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA3
+	{ EXYNOS4212_GPJ0(7),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA4
+
+	{ EXYNOS4212_GPJ1(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA5
+	{ EXYNOS4212_GPJ1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA6
+	{ EXYNOS4212_GPJ1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA7
+	{ EXYNOS4212_GPJ1(3),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//CAM_CLK_OUT
+	{ EXYNOS4212_GPJ1(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+
+	{ EXYNOS4_GPK0(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_CLK
+	{ EXYNOS4_GPK0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_CMD
+	{ EXYNOS4_GPK0(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_CDn
+	{ EXYNOS4_GPK0(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA0
+	{ EXYNOS4_GPK0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA1
+	{ EXYNOS4_GPK0(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA2
+	{ EXYNOS4_GPK0(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA3
+	#ifdef CONFIG_TC4_EVT
+	{ EXYNOS4_GPK1(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPK1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	#endif
+	#ifdef CONFIG_TC4_DVT
+	{ EXYNOS4_GPK1(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//ANX7805_PD
+	{ EXYNOS4_GPK1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//VDD50_EN
+	#endif
+	
+	{ EXYNOS4_GPK1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPK1(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA4
+	{ EXYNOS4_GPK1(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA5
+	{ EXYNOS4_GPK1(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA6
+	{ EXYNOS4_GPK1(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA7
+
+	{ EXYNOS4_GPK2(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//TF_CLK
+	{ EXYNOS4_GPK2(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//TF_CMD
+	{ EXYNOS4_GPK2(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//ANX7805_RSTN
+	{ EXYNOS4_GPK2(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//TF_DATA0
+	{ EXYNOS4_GPK2(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//TF_DATA1
+	{ EXYNOS4_GPK2(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//TF_DATA2
+	{ EXYNOS4_GPK2(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//TF_DATA3
+
+	{ EXYNOS4_GPK3(0),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//WIFI_CLK
+	{ EXYNOS4_GPK3(1),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//WIFI_CMD
+	{ EXYNOS4_GPK3(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//HUB_CONNECT
+	{ EXYNOS4_GPK3(3),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//WIFI_DATA0
+	{ EXYNOS4_GPK3(4),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//WIFI_DATA1
+	{ EXYNOS4_GPK3(5),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//WIFI_DATA2
+	{ EXYNOS4_GPK3(6),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//WIFI_DATA3
+
+	{ EXYNOS4_GPL0(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//BUCK6_EN
+	#ifdef CONFIG_TC4_EVT
+	{ EXYNOS4_GPL0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//VDD50_EN
+	#endif
+	#ifdef CONFIG_TC4_DVT
+	{ EXYNOS4_GPL0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//6260_GPIO3
+	#endif
+	
+	{ EXYNOS4_GPL0(2), /* S3C_GPIO_SLP_PREV*/S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//TP1_EN
+	{ EXYNOS4_GPL0(3),  S3C_GPIO_SLP_OUT1,	S3C_GPIO_PULL_NONE},	//NFC_EN1  out1
+	
+	{ EXYNOS4_GPL0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//CHG_EN
+	{ EXYNOS4_GPL0(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NO THIS PIN
+	{ EXYNOS4_GPL0(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//HDMI_IIC_EN
+	{ EXYNOS4_GPL0(7),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+
+	{ EXYNOS4_GPL1(0),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE}, 	//LVDS_PWDN  out0
+	{ EXYNOS4_GPL1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPL1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+
+	{ EXYNOS4_GPL2(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//KP_COL0
+#ifdef CONFIG_SMM6260_MODEM
+	{ EXYNOS4_GPL2(1),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//MD_RESETBB
+#else
+	{ EXYNOS4_GPL2(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//MD_RESETBB
+#endif
+	{ EXYNOS4_GPL2(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//HUB_RESET
+	{ EXYNOS4_GPL2(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//NFC_SCL
+	{ EXYNOS4_GPL2(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//NFC_SDA
+	{ EXYNOS4_GPL2(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NFC_GPIO4
+	#ifdef CONFIG_TC4_EVT
+	{ EXYNOS4_GPL2(6),	S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//ANX7805_PWON
+	{ EXYNOS4_GPL2(7),	S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//TP
+	#endif
+
+	#ifdef CONFIG_TC4_DVT
+	//GPM4(2) --ISP_SCL1
+	//GPM4(3)--ISP_SDA1
+	//GPM3(5)--PMIC_DS2
+	//GPM3(6)--PMIC_DS3
+	//GPM3(7)--PMIC_DS4
+	#endif
+	
+
+#if 1
+	{ EXYNOS4_GPY0(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPY0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+
+	{ EXYNOS4_GPY0(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY0(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY0(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+
+	{ EXYNOS4_GPY1(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY1(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+
+	{ EXYNOS4_GPY2(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY2(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY2(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY2(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY2(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY2(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+
+	{ EXYNOS4_GPY3(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+       { EXYNOS4_GPY3(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPY3(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* MHL_SCL_1.8V */
+	{ EXYNOS4_GPY3(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY3(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY3(5),  S3C_GPIO_SLP_INPUT,  S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY3(6),  S3C_GPIO_SLP_INPUT,  S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY3(7),  S3C_GPIO_SLP_INPUT,  S3C_GPIO_PULL_DOWN},
+
+	{ EXYNOS4_GPY4(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY4(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY4(2),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY4(3),  S3C_GPIO_SLP_INPUT,  S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY4(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY4(5),  S3C_GPIO_SLP_INPUT,  S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY4(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY4(7),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},
+
+	{ EXYNOS4_GPY5(0),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(1),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(2),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(3),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(4),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(5),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(6),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(7),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+
+	{ EXYNOS4_GPY6(0),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(1),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(2),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(3),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(4),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(5),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(6),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(7),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+#endif 
+	{ EXYNOS4_GPZ(0),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	//I2S0_SCLK
+	{ EXYNOS4_GPZ(1),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	//I2S0_CDCLK
+	{ EXYNOS4_GPZ(2),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN}, //I2S0_LRCK
+	{ EXYNOS4_GPZ(3),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN}, //I2S0_SDI
+	{ EXYNOS4_GPZ(4),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN}, //I2S0_SDO0
+	{ EXYNOS4_GPZ(5),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN}, //WIFI_PWDN
+	{ EXYNOS4_GPZ(6),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//BT_RST
+
+#else
+	{ EXYNOS4_GPA0(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //BT_TXD
+	{ EXYNOS4_GPA0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //BT_RXD
+	{ EXYNOS4_GPA0(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //BT_RTS
+	{ EXYNOS4_GPA0(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //BT_CTS
+	
+	{ EXYNOS4_GPA0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //AC100_TXD,SMM6260
+	{ EXYNOS4_GPA0(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //AC100_RXD
+	{ EXYNOS4_GPA0(6),	S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE}, //AC100_RTS
+	{ EXYNOS4_GPA0(7),	S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE}, //AC100_CTS
+
+
+	{ EXYNOS4_GPA1(0),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //DEBUG
+	{ EXYNOS4_GPA1(1),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE}, //DEBUG
+	{ EXYNOS4_GPA1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},  //I2C_SDA3
+	{ EXYNOS4_GPA1(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C_SCL3
+#ifdef CONFIG_TC4_EVT	
+	{ EXYNOS4_GPA1(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //TP1_RST
+	{ EXYNOS4_GPA1(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //TestPoint
+#endif
+#ifdef CONFIG_TC4_DVT
+	{ EXYNOS4_GPA1(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //GPS_TXD
+	{ EXYNOS4_GPA1(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //GPS_RXD
+#endif
+
+	{ EXYNOS4_GPB(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C_SDA4
+	{ EXYNOS4_GPB(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C_SCL4
+	{ EXYNOS4_GPB(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C_SDA5
+	{ EXYNOS4_GPB(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C_SCL5
+	{ EXYNOS4_GPB(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //GPS_RST
+	{ EXYNOS4_GPB(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //PMIC_SET1
+	{ EXYNOS4_GPB(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //PMIC_SET2
+	{ EXYNOS4_GPB(7),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //PMIC_SET3
+
+
+	{ EXYNOS4_GPC0(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //MD_PWON
+	{ EXYNOS4_GPC0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //VLED_ON
+#ifdef CONFIG_SMM6260_MODEM
+	{ EXYNOS4_GPC0(2),  S3C_GPIO_SLP_PREV,  S3C_GPIO_PULL_NONE}, //MD_RSTN  //lisw_2012.029 for Modem do not go into L3
+#else
+	{ EXYNOS4_GPC0(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //MD_RSTN
+#endif
+	{ EXYNOS4_GPC0(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //AP_SLEEP
+	{ EXYNOS4_GPC0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //AP_WAKEUP_MD
+	
+	{ EXYNOS4_GPC1(0),  S3C_GPIO_SLP_PREV,  S3C_GPIO_PULL_NONE}, //UART_SW  config as hp  out1??
+	{ EXYNOS4_GPC1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //LED_EN18
+	{ EXYNOS4_GPC1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN}, //VLED_EN
+	{ EXYNOS4_GPC1(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C6_SDA
+	{ EXYNOS4_GPC1(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C6_SCL
+
+	{ EXYNOS4_GPD0(0),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE}, // MOTOR-PWM
+	{ EXYNOS4_GPD0(1),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE}, //XPWMOUT1
+	{ EXYNOS4_GPD0(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},  //I2C7_SDA
+	{ EXYNOS4_GPD0(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C7_SCL
+
+	{ EXYNOS4_GPD1(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C0_SDA
+	{ EXYNOS4_GPD1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C0_SCL
+	{ EXYNOS4_GPD1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C1_SDA
+	{ EXYNOS4_GPD1(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE}, //I2C1_SCL
+
+	{ EXYNOS4_GPF0(0),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_HSYNC
+	{ EXYNOS4_GPF0(1),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_VSYNC
+	{ EXYNOS4_GPF0(2),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_VDEN
+	{ EXYNOS4_GPF0(3),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_VCLK
+	{ EXYNOS4_GPF0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//CAM2M_RST
+	{ EXYNOS4_GPF0(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//CAM2M_PWDN
+	{ EXYNOS4_GPF0(6),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_D2
+	{ EXYNOS4_GPF0(7),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_D3
+
+	{ EXYNOS4_GPF1(0),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_D4
+	{ EXYNOS4_GPF1(1),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//LCD_D5
+	{ EXYNOS4_GPF1(2),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D6
+	{ EXYNOS4_GPF1(3),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D7
+	{ EXYNOS4_GPF1(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//CAM5M_RST
+	{ EXYNOS4_GPF1(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//CAM5M_PWDN
+	{ EXYNOS4_GPF1(6),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D10
+	{ EXYNOS4_GPF1(7),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D11
+
+	{ EXYNOS4_GPF2(0),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D12
+	{ EXYNOS4_GPF2(1),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D13
+	{ EXYNOS4_GPF2(2),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D14
+	{ EXYNOS4_GPF2(3),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D15
+	{ EXYNOS4_GPF2(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPF2(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPF2(6),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D18
+	{ EXYNOS4_GPF2(7),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D19
+	
+	{ EXYNOS4_GPF3(0),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D20
+	{ EXYNOS4_GPF3(1),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D21
+	{ EXYNOS4_GPF3(2),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D22
+	{ EXYNOS4_GPF3(3),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//D23
+	{ EXYNOS4_GPF3(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPF3(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//MD_G15
+
+	{ EXYNOS4212_GPJ0(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//CAM_CLK
+	{ EXYNOS4212_GPJ0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//CAM_VSYNC
+	{ EXYNOS4212_GPJ0(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//CAM_HREF
+	{ EXYNOS4212_GPJ0(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA0
+	{ EXYNOS4212_GPJ0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA1
+	{ EXYNOS4212_GPJ0(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA2
+	{ EXYNOS4212_GPJ0(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA3
+	{ EXYNOS4212_GPJ0(7),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA4
+
+	{ EXYNOS4212_GPJ1(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA5
+	{ EXYNOS4212_GPJ1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA6
+	{ EXYNOS4212_GPJ1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//DATA7
+	{ EXYNOS4212_GPJ1(3),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE},	//CAM_CLK_OUT
+	{ EXYNOS4212_GPJ1(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+
+	{ EXYNOS4_GPK0(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_CLK
+	{ EXYNOS4_GPK0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_CMD
+	{ EXYNOS4_GPK0(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_CDn
+	{ EXYNOS4_GPK0(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA0
+	{ EXYNOS4_GPK0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA1
+	{ EXYNOS4_GPK0(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA2
+	{ EXYNOS4_GPK0(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA3
+	#ifdef CONFIG_TC4_EVT
+	{ EXYNOS4_GPK1(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPK1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	#endif
+	#ifdef CONFIG_TC4_DVT
+	{ EXYNOS4_GPK1(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//ANX7805_PD
+	{ EXYNOS4_GPK1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//VDD50_EN
+	#endif
+	
+	{ EXYNOS4_GPK1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPK1(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA4
+	{ EXYNOS4_GPK1(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA5
+	{ EXYNOS4_GPK1(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA6
+	{ EXYNOS4_GPK1(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//eMMC_DATA7
+
+	{ EXYNOS4_GPK2(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//TF_CLK
+	{ EXYNOS4_GPK2(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//TF_CMD
+	{ EXYNOS4_GPK2(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//ANX7805_RSTN
+	{ EXYNOS4_GPK2(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//TF_DATA0
+	{ EXYNOS4_GPK2(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//TF_DATA1
+	{ EXYNOS4_GPK2(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//TF_DATA2
+	{ EXYNOS4_GPK2(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//TF_DATA3
+
+	{ EXYNOS4_GPK3(0),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//WIFI_CLK
+	{ EXYNOS4_GPK3(1),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//WIFI_CMD
+	{ EXYNOS4_GPK3(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//HUB_CONNECT
+	{ EXYNOS4_GPK3(3),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//WIFI_DATA0
+	{ EXYNOS4_GPK3(4),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//WIFI_DATA1
+	{ EXYNOS4_GPK3(5),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//WIFI_DATA2
+	{ EXYNOS4_GPK3(6),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//WIFI_DATA3
+
+	{ EXYNOS4_GPL0(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//BUCK6_EN
+	#ifdef CONFIG_TC4_EVT
+	{ EXYNOS4_GPL0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//VDD50_EN
+	#endif
+	#ifdef CONFIG_TC4_DVT
+	{ EXYNOS4_GPL0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//6260_GPIO3
+	#endif
+	
+	{ EXYNOS4_GPL0(2),  S3C_GPIO_SLP_PREV,	S3C_GPIO_PULL_NONE},	//TP1_EN
+	{ EXYNOS4_GPL0(3),  S3C_GPIO_SLP_OUT1,	S3C_GPIO_PULL_NONE},	//NFC_EN1  out1
+	
+	{ EXYNOS4_GPL0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//CHG_EN
+	{ EXYNOS4_GPL0(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//NO THIS PIN
+	{ EXYNOS4_GPL0(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//HDMI_IIC_EN
+	{ EXYNOS4_GPL0(7),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//NC
+
+	{ EXYNOS4_GPL1(0),  S3C_GPIO_SLP_OUT0,	S3C_GPIO_PULL_NONE}, 	//LVDS_PWDN  out0
+	{ EXYNOS4_GPL1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//NC
+	{ EXYNOS4_GPL1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//NC
+
+	{ EXYNOS4_GPL2(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//KP_COL0
+	{ EXYNOS4_GPL2(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//MD_RESETBB
+	{ EXYNOS4_GPL2(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//HUB_RESET
+	{ EXYNOS4_GPL2(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//NFC_SCL
+	{ EXYNOS4_GPL2(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_NONE},	//NFC_SDA
+	{ EXYNOS4_GPL2(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NFC_GPIO4
+	#ifdef CONFIG_TC4_EVT
+	{ EXYNOS4_GPL2(6),	S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//ANX7805_PWON
+	{ EXYNOS4_GPL2(7),	S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//TP
+	#endif
+
+	#ifdef CONFIG_TC4_DVT
+	//GPM4(2) --ISP_SCL1
+	//GPM4(3)--ISP_SDA1
+	//GPM3(5)--PMIC_DS2
+	//GPM3(6)--PMIC_DS3
+	//GPM3(7)--PMIC_DS4
+	#endif
+	
+
+#if 1
+	{ EXYNOS4_GPY0(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPY0(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+
+	{ EXYNOS4_GPY0(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY0(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY0(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY0(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+
+	{ EXYNOS4_GPY1(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY1(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY1(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY1(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+
+	{ EXYNOS4_GPY2(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY2(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY2(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY2(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY2(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY2(5),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+
+	{ EXYNOS4_GPY3(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+       { EXYNOS4_GPY3(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	//NC
+	{ EXYNOS4_GPY3(2),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* MHL_SCL_1.8V */
+	{ EXYNOS4_GPY3(3),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY3(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY3(5),  S3C_GPIO_SLP_INPUT,  S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY3(6),  S3C_GPIO_SLP_INPUT,  S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY3(7),  S3C_GPIO_SLP_INPUT,  S3C_GPIO_PULL_DOWN},
+
+	{ EXYNOS4_GPY4(0),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY4(1),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY4(2),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY4(3),  S3C_GPIO_SLP_INPUT,  S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY4(4),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY4(5),  S3C_GPIO_SLP_INPUT,  S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY4(6),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},
+	{ EXYNOS4_GPY4(7),  S3C_GPIO_SLP_INPUT,	S3C_GPIO_PULL_DOWN},
+
+	{ EXYNOS4_GPY5(0),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(1),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(2),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(3),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(4),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(5),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(6),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY5(7),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+
+	{ EXYNOS4_GPY6(0),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(1),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(2),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(3),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(4),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(5),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(6),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+	{ EXYNOS4_GPY6(7),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	/* NC */
+#endif 
+	{ EXYNOS4_GPZ(0),  S3C_GPIO_SLP_PREV,  S3C_GPIO_PULL_NONE},	//I2S0_SCLK
+	{ EXYNOS4_GPZ(1),  S3C_GPIO_SLP_PREV, S3C_GPIO_PULL_NONE},	//I2S0_CDCLK
+	{ EXYNOS4_GPZ(2),  S3C_GPIO_SLP_PREV,  S3C_GPIO_PULL_NONE}, //I2S0_LRCK
+	{ EXYNOS4_GPZ(3),  S3C_GPIO_SLP_PREV,  S3C_GPIO_PULL_NONE}, //I2S0_SDI
+	{ EXYNOS4_GPZ(4),  S3C_GPIO_SLP_PREV,  S3C_GPIO_PULL_NONE}, //I2S0_SDO0
+	{ EXYNOS4_GPZ(5),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN}, //WIFI_PWDN
+	{ EXYNOS4_GPZ(6),  S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN},	//BT_RST
+#endif
+};
+#ifdef CONFIG_TC4_DVT
+	//GPX0(0) ---NC
+	//GPX2(6) --6260_GPIO1
+	//GPX3(2) --6260_GPIO2
+#endif
+static unsigned int tc4_sleep_alive_gpio_table[][4] =
+{//ly 20111118 modified it for eint wakeup
+	{EXYNOS4_GPX0(0), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //ANX7805_INIT
+	{EXYNOS4_GPX0(1), S3C_GPIO_SLP_OUT1,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //ANX7805_PD
+	//{EXYNOS4_GPX0(2), S3C_GPIO_OUTPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //ONO
+	{EXYNOS4_GPX0(3), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//CABLE_DET
+	{EXYNOS4_GPX0(4), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//TP1_INT
+	{EXYNOS4_GPX0(5), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//PIX_SDA
+	{EXYNOS4_GPX0(6), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //PIX_SCL
+	//{EXYNOS4_GPX0(7), S3C_GPIO_SFN(0xf),	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //TF_CDN
+
+	{EXYNOS4_GPX1(0), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},  //CHG_FLT
+	{EXYNOS4_GPX1(1), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//NFC_INT
+	{EXYNOS4_GPX1(2), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//KP_LED
+	{EXYNOS4_GPX1(3), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //HOOK_DET
+	{EXYNOS4_GPX1(4), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//WIFI_WOW
+	//{EXYNOS4_GPX1(5), S3C_GPIO_SFN(0xf),	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//CHG_UOK
+	//{EXYNOS4_GPX1(6), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//MD_SLEEP_REQUEST
+	{EXYNOS4_GPX1(7), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //IRQ_PMIC
+
+
+	{EXYNOS4_GPX2(0), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//KP_ROW0
+	{EXYNOS4_GPX2(1), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//KP_ROW1
+	{EXYNOS4_GPX2(2), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//HP_DET
+	{EXYNOS4_GPX2(3), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//HUB_INIT_N
+	{EXYNOS4_GPX2(4), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //MD_B14
+	//{EXYNOS4_GPX2(5), S3C_GPIO_SFN(0xf),	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //MD_WAKEUP_AP
+	//{EXYNOS4_GPX2(6), S3C_GPIO_SFN(0xf),	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //CHG_DOK
+	{EXYNOS4_GPX2(7), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //CHG_COK
+
+	{EXYNOS4_GPX3(0), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//GM_INT1
+	{EXYNOS4_GPX3(1), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //GM_INI2
+	//{EXYNOS4_GPX3(2), S3C_GPIO_SFN(0xf),	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //FUEL_ALRT
+	{EXYNOS4_GPX3(3), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//GYRO_INT
+	{EXYNOS4_GPX3(4), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //COMPASS_RDY
+	{EXYNOS4_GPX3(5), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //MD_L15
+	{EXYNOS4_GPX3(6), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE}, //HDMI_CEC
+	{EXYNOS4_GPX3(7), S3C_GPIO_INPUT,	S3C_GPIO_SETPIN_NONE, S3C_GPIO_PULL_NONE},	//HDMI_HPD
+
+};
+
+
+//added by yulu
+static void tc4_config_sleep_gpio_table(void)
+{
+	int i,gpio;
+/*
+	[Fix Me] Below codes are sample GPIO initialization and review codes
+	for target platform if needed.
+*/
+#if 0
+	for (i = 0; i < ARRAY_SIZE(tc4_sleep_alive_gpio_table); i++)
+	  {
+		  gpio = tc4_sleep_alive_gpio_table[i][0];
+	
+		  s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(tc4_sleep_alive_gpio_table[i][1]));
+		  if (tc4_sleep_alive_gpio_table[i][2] != S3C_GPIO_SETPIN_NONE)
+		  {
+			  gpio_set_value(gpio, tc4_sleep_alive_gpio_table[i][2]);
+		  }
+		  s3c_gpio_setpull(gpio, tc4_sleep_alive_gpio_table[i][3]);
+	  }
+
+	
+#endif
+	config_sleep_gpio_table(ARRAY_SIZE(tc4_sleep_gpio_table),
+			tc4_sleep_gpio_table); ///yulu
+}
+
+#endif
+#define SMDK4412_REV_0_0_ADC_VALUE 0
+#define SMDK4412_REV_0_1_ADC_VALUE 443
+int samsung_board_rev;
+
+static int get_samsung_board_rev(void)
+{
+	int		ret = 0;
+#if 0 //It's only for smdk
+	int 		adc_val = 0;
+	struct clk	*adc_clk;
+	struct resource	*res;
+	void __iomem	*adc_regs;
+	unsigned int	con;
+	int		ret;
+
+	if ((soc_is_exynos4412() && samsung_rev() < EXYNOS4412_REV_1_0) ||
+		(soc_is_exynos4212() && samsung_rev() < EXYNOS4212_REV_1_0))
+		return SAMSUNG_BOARD_REV_0_0;
+
+	adc_clk = clk_get(NULL, "adc");
+	if (unlikely(IS_ERR(adc_clk)))
+		return SAMSUNG_BOARD_REV_0_0;
+
+	clk_enable(adc_clk);
+
+	res = platform_get_resource(&s3c_device_adc, IORESOURCE_MEM, 0);
+	if (unlikely(!res))
+		goto err_clk;
+
+	adc_regs = ioremap(res->start, resource_size(res));
+	if (unlikely(!adc_regs))
+		goto err_clk;
+
+	writel(S5PV210_ADCCON_SELMUX(3), adc_regs + S5PV210_ADCMUX);
+
+	con = readl(adc_regs + S3C2410_ADCCON);
+	con &= ~S3C2410_ADCCON_MUXMASK;
+	con &= ~S3C2410_ADCCON_STDBM;
+	con &= ~S3C2410_ADCCON_STARTMASK;
+	con |=  S3C2410_ADCCON_PRSCEN;
+
+	con |= S3C2410_ADCCON_ENABLE_START;
+	writel(con, adc_regs + S3C2410_ADCCON);
+
+	udelay (50);
+
+	adc_val = readl(adc_regs + S3C2410_ADCDAT0) & 0xFFF;
+	writel(0, adc_regs + S3C64XX_ADCCLRINT);
+
+	iounmap(adc_regs);
+err_clk:
+	clk_disable(adc_clk);
+	clk_put(adc_clk);
+
+	ret = (adc_val < SMDK4412_REV_0_1_ADC_VALUE/2) ?
+			SAMSUNG_BOARD_REV_0_0 : SAMSUNG_BOARD_REV_0_1;
+
+	pr_info ("SMDK MAIN Board Rev 0.%d (ADC value:%d)\n", ret, adc_val);
+#endif
+	return ret;
+}
+
+static void __init smdk4x12_machine_init(void)
+{
+#ifdef CONFIG_S3C64XX_DEV_SPI
+	unsigned int gpio;
+	struct clk *sclk = NULL;
+	struct clk *prnt = NULL;
+	struct device *spi0_dev = &exynos_device_spi0.dev;
+#ifndef CONFIG_FB_S5P_LMS501KF03
+	struct device *spi1_dev = &exynos_device_spi1.dev;
+#endif
+	struct device *spi2_dev = &exynos_device_spi2.dev;
+#endif
+	int err;
+	
+	pm_power_off = smdk4x12_power_off;
+	s3c_config_sleep_gpio_table = tc4_config_sleep_gpio_table;
+	samsung_board_rev = get_samsung_board_rev();
+
+#if defined(CONFIG_EXYNOS_DEV_PD) && defined(CONFIG_PM_RUNTIME)
+	exynos_pd_disable(&exynos4_device_pd[PD_MFC].dev);
+	exynos_pd_disable(&exynos4_device_pd[PD_G3D].dev);
+	exynos_pd_disable(&exynos4_device_pd[PD_LCD0].dev);
+	exynos_pd_disable(&exynos4_device_pd[PD_CAM].dev);
+	exynos_pd_disable(&exynos4_device_pd[PD_TV].dev);
+	exynos_pd_disable(&exynos4_device_pd[PD_GPS].dev);
+	exynos_pd_disable(&exynos4_device_pd[PD_GPS_ALIVE].dev);
+	exynos_pd_disable(&exynos4_device_pd[PD_ISP].dev);
+#elif defined(CONFIG_EXYNOS_DEV_PD)
+	/*
+	 * These power domains should be always on
+	 * without runtime pm support.
+	 */
+	exynos_pd_enable(&exynos4_device_pd[PD_MFC].dev);
+	exynos_pd_enable(&exynos4_device_pd[PD_G3D].dev);
+	exynos_pd_enable(&exynos4_device_pd[PD_LCD0].dev);
+	exynos_pd_enable(&exynos4_device_pd[PD_CAM].dev);
+	exynos_pd_enable(&exynos4_device_pd[PD_TV].dev);
+	exynos_pd_enable(&exynos4_device_pd[PD_GPS].dev);
+	exynos_pd_enable(&exynos4_device_pd[PD_GPS_ALIVE].dev);
+	exynos_pd_enable(&exynos4_device_pd[PD_ISP].dev);
+#endif
+	s3c_i2c0_set_platdata(NULL);
+	i2c_register_board_info(0, i2c_devs0, ARRAY_SIZE(i2c_devs0));
+
+	s3c_i2c1_set_platdata(NULL);
+	i2c_register_board_info(1, i2c_devs1, ARRAY_SIZE(i2c_devs1));
+
+	s3c_i2c2_set_platdata(NULL);
+	i2c_register_board_info(2, i2c_devs2, ARRAY_SIZE(i2c_devs2));
+
+	s3c_i2c3_set_platdata(NULL);
+	i2c_register_board_info(3, i2c_devs3, ARRAY_SIZE(i2c_devs3));
+
+	s3c_i2c4_set_platdata(NULL);
+	i2c_register_board_info(4, i2c_devs4, ARRAY_SIZE(i2c_devs4));
+	s3c_i2c5_set_platdata(NULL);
+	i2c_register_board_info(5, i2c_devs5, ARRAY_SIZE(i2c_devs5));
+
+	//For S5K4EC (using i2c6)
+	s3c_i2c6_set_platdata(NULL);
+	i2c_register_board_info(6, i2c_devs6, ARRAY_SIZE(i2c_devs6));
+
+	s3c_i2c7_set_platdata(NULL);
+	i2c_register_board_info(7, i2c_devs7, ARRAY_SIZE(i2c_devs7));
+
+#ifdef CONFIG_ANDROID_PMEM
+	android_pmem_set_platdata();
+#endif
+#if defined(CONFIG_FB_S5P_MIPI_DSIM)
+	mipi_fb_init();
+#endif
+#ifdef CONFIG_FB_S3C
+	dev_set_name(&s5p_device_fimd0.dev, "s3cfb.0");
+	clk_add_alias("lcd", "exynos4-fb.0", "lcd", &s5p_device_fimd0.dev);
+	clk_add_alias("sclk_fimd", "exynos4-fb.0", "sclk_fimd", &s5p_device_fimd0.dev);
+	s5p_fb_setname(0, "exynos4-fb");
+#if defined(CONFIG_LCD_AMS369FG06) || defined(CONFIG_LCD_LMS501KF03)
+	spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
+#endif
+	s5p_fimd0_set_platdata(&smdk4x12_lcd0_pdata);
+#ifdef CONFIG_FB_MIPI_DSIM
+	s5p_device_mipi_dsim.dev.parent = &exynos4_device_pd[PD_LCD0].dev;
+#endif
+#ifdef CONFIG_EXYNOS_DEV_PD
+	s5p_device_fimd0.dev.parent = &exynos4_device_pd[PD_LCD0].dev;
+#endif
+#endif
+#ifdef CONFIG_FB_S5P
+#ifdef CONFIG_FB_S5P_LMS501KF03
+	spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
+	s3cfb_set_platdata(&lms501kf03_data);
+#else
+	s3cfb_set_platdata(NULL);
+#endif
+#ifdef CONFIG_FB_S5P_MIPI_DSIM
+	s5p_device_dsim.dev.parent = &exynos4_device_pd[PD_LCD0].dev;
+#endif
+#ifdef CONFIG_EXYNOS_DEV_PD
+	s3c_device_fb.dev.parent = &exynos4_device_pd[PD_LCD0].dev;
+#endif
+#endif
+#ifdef CONFIG_USB_EHCI_S5P
+	smdk4x12_ehci_init();
+#endif
+#ifdef CONFIG_USB_OHCI_S5P
+	smdk4x12_ohci_init();
+#endif
+#ifdef CONFIG_USB_GADGET
+	smdk4x12_usbgadget_init();
+#endif
+#ifdef CONFIG_USB_EXYNOS_SWITCH
+	smdk4x12_usbswitch_init();
+#endif
+
+	samsung_bl_set(&smdk4x12_bl_gpio_info, &smdk4x12_bl_data);
+
+#ifdef CONFIG_EXYNOS4_DEV_DWMCI
+	exynos_dwmci_set_platdata(&exynos_dwmci_pdata);
+#endif
+
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_IS
+	exynos4_fimc_is_set_platdata(NULL);
+#ifdef CONFIG_EXYNOS_DEV_PD
+	exynos4_device_fimc_is.dev.parent = &exynos4_device_pd[PD_ISP].dev;
+#endif
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC
+	s3c_sdhci0_set_platdata(&smdk4x12_hsmmc0_pdata);
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC1
+	s3c_sdhci1_set_platdata(&smdk4x12_hsmmc1_pdata);
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC2
+	s3c_sdhci2_set_platdata(&smdk4x12_hsmmc2_pdata);
+#endif
+#ifdef CONFIG_S3C_DEV_HSMMC3
+	s3c_sdhci3_set_platdata(&smdk4x12_hsmmc3_pdata);
+#endif
+#ifdef CONFIG_S5P_DEV_MSHC
+	s3c_mshci_set_platdata(&exynos4_mshc_pdata);
+#endif
+#if defined(CONFIG_VIDEO_EXYNOS_TV) && defined(CONFIG_VIDEO_EXYNOS_HDMI)
+	dev_set_name(&s5p_device_hdmi.dev, "exynos4-hdmi");
+	clk_add_alias("hdmi", "s5p-hdmi", "hdmi", &s5p_device_hdmi.dev);
+	clk_add_alias("hdmiphy", "s5p-hdmi", "hdmiphy", &s5p_device_hdmi.dev);
+	s5p_tv_setup();
+
+	/* setup dependencies between TV devices */
+	s5p_device_hdmi.dev.parent = &exynos4_device_pd[PD_TV].dev;
+	s5p_device_mixer.dev.parent = &exynos4_device_pd[PD_TV].dev;
+
+	s5p_i2c_hdmiphy_set_platdata(NULL);
+#ifdef CONFIG_VIDEO_EXYNOS_HDMI_CEC
+	s5p_hdmi_cec_set_platdata(&hdmi_cec_data);
+#endif
+#endif
+#ifdef CONFIG_VIDEO_EXYNOS_FIMC_LITE
+	smdk4x12_set_camera_flite_platdata();
+	s3c_set_platdata(&exynos_flite0_default_data,
+			sizeof(exynos_flite0_default_data), &exynos_device_flite0);
+	s3c_set_platdata(&exynos_flite1_default_data,
+			sizeof(exynos_flite1_default_data), &exynos_device_flite1);
+#ifdef CONFIG_EXYNOS_DEV_PD
+	exynos_device_flite0.dev.parent = &exynos4_device_pd[PD_ISP].dev;
+	exynos_device_flite1.dev.parent = &exynos4_device_pd[PD_ISP].dev;
+#endif
+#endif
+#ifdef CONFIG_EXYNOS_SETUP_THERMAL
+	s5p_tmu_set_platdata(&exynos_tmu_data);
+#endif
+#ifdef CONFIG_VIDEO_FIMC
+	s3c_fimc0_set_platdata(&fimc_plat);
+#ifdef CONFIG_TC4_GB
+	s3c_fimc1_set_platdata(NULL);
+	s3c_fimc2_set_platdata(&fimc_plat);
+#else
+	s3c_fimc1_set_platdata(&fimc_plat);
+        s3c_fimc2_set_platdata(NULL);
+#endif
+	s3c_fimc3_set_platdata(NULL);
+#ifdef CONFIG_EXYNOS_DEV_PD
+	s3c_device_fimc0.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+	s3c_device_fimc1.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+	s3c_device_fimc2.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+	s3c_device_fimc3.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+#ifdef CONFIG_EXYNOS4_CONTENT_PATH_PROTECTION
+	secmem.parent = &exynos4_device_pd[PD_CAM].dev;
+#endif
+#endif
+#ifdef CONFIG_VIDEO_FIMC_MIPI
+	s3c_csis0_set_platdata(NULL);
+	s3c_csis1_set_platdata(NULL);
+#ifdef CONFIG_EXYNOS_DEV_PD
+	s3c_device_csis0.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+	s3c_device_csis1.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+#endif
+#endif
+
+#if defined(CONFIG_ITU_A) || defined(CONFIG_CSI_C) \
+	|| defined(CONFIG_S5K3H1_CSI_C) || defined(CONFIG_S5K3H2_CSI_C) \
+	|| defined(CONFIG_S5K6A3_CSI_C)
+	smdk4x12_cam0_reset(1);
+#endif
+#if defined(CONFIG_ITU_B) || defined(CONFIG_CSI_D) \
+	|| defined(CONFIG_S5K3H1_CSI_D) || defined(CONFIG_S5K3H2_CSI_D) \
+	|| defined(CONFIG_S5K6A3_CSI_D)
+	smdk4x12_cam1_reset(1);
+#endif
+#endif /* CONFIG_VIDEO_FIMC */
+
+#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+	smdk4x12_camera_config();
+	smdk4x12_subdev_config();
+
+	dev_set_name(&s5p_device_fimc0.dev, "s3c-fimc.0");
+	dev_set_name(&s5p_device_fimc1.dev, "s3c-fimc.1");
+	dev_set_name(&s5p_device_fimc2.dev, "s3c-fimc.2");
+	dev_set_name(&s5p_device_fimc3.dev, "s3c-fimc.3");
+
+	clk_add_alias("fimc", "exynos4210-fimc.0", "fimc", &s5p_device_fimc0.dev);
+	clk_add_alias("sclk_fimc", "exynos4210-fimc.0", "sclk_fimc",
+			&s5p_device_fimc0.dev);
+	clk_add_alias("fimc", "exynos4210-fimc.1", "fimc", &s5p_device_fimc1.dev);
+	clk_add_alias("sclk_fimc", "exynos4210-fimc.1", "sclk_fimc",
+			&s5p_device_fimc1.dev);
+	clk_add_alias("fimc", "exynos4210-fimc.2", "fimc", &s5p_device_fimc2.dev);
+	clk_add_alias("sclk_fimc", "exynos4210-fimc.2", "sclk_fimc",
+			&s5p_device_fimc2.dev);
+	clk_add_alias("fimc", "exynos4210-fimc.3", "fimc", &s5p_device_fimc3.dev);
+	clk_add_alias("sclk_fimc", "exynos4210-fimc.3", "sclk_fimc",
+			&s5p_device_fimc3.dev);
+
+	s3c_fimc_setname(0, "exynos4210-fimc");
+	s3c_fimc_setname(1, "exynos4210-fimc");
+	s3c_fimc_setname(2, "exynos4210-fimc");
+	s3c_fimc_setname(3, "exynos4210-fimc");
+	/* FIMC */
+	s3c_set_platdata(&s3c_fimc0_default_data,
+			 sizeof(s3c_fimc0_default_data), &s5p_device_fimc0);
+	s3c_set_platdata(&s3c_fimc1_default_data,
+			 sizeof(s3c_fimc1_default_data), &s5p_device_fimc1);
+	s3c_set_platdata(&s3c_fimc2_default_data,
+			 sizeof(s3c_fimc2_default_data), &s5p_device_fimc2);
+	s3c_set_platdata(&s3c_fimc3_default_data,
+			 sizeof(s3c_fimc3_default_data), &s5p_device_fimc3);
+#ifdef CONFIG_EXYNOS_DEV_PD
+	s5p_device_fimc0.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+	s5p_device_fimc1.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+	s5p_device_fimc2.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+	s5p_device_fimc3.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+#endif
+#ifdef CONFIG_VIDEO_S5P_MIPI_CSIS
+	dev_set_name(&s5p_device_mipi_csis0.dev, "s3c-csis.0");
+	dev_set_name(&s5p_device_mipi_csis1.dev, "s3c-csis.1");
+	clk_add_alias("csis", "s5p-mipi-csis.0", "csis",
+			&s5p_device_mipi_csis0.dev);
+	clk_add_alias("sclk_csis", "s5p-mipi-csis.0", "sclk_csis",
+			&s5p_device_mipi_csis0.dev);
+	clk_add_alias("csis", "s5p-mipi-csis.1", "csis",
+			&s5p_device_mipi_csis1.dev);
+	clk_add_alias("sclk_csis", "s5p-mipi-csis.1", "sclk_csis",
+			&s5p_device_mipi_csis1.dev);
+	dev_set_name(&s5p_device_mipi_csis0.dev, "s5p-mipi-csis.0");
+	dev_set_name(&s5p_device_mipi_csis1.dev, "s5p-mipi-csis.1");
+
+	s3c_set_platdata(&s5p_mipi_csis0_default_data,
+			sizeof(s5p_mipi_csis0_default_data), &s5p_device_mipi_csis0);
+	s3c_set_platdata(&s5p_mipi_csis1_default_data,
+			sizeof(s5p_mipi_csis1_default_data), &s5p_device_mipi_csis1);
+#ifdef CONFIG_EXYNOS_DEV_PD
+	s5p_device_mipi_csis0.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+	s5p_device_mipi_csis1.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+#endif
+#endif
+#if defined(CONFIG_ITU_A) || defined(CONFIG_CSI_C) \
+	|| defined(CONFIG_S5K3H1_CSI_C) || defined(CONFIG_S5K3H2_CSI_C) \
+	|| defined(CONFIG_S5K6A3_CSI_C)
+	smdk4x12_cam0_reset(1);
+#endif
+#if defined(CONFIG_ITU_B) || defined(CONFIG_CSI_D) \
+	|| defined(CONFIG_S5K3H1_CSI_D) || defined(CONFIG_S5K3H2_CSI_D) \
+	|| defined(CONFIG_S5K6A3_CSI_D)
+	smdk4x12_cam1_reset(1);
+#endif
+#endif
+
+#if defined(CONFIG_VIDEO_TVOUT)
+	s5p_hdmi_hpd_set_platdata(&hdmi_hpd_data);
+	s5p_hdmi_cec_set_platdata(&hdmi_cec_data);
+#ifdef CONFIG_EXYNOS_DEV_PD
+	s5p_device_tvout.dev.parent = &exynos4_device_pd[PD_TV].dev;
+	exynos4_device_pd[PD_TV].dev.parent= &exynos4_device_pd[PD_LCD0].dev;
+#endif
+#endif
+
+#if	defined(CONFIG_VIDEO_JPEG_V2X) || defined(CONFIG_VIDEO_JPEG)
+#ifdef CONFIG_EXYNOS_DEV_PD
+	s5p_device_jpeg.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+	exynos4_jpeg_setup_clock(&s5p_device_jpeg.dev, 160000000);
+#endif
+#endif
+
+#ifdef CONFIG_ION_EXYNOS
+	exynos_ion_set_platdata();
+#endif
+
+#if defined(CONFIG_VIDEO_MFC5X) || defined(CONFIG_VIDEO_SAMSUNG_S5P_MFC)
+#ifdef CONFIG_EXYNOS_DEV_PD
+	s5p_device_mfc.dev.parent = &exynos4_device_pd[PD_MFC].dev;
+#endif
+	if (soc_is_exynos4412() && samsung_rev() >= EXYNOS4412_REV_1_0)
+		exynos4_mfc_setup_clock(&s5p_device_mfc.dev, 200 * MHZ);
+	else
+		exynos4_mfc_setup_clock(&s5p_device_mfc.dev, 267 * MHZ);
+#endif
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_MFC)
+	dev_set_name(&s5p_device_mfc.dev, "s3c-mfc");
+	clk_add_alias("mfc", "s5p-mfc", "mfc", &s5p_device_mfc.dev);
+	s5p_mfc_setname(&s5p_device_mfc, "s5p-mfc");
+#endif
+
+#ifdef CONFIG_VIDEO_FIMG2D
+	s5p_fimg2d_set_platdata(&fimg2d_data);
+#endif
+	samsung_keypad_set_platdata(&smdk4x12_keypad_data);
+	//smdk4x12_smsc911x_init();
+#ifdef CONFIG_EXYNOS_C2C
+	exynos_c2c_set_platdata(&smdk4x12_c2c_pdata);
+#endif
+#ifndef CONFIG_TC4_GB
+	exynos_sysmmu_init();
+#endif
+	smdk4x12_gpio_power_init();
+
+	platform_add_devices(smdk4x12_devices, ARRAY_SIZE(smdk4x12_devices));
+	if (soc_is_exynos4412())
+		platform_add_devices(smdk4412_devices, ARRAY_SIZE(smdk4412_devices));
+
+#ifdef CONFIG_FB_S3C
+	exynos4_fimd0_setup_clock(&s5p_device_fimd0.dev, "mout_mpll_user",
+				800 * MHZ);
+#endif
+#ifdef CONFIG_S3C64XX_DEV_SPI
+	sclk = clk_get(spi0_dev, "dout_spi0");
+	if (IS_ERR(sclk))
+		dev_err(spi0_dev, "failed to get sclk for SPI-0\n");
+	prnt = clk_get(spi0_dev, "mout_mpll_user");
+	if (IS_ERR(prnt))
+		dev_err(spi0_dev, "failed to get prnt\n");
+	if (clk_set_parent(sclk, prnt))
+		printk(KERN_ERR "Unable to set parent %s of clock %s.\n",
+				prnt->name, sclk->name);
+
+	clk_set_rate(sclk, 800 * 1000 * 1000);
+	clk_put(sclk);
+	clk_put(prnt);
+
+	if (!gpio_request(EXYNOS4_GPB(1), "SPI_CS0")) {
+		gpio_direction_output(EXYNOS4_GPB(1), 1);
+		s3c_gpio_cfgpin(EXYNOS4_GPB(1), S3C_GPIO_SFN(1));
+		s3c_gpio_setpull(EXYNOS4_GPB(1), S3C_GPIO_PULL_UP);
+		exynos_spi_set_info(0, EXYNOS_SPI_SRCCLK_SCLK,
+			ARRAY_SIZE(spi0_csi));
+	}
+
+	for (gpio = EXYNOS4_GPB(0); gpio < EXYNOS4_GPB(4); gpio++)
+		s5p_gpio_set_drvstr(gpio, S5P_GPIO_DRVSTR_LV3);
+
+	spi_register_board_info(spi0_board_info, ARRAY_SIZE(spi0_board_info));
+
+#ifndef CONFIG_FB_S5P_LMS501KF03
+	sclk = clk_get(spi1_dev, "dout_spi1");
+	if (IS_ERR(sclk))
+		dev_err(spi1_dev, "failed to get sclk for SPI-1\n");
+	prnt = clk_get(spi1_dev, "mout_mpll_user");
+	if (IS_ERR(prnt))
+		dev_err(spi1_dev, "failed to get prnt\n");
+	if (clk_set_parent(sclk, prnt))
+		printk(KERN_ERR "Unable to set parent %s of clock %s.\n",
+				prnt->name, sclk->name);
+
+	clk_set_rate(sclk, 800 * 1000 * 1000);
+	clk_put(sclk);
+	clk_put(prnt);
+
+	if (!gpio_request(EXYNOS4_GPB(5), "SPI_CS1")) {
+		gpio_direction_output(EXYNOS4_GPB(5), 1);
+		s3c_gpio_cfgpin(EXYNOS4_GPB(5), S3C_GPIO_SFN(1));
+		s3c_gpio_setpull(EXYNOS4_GPB(5), S3C_GPIO_PULL_UP);
+		exynos_spi_set_info(1, EXYNOS_SPI_SRCCLK_SCLK,
+			ARRAY_SIZE(spi1_csi));
+	}
+
+	for (gpio = EXYNOS4_GPB(4); gpio < EXYNOS4_GPB(8); gpio++)
+		s5p_gpio_set_drvstr(gpio, S5P_GPIO_DRVSTR_LV3);
+
+	spi_register_board_info(spi1_board_info, ARRAY_SIZE(spi1_board_info));
+#endif
+
+	sclk = clk_get(spi2_dev, "dout_spi2");
+	if (IS_ERR(sclk))
+		dev_err(spi2_dev, "failed to get sclk for SPI-2\n");
+	prnt = clk_get(spi2_dev, "mout_mpll_user");
+	if (IS_ERR(prnt))
+		dev_err(spi2_dev, "failed to get prnt\n");
+	if (clk_set_parent(sclk, prnt))
+		printk(KERN_ERR "Unable to set parent %s of clock %s.\n",
+				prnt->name, sclk->name);
+
+	clk_set_rate(sclk, 800 * 1000 * 1000);
+	clk_put(sclk);
+	clk_put(prnt);
+
+	if (!gpio_request(EXYNOS4_GPC1(2), "SPI_CS2")) {
+		gpio_direction_output(EXYNOS4_GPC1(2), 1);
+		s3c_gpio_cfgpin(EXYNOS4_GPC1(2), S3C_GPIO_SFN(1));
+		s3c_gpio_setpull(EXYNOS4_GPC1(2), S3C_GPIO_PULL_UP);
+		exynos_spi_set_info(2, EXYNOS_SPI_SRCCLK_SCLK,
+			ARRAY_SIZE(spi2_csi));
+	}
+
+	for (gpio = EXYNOS4_GPC1(1); gpio < EXYNOS4_GPC1(5); gpio++)
+		s5p_gpio_set_drvstr(gpio, S5P_GPIO_DRVSTR_LV3);
+
+	spi_register_board_info(spi2_board_info, ARRAY_SIZE(spi2_board_info));
+#endif
+#ifdef CONFIG_BUSFREQ_OPP
+	dev_add(&busfreq, &exynos4_busfreq.dev);
+	ppmu_init(&exynos_ppmu[PPMU_DMC0], &exynos4_busfreq.dev);
+	ppmu_init(&exynos_ppmu[PPMU_DMC1], &exynos4_busfreq.dev);
+	ppmu_init(&exynos_ppmu[PPMU_CPU], &exynos4_busfreq.dev);
+#endif
+	register_reboot_notifier(&exynos4_reboot_notifier);
+}
+
+#ifdef CONFIG_EXYNOS_C2C
+static void __init exynos_c2c_reserve(void)
+{
+	static struct cma_region region = {
+			.name = "c2c_shdmem",
+			.size = 64 * SZ_1M,
+			{ .alignment	= 64 * SZ_1M },
+			.start = C2C_SHAREDMEM_BASE
+	};
+
+	BUG_ON(cma_early_region_register(&region));
+	BUG_ON(cma_early_region_reserve(&region));
+}
+#endif
+#ifdef CONFIG_TC4_GB
+MACHINE_START(SMDK4212, "SMDK4212")
+	.boot_params	= S5P_PA_SDRAM + 0x100,
+	.init_irq	= exynos4_init_irq,
+	.map_io		= smdk4x12_map_io,
+	.init_machine	= smdk4x12_machine_init,
+	.timer		= &exynos4_timer,
+	#if defined(CONFIG_KERNEL_PANIC_DUMP)		//mj for panic-dump
+	.reserve		= reserve_panic_dump_area,
+	#endif
+
+#ifdef CONFIG_EXYNOS_C2C
+	.reserve	= &exynos_c2c_reserve,
+#endif
+MACHINE_END
+
+MACHINE_START(SMDK4412, "SMDK4212")
+	.boot_params	= S5P_PA_SDRAM + 0x100,
+	.init_irq	= exynos4_init_irq,
+	.map_io		= smdk4x12_map_io,
+	.init_machine	= smdk4x12_machine_init,
+	.timer		= &exynos4_timer,
+
+	#if defined(CONFIG_KERNEL_PANIC_DUMP)		//mj for panic-dump
+	.reserve		= reserve_panic_dump_area,
+	#endif
+
+#ifdef CONFIG_EXYNOS_C2C
+	.reserve	= &exynos_c2c_reserve,
+#endif
+MACHINE_END
+#endif
+
+#ifdef CONFIG_TC4_ICS
+MACHINE_START(SMDK4212, "SMDK4X12")
+	.boot_params	= S5P_PA_SDRAM + 0x100,
+	.init_irq	= exynos4_init_irq,
+	.map_io		= smdk4x12_map_io,
+	.init_machine	= smdk4x12_machine_init,
+	.timer		= &exynos4_timer,
+	#if defined(CONFIG_KERNEL_PANIC_DUMP)		//mj for panic-dump
+	.reserve		= reserve_panic_dump_area,
+	#endif
+
+#ifdef CONFIG_EXYNOS_C2C
+	.reserve	= &exynos_c2c_reserve,
+#endif
+MACHINE_END
+
+MACHINE_START(SMDK4412, "SMDK4X12")
+	.boot_params	= S5P_PA_SDRAM + 0x100,
+	.init_irq	= exynos4_init_irq,
+	.map_io		= smdk4x12_map_io,
+	.init_machine	= smdk4x12_machine_init,
+	.timer		= &exynos4_timer,
+
+	#if defined(CONFIG_KERNEL_PANIC_DUMP)		//mj for panic-dump
+	.reserve		= reserve_panic_dump_area,
+	#endif
+
+#ifdef CONFIG_EXYNOS_C2C
+	.reserve	= &exynos_c2c_reserve,
+#endif
+MACHINE_END
+#endif
+
+
diff -ruNa TC4_Kernel_3.0/arch/arm/mach-exynos/Makefile modem/arch/arm/mach-exynos/Makefile
--- TC4_Kernel_3.0/arch/arm/mach-exynos/Makefile	2012-05-29 09:32:09.000000000 +0800
+++ modem/arch/arm/mach-exynos/Makefile	2012-07-04 15:30:18.000000000 +0800
@@ -53,7 +53,7 @@
 obj-$(CONFIG_MACH_SMDKV310)		+= mach-smdkv310.o
 obj-$(CONFIG_MACH_ARMLEX4210)		+= mach-armlex4210.o
 obj-$(CONFIG_MACH_UNIVERSAL_C210)	+= mach-universal_c210.o
-obj-$(CONFIG_XMM6260_MODEM)	+= setup-modem.o
+obj-$(CONFIG_SMM6260_MODEM)	+= setup-modem.o
 obj-$(CONFIG_MACH_NURI)			+= mach-nuri.o
 obj-$(CONFIG_MACH_SMDK4X12)		+= mach-smdk4x12.o
 obj-$(CONFIG_MACH_SMDK5210)		+= mach-smdk5210.o
diff -ruNa TC4_Kernel_3.0/arch/arm/mach-exynos/setup-modem.c modem/arch/arm/mach-exynos/setup-modem.c
--- TC4_Kernel_3.0/arch/arm/mach-exynos/setup-modem.c	1970-01-01 08:00:00.000000000 +0800
+++ modem/arch/arm/mach-exynos/setup-modem.c	2012-07-04 15:30:18.000000000 +0800
@@ -0,0 +1,284 @@
+#include <linux/gpio.h>
+#include <plat/gpio-cfg.h>
+#include <plat/devs.h>
+#include <mach/regs-gpio.h>
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/regulator/consumer.h>
+#include <linux/modemctl.h>
+
+#ifdef CONFIG_HAS_WAKELOCK
+#include <linux/wakelock.h>
+#endif
+#include <mach/modem.h>
+
+extern void usb_host_phy_init(void);
+extern void usb_host_phy_off(void);
+extern void usb_host_phy_suspend(void);
+extern int usb_host_phy_resume(void);
+
+int smm6260_is_on(void)
+{
+	return gpio_get_value(GPIO_PHONE_ON);
+}
+EXPORT_SYMBOL_GPL(smm6260_is_on);
+
+int smm6260_set_active_state(int val)
+{
+	int err;
+	
+	err = gpio_request(GPIO_ACTIVE_STATE, "ACTIVE_STATE");
+	if (err) {
+		printk(KERN_ERR "fail to request gpio %s\n", "ACTIVE_STATE");
+	} else {
+		gpio_direction_output(GPIO_ACTIVE_STATE, val ? 1 : 0);
+		s3c_gpio_setpull(GPIO_ACTIVE_STATE, S3C_GPIO_PULL_NONE);
+		gpio_set_value(GPIO_ACTIVE_STATE, val ? 1 : 0);
+		gpio_free(GPIO_ACTIVE_STATE);
+	}
+	
+	printk("%s: AP>>CP:   ACTIVE_STATE:%d,%d\n", __func__, val ? 1 : 0, gpio_get_value(GPIO_ACTIVE_STATE));
+	return 0;
+}
+EXPORT_SYMBOL_GPL(smm6260_set_active_state);
+
+int smm6260_set_slave_wakeup(int val)
+{
+	int err;
+	
+	err = gpio_request(GPIO_IPC_SLAVE_WAKEUP, "IPC_SLAVE_WAKEUP");
+	if (err) {
+		printk(KERN_ERR "fail to request gpio %s\n", "IPC_SLAVE_WAKEUP");
+	} else {
+		gpio_direction_output(GPIO_IPC_SLAVE_WAKEUP, val ? 1 : 0);
+		s3c_gpio_setpull(GPIO_IPC_SLAVE_WAKEUP, S3C_GPIO_PULL_NONE);
+		gpio_set_value(GPIO_IPC_SLAVE_WAKEUP, val ? 1 : 0);
+		gpio_free(GPIO_IPC_SLAVE_WAKEUP);
+	}
+
+	printk("%s: AP>>CP:   SLAV_WUP:%d,%d\n", __func__, val ? 1 : 0,	gpio_get_value(GPIO_IPC_SLAVE_WAKEUP));
+	return 0;
+}
+EXPORT_SYMBOL_GPL(smm6260_set_slave_wakeup);
+
+int smm6260_is_host_wakeup(void)
+{
+	return ((gpio_get_value(GPIO_IPC_HOST_WAKEUP)) ==HOST_WUP_LEVEL)? 1 : 0;
+}
+EXPORT_SYMBOL_GPL(smm6260_is_host_wakeup);
+
+
+void smm6260_cfg(void)
+{
+	static int smm6260_initialed=0;
+	int err = 0;
+
+        if(smm6260_initialed)
+		return;
+	/*TODO: check uart init func AP FLM BOOT RX -- */
+      
+	err = gpio_request(GPIO_CP_PMU_RST, "CP_PMU_RST");
+	if (err) {
+		printk(KERN_ERR "fail to request gpio %s\n", "CP_PMU_RST");
+	} else {
+		gpio_direction_output(GPIO_CP_PMU_RST, 0);
+		s3c_gpio_setpull(GPIO_CP_PMU_RST, S3C_GPIO_PULL_NONE);
+		gpio_free(GPIO_CP_PMU_RST);
+	}
+	
+	err = gpio_request(GPIO_PHONE_ON, "PHONE_ON");
+	if (err) {
+		printk(KERN_ERR "fail to request gpio %s\n", "PHONE_ON");
+	} else {
+		gpio_direction_output(GPIO_PHONE_ON, 0);
+		s3c_gpio_setpull(GPIO_PHONE_ON, S3C_GPIO_PULL_NONE);
+		gpio_free(GPIO_PHONE_ON);
+	}
+	
+	err = gpio_request(GPIO_CP_RST, "CP_RST");
+	if (err) {
+		printk(KERN_ERR "fail to request gpio %s\n", "CP_RST");
+	} else {
+		gpio_direction_output(GPIO_CP_RST, 0);
+		s3c_gpio_setpull(GPIO_CP_RST, S3C_GPIO_PULL_NONE);
+		gpio_free(GPIO_CP_RST);
+	}
+
+	err = gpio_request(GPIO_IPC_SLAVE_WAKEUP, "IPC_SLAVE_WAKEUP");
+	if (err) {
+		printk(KERN_ERR "fail to request gpio %s\n",
+			"IPC_SLAVE_WAKEUP");
+	} else {
+		gpio_direction_output(GPIO_IPC_SLAVE_WAKEUP, 0);
+		s3c_gpio_setpull(GPIO_IPC_SLAVE_WAKEUP, S3C_GPIO_PULL_NONE);
+		gpio_free(GPIO_IPC_SLAVE_WAKEUP);
+	}
+
+	err = gpio_request(GPIO_IPC_HOST_WAKEUP, "IPC_HOST_WAKEUP");
+	if (err) {
+		printk(KERN_ERR "fail to request gpio %s\n", "IPC_HOST_WAKEUP");
+	} else {
+		gpio_direction_output(GPIO_IPC_HOST_WAKEUP, 0);
+		s3c_gpio_cfgpin(GPIO_IPC_HOST_WAKEUP, S3C_GPIO_INPUT);
+		s3c_gpio_setpull(GPIO_IPC_HOST_WAKEUP, S3C_GPIO_PULL_NONE);
+		gpio_free(GPIO_IPC_HOST_WAKEUP);
+	}
+	
+	err = gpio_request(GPIO_SUSPEND_REQUEST, "IPC_SUSPEND_REQUEST");
+	if (err) {
+		printk(KERN_ERR "fail to request gpio %s\n", "IPC_SUSPEND_REQUEST");
+	} else {
+		gpio_direction_output(GPIO_SUSPEND_REQUEST, 0);
+		s3c_gpio_cfgpin(GPIO_SUSPEND_REQUEST, S3C_GPIO_INPUT);
+		s3c_gpio_setpull(GPIO_SUSPEND_REQUEST, S3C_GPIO_PULL_NONE);
+		gpio_free(GPIO_SUSPEND_REQUEST);
+	}	
+	
+	err = gpio_request(GPIO_ACTIVE_STATE, "ACTIVE_STATE");
+	if (err) {
+		printk(KERN_ERR "fail to request gpio %s\n", "ACTIVE_STATE");
+	} else {
+		gpio_direction_output(GPIO_ACTIVE_STATE, 0);
+		s3c_gpio_setpull(GPIO_ACTIVE_STATE, S3C_GPIO_PULL_NONE);
+		gpio_free(GPIO_ACTIVE_STATE);
+	}
+
+	err = gpio_request(GPIO_CP_RESET_REPORT, "CP_RESET_REPORT");
+	if (err) {
+		printk(KERN_ERR "fail to request gpio %s\n", "CP_RESET_REPORT");
+	} else {
+		gpio_direction_output(GPIO_CP_RESET_REPORT, 0);
+		s3c_gpio_cfgpin(GPIO_CP_RESET_REPORT, S3C_GPIO_INPUT);
+		s3c_gpio_setpull(GPIO_CP_RESET_REPORT, S3C_GPIO_PULL_NONE);
+		gpio_free(GPIO_CP_RESET_REPORT);
+	}	
+
+	err = gpio_request(GPIO_XUJIE_MONITOR, "XUJIE_MONITOR");
+	if (err) {
+		printk(KERN_ERR "fail to request gpio %s\n", "XUJIE_MONITOR");
+	} else {
+		gpio_direction_output(GPIO_XUJIE_MONITOR, 0);
+		s3c_gpio_setpull(GPIO_XUJIE_MONITOR, S3C_GPIO_PULL_NONE);
+		gpio_free(GPIO_XUJIE_MONITOR);
+	}	
+
+	smm6260_initialed = 1;
+	printk("\n---%s(): finish\n",__FUNCTION__);
+}
+static void smm6260_vcc_init(void)
+{
+
+}
+
+static void smm6260_vcc_off(void)
+{
+
+}
+
+extern struct modemctl *global_mc;
+
+static void smm6260_on(void)
+{
+	int count =1000;
+	printk("%s: start\n", __func__);
+	
+	smm6260_vcc_init();
+
+	if(global_mc->gModemPowerState==1){
+		printk("---not the first time modem power on\n");
+
+		gpio_set_value(GPIO_CP_RST, 0);
+		msleep(100);
+		gpio_set_value(GPIO_CP_RST, 1);
+		mdelay(1);
+		gpio_set_value(GPIO_CP_PMU_RST, 1);
+		mdelay(2);
+		gpio_set_value(GPIO_PHONE_ON, 1);
+		//udelay(60);
+		//gpio_set_value(GPIO_PHONE_ON, 0);
+		}
+	else{
+		global_mc->gModemPowerState=1;
+		
+		gpio_set_value(GPIO_CP_PMU_RST, 0);
+		gpio_set_value(GPIO_PHONE_ON, 0);
+		msleep(100);
+		
+		gpio_set_value(GPIO_CP_RST, 0);
+		msleep(100);
+		gpio_set_value(GPIO_CP_RST, 1);
+		mdelay(1);
+		gpio_set_value(GPIO_CP_PMU_RST, 1);
+		mdelay(2);
+		gpio_set_value(GPIO_PHONE_ON, 1);
+		udelay(60);
+		//gpio_set_value(GPIO_PHONE_ON, 0);
+		printk("---the first time modem power on\n");
+		}
+//from intel Khai
+	printk("\n\n---%s(): finish\n", __FUNCTION__);
+}
+
+static void smm6260_off(void)
+{
+	printk("%s\n", __func__);
+	gpio_set_value(GPIO_CP_RST, 0);
+	gpio_set_value(GPIO_CP_PMU_RST, 0);
+	gpio_set_value(GPIO_PHONE_ON, 0);
+	msleep(2000);
+	//gpio_set_value(GPIO_PHONE_ON, 1);
+	//msleep(1500);
+
+}
+extern void do_modem_reset();
+
+ void smm6260_reset(void)
+{
+	printk("%s\n", __func__);
+	
+	do_modem_reset(); 
+}
+
+/* move the PDA_ACTIVE Pin control to sleep_gpio_table */
+static void smm6260_suspend(void)
+{
+	smm6260_vcc_off();
+}
+
+static void smm6260_resume(void)
+{
+	smm6260_vcc_init();
+}
+
+static struct modem_platform_data smm6260_data = {
+	.name = "smm6260",
+	.gpio_phone_on = GPIO_PHONE_ON,
+	.gpio_cp_reset = GPIO_CP_RST,
+	.gpio_ipc_slave_wakeup = GPIO_IPC_SLAVE_WAKEUP,
+	.gpio_ipc_host_wakeup = GPIO_IPC_HOST_WAKEUP,
+	.gpio_suspend_request = GPIO_SUSPEND_REQUEST,
+	.gpio_active_state = GPIO_ACTIVE_STATE,
+	.gpio_cp_reset_int = GPIO_CP_RESET_REPORT,
+	.ops = {
+		.modem_on = smm6260_on,
+		.modem_off = smm6260_off,
+		.modem_reset = smm6260_reset,
+		.modem_suspend = smm6260_suspend,
+		.modem_resume = smm6260_resume,
+		.modem_cfg = smm6260_cfg,
+	}
+};
+
+struct platform_device smm6260_modem = {
+	.name = "smm_modem",
+	.id = -1,
+
+	.dev = {
+		.platform_data = &smm6260_data,
+	},
+};
+EXPORT_SYMBOL(smm6260_modem);
+
diff -ruNa TC4_Kernel_3.0/arch/arm/mach-exynos/setup-usb-phy.c modem/arch/arm/mach-exynos/setup-usb-phy.c
--- TC4_Kernel_3.0/arch/arm/mach-exynos/setup-usb-phy.c	2012-05-15 15:08:08.000000000 +0800
+++ modem/arch/arm/mach-exynos/setup-usb-phy.c	2012-07-04 15:30:18.000000000 +0800
@@ -23,6 +23,8 @@
 #include <plat/regs-usb3-exynos-drd-phy.h>
 #ifdef CONFIG_SMM6260_MODEM
 #include <mach/modem.h>
+#include <linux/modemctl.h>
+
 #endif
 #define ETC6PUD		(S5P_VA_GPIO2 + 0x228)
 #define EXYNOS4_USB_CFG		(S3C_VA_SYS + 0x21C)
@@ -481,6 +483,7 @@
 
 #ifdef CONFIG_USB_EHCI_S5P
 extern void usb_hub_gpio_init();
+extern struct modemctl *global_mc;
 #endif
 static int exynos4_usb_phy1_init(struct platform_device *pdev)
 {
@@ -489,12 +492,34 @@
 	u32 phyclk;
 	u32 rstcon;
 	int err;
+	struct completion done;
+#ifdef CONFIG_USB_EHCI_S5P
+	struct modemctl *mc =  global_mc;
+#endif
+
 printk("\n\n [usb_host_phy_init]++++++++++++++\n");
+printk("[XJ] cp -> ap wakeup host: %d\n",smm6260_is_host_wakeup());
 	
+#ifdef CONFIG_USB_EHCI_S5P	
 #ifdef CONFIG_SMM6260_MODEM
+
 		if (!smm6260_is_host_wakeup()) {
 			smm6260_set_slave_wakeup(1);
 		}
+		
+		if((mc != NULL)&&(mc->in_l3_state == 1)){
+			init_completion(&done);
+			mc->l3_done = &done;
+	//		mc->transfer_flag=1;
+			printk("---wait for wakeup go low no more than 0.5s\n");   //xujie temp
+			if (!wait_for_completion_timeout(&done, 2*HZ)) {
+				printk("completion wait timeout\n");
+			}
+
+		}
+
+
+#endif
 #endif
 
 	otg_clk = clk_get(&pdev->dev, "usbotg");
@@ -589,7 +614,7 @@
 
 	clk_disable(otg_clk);
 	clk_put(otg_clk);
-
+	//exynos_usb_mux_change(pdev, 0);//wjp for device function
 	return 0;
 }
 
@@ -892,6 +917,7 @@
 
 int s5p_usb_phy_suspend(struct platform_device *pdev, int type)
 {
+	//msleep(10);
 	if (type == S5P_USB_PHY_HOST)
 		return exynos4_usb_phy1_suspend(pdev);
 
diff -ruNa TC4_Kernel_3.0/arch/arm/plat-samsung/pm.c modem/arch/arm/plat-samsung/pm.c
--- TC4_Kernel_3.0/arch/arm/plat-samsung/pm.c	2012-05-15 15:08:07.000000000 +0800
+++ modem/arch/arm/plat-samsung/pm.c	2012-07-04 15:30:18.000000000 +0800
@@ -30,6 +30,9 @@
 
 #include <plat/pm.h>
 #include <mach/pm-core.h>
+#include <plat/gpio-cfg.h>
+#include <mach/regs-gpio.h>
+#include <mach/gpio.h>
 
 /* for external use */
 
@@ -321,6 +324,8 @@
 	}
 
 	/* save all necessary core registers not covered by the drivers */
+        gpio_set_value(EXYNOS4_GPX0(1), 0);
+        s3c_gpio_cfgpin(EXYNOS4_GPX0(1), S3C_GPIO_SFN(1));
 
 	s3c_pm_save_gpios();
 	s3c_pm_saved_gpios();
@@ -339,6 +344,22 @@
 
 	s3c_pm_arch_prepare_irqs();
 
+	
+	printk("****************************************************************\n");
+		printk("BEFORE SLEEP: WAKEUP_STAT: 0x%x\n", __raw_readl(S5P_WAKEUP_STAT));
+		printk("BEFORE SLEEP:  ICCICR_CPU0: 0x%x\n", __raw_readl(S5P_VA_GIC_CPU+0));
+		printk("BEFORE SLEEP:  0x%x\n", __raw_readl(S5P_VA_GIC_CPU+4));
+		printk("BEFORE SLEEP:  0x%x\n", __raw_readl(S5P_VA_GIC_CPU+8));
+		printk("BEFORE SLEEP:  0x%x\n", __raw_readl(S5P_VA_GIC_CPU+0xc));
+		printk("BEFORE SLEEP:  0x%x\n", __raw_readl(S5P_VA_GIC_CPU+0x10));
+		printk("BEFORE SLEEP:  0x%x\n", __raw_readl(S5P_VA_GIC_CPU+0x14));
+		printk("BEFORE SLEEP:  0x%x\n", __raw_readl(S5P_VA_GIC_CPU+0x18));
+		printk("BEFORE SLEEP:  0x%x\n", __raw_readl(S5P_VA_GIC_CPU+0x1c));
+		printk("BEFORE SLEEP:  0x%x\n", __raw_readl(S5P_VA_GIC_CPU+0x40));
+		printk("BEFORE SLEEP:  0x%x\n", __raw_readl(S5P_VA_GIC_CPU+0x44));
+		printk("BEFORE SLEEP:  0x%x\n", __raw_readl(S5P_VA_GIC_CPU+0xFC));
+		printk("****************************************************************\n");
+
 	/* call cpu specific preparation */
 
 	pm_cpu_prep();
@@ -362,7 +383,8 @@
 	/* restore the cpu state using the kernel's cpu init code. */
 
 	cpu_init();
-
+        gpio_set_value(EXYNOS4_GPX0(1), 0);
+        s3c_gpio_cfgpin(EXYNOS4_GPX0(1), S3C_GPIO_SFN(1));
 	s3c_pm_restore_core();
 	s3c_pm_restore_uarts();
 	s3c_pm_restore_gpios();
diff -ruNa TC4_Kernel_3.0/drivers/Kconfig modem/drivers/Kconfig
--- TC4_Kernel_3.0/drivers/Kconfig	2012-05-15 15:08:19.000000000 +0800
+++ modem/drivers/Kconfig	2012-07-04 15:30:18.000000000 +0800
@@ -128,4 +128,6 @@
 
 source "drivers/clocksource/Kconfig"
 
+source "drivers/smm6260_phone/Kconfig"
+
 endmenu
diff -ruNa TC4_Kernel_3.0/drivers/Makefile modem/drivers/Makefile
--- TC4_Kernel_3.0/drivers/Makefile	2012-05-15 15:08:23.000000000 +0800
+++ modem/drivers/Makefile	2012-07-04 15:30:18.000000000 +0800
@@ -121,4 +121,5 @@
 obj-y				+= ieee802154/
 #common clk code
 obj-y				+= clk/
+obj-y				+= smm6260_phone/
 obj-$(CONFIG_HWSPINLOCK)	+= hwspinlock/
diff -ruNa TC4_Kernel_3.0/drivers/media/video/samsung/tvout/s5p_tvout.c modem/drivers/media/video/samsung/tvout/s5p_tvout.c
--- TC4_Kernel_3.0/drivers/media/video/samsung/tvout/s5p_tvout.c	2012-05-21 18:57:08.000000000 +0800
+++ modem/drivers/media/video/samsung/tvout/s5p_tvout.c	2012-07-04 15:30:18.000000000 +0800
@@ -153,14 +153,14 @@
 		printk("%s: failed to get %s\n", __func__, "vdd18_mipi");
 		goto err_regulator;
 	}
-	regulator_enable(tv_regulator_vdd18); 	
+	//regulator_enable(tv_regulator_vdd18); 	
 
 	tv_regulator_vdd10 = regulator_get(NULL, "vdd10_mipi");  
 	if (IS_ERR(tv_regulator_vdd10)) {
 		printk("%s: failed to get %s\n", __func__, "vdd10_mipi");
 		goto err_regulator;
 	}
-	regulator_enable(tv_regulator_vdd10); 	
+	//regulator_enable(tv_regulator_vdd10); 	
 #endif
 
 	if (s5p_tvout_clk_get(pdev, &s5ptv_status) < 0)
diff -ruNa TC4_Kernel_3.0/drivers/misc/c2c/samsung-c2c.c modem/drivers/misc/c2c/samsung-c2c.c
--- TC4_Kernel_3.0/drivers/misc/c2c/samsung-c2c.c	2012-05-15 15:08:26.000000000 +0800
+++ modem/drivers/misc/c2c/samsung-c2c.c	2012-07-04 15:30:18.000000000 +0800
@@ -33,6 +33,7 @@
 #include <asm/pgtable.h>
 #endif
 #include <asm/mach-types.h>
+#include <linux/mm.h>
 
 #include <mach/c2c.h>
 #include <mach/regs-c2c.h>
@@ -40,10 +41,31 @@
 #include <mach/regs-pmu5.h>
 #include <mach/pmu.h>
 #include <plat/cpu.h>
-
+#include <mach/gpio.h>
+#include <plat/gpio-cfg.h>
 #include "samsung-c2c.h"
 
+#define DEBUG_PORT 1
+#define XMM6262_WRITE_NVM
+
+#ifdef XMM6262_WRITE_NVM
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/wakelock.h>
+#define XMM6262_FW "/data/xmm6262_fw.bin"
+#define FILE_NVM_STATIC "/data/nvm_static.bin"
+#define FILE_NVM_DYNAMIC "/data/nvm_dynamic.bin"
+#define FILE_NVM_CAL "/data/nvm_cal.bin"
+enum cp_nvm_type {
+	CP_NVM_STATIC = 0,
+	CP_NVM_DYNAMIC = 1,
+	CP_NVM_CAL = 2,	
+};
+#endif
+
 void (*exynos_c2c_request_pwr_mode)(enum c2c_pwr_mode mode);
+static void c2c_md_reset(void);
 
 #ifdef ENABLE_C2CSTATE_TIMER
 struct timer_list c2c_status_timer;
@@ -101,6 +123,7 @@
 			struct device_attribute *attr, char *buf)
 {
 	int ret = 0;
+
 	ret = sprintf(buf, "C2C State");
 	ret += sprintf(&buf[ret], "SysReg : 0x%x\n",
 			readl(c2c_con.c2c_sysreg));
@@ -110,20 +133,79 @@
 			c2c_readl(EXYNOS_C2C_FCLK_FREQ));
 	ret += sprintf(&buf[ret], "RX_MAX_FREQ : %d\n",
 			c2c_readl(EXYNOS_C2C_RX_MAX_FREQ));
+        ret += sprintf(&buf[ret], "TX_MAX_FREQ : %d\n",
+                       c2c_readl(EXYNOS_C2C_TX_MAX_FREQ));
+        ret += sprintf(&buf[ret], "RX_MAX_FREQ_ACK : %d\n",
+                       c2c_readl(EXYNOS_C2C_TX_MAX_FREQ+4));
 	ret += sprintf(&buf[ret], "IRQ_EN_SET1 : 0x%x\n",
 			c2c_readl(EXYNOS_C2C_IRQ_EN_SET1));
 	ret += sprintf(&buf[ret], "Get C2C sclk rate : %ld\n",
 			clk_get_rate(c2c_con.c2c_sclk));
 	ret += sprintf(&buf[ret], "Get C2C aclk rate : %ld\n",
 			clk_get_rate(c2c_con.c2c_aclk));
+        ret += sprintf(&buf[ret], "CLK_DIV_DMC1 is : %x\n",
+                       readl(ioremap(0x10040504,4)));
+        ret += sprintf(&buf[ret], "CP FCLK_FREQ : %d\n",
+                       readl(ioremap(0x10580000+0x40,4)));
+	ret += sprintf(&buf[ret], "CP RX_MAX_FREQ : %d\n",
+                       readl(ioremap(0x10580000+0x44,4)));
+        ret += sprintf(&buf[ret], "CP TX_MAX_FREQ : %d\n",
+                       readl(ioremap(0x10580000+0x48,4))); 
+        ret += sprintf(&buf[ret], "CP RX_MAX_FREQ_ACK : %d\n",
+                       readl(ioremap(0x10580000+0x4c,4))); 
 
+        
 	return ret;
 }
+#ifdef XMM6262_WRITE_NVM
+static int c2c_write_nvm_data(enum cp_nvm_type nvm)
+{
+	dma_addr_t phy_cpmem, vir_cpmem;
+	struct file *fp_nvm;
+        mm_segment_t fs;
+	int ret = 0;
+
+	/* CMA allocation to read NVM region */
+	phy_cpmem = cma_alloc(c2c_con.c2c_dev, "c2c_shdmem", 64 * 1024 * 1024, 0);
+	if (IS_ERR_VALUE(phy_cpmem)) {
+		dev_info(c2c_con.c2c_dev, "CMA allocation is failed in write NVM.\n");
+		return NULL;
+	}
+	vir_cpmem = phys_to_virt(phy_cpmem);
+
+	/* File Open */
+        fs = get_fs();
+        set_fs(KERNEL_DS);
+
+	switch(nvm) {
+	case CP_NVM_STATIC: /* 128KB */
+		fp_nvm = filp_open(FILE_NVM_STATIC, O_RDWR, 0);	
+		ret = vfs_write(fp_nvm, vir_cpmem + 0x1F80000, 0x20000, &fp_nvm->f_pos);
+		break;
+	case CP_NVM_DYNAMIC: /* 256KB */
+		fp_nvm = filp_open(FILE_NVM_DYNAMIC, O_RDWR, 0);	
+		ret = vfs_write(fp_nvm, vir_cpmem + 0x1FA0000, 0x40000, &fp_nvm->f_pos);
+		break;
+	case CP_NVM_CAL: /* 128KB */
+		fp_nvm = filp_open(FILE_NVM_CAL, O_RDWR, 0);	
+		ret = vfs_write(fp_nvm, vir_cpmem + 0x1FE0000, 0x20000, &fp_nvm->f_pos);
+		break;
+	default :
+		dev_info(c2c_con.c2c_dev, "Wrong NVM Type!!!\n");
+	}
+	filp_close(fp_nvm, NULL);
+	set_fs(fs);
+	cma_free(phy_cpmem);
+
+	return ret;
+}
+#endif
 
 static ssize_t c2c_ctrl_store(struct device *dev, struct device_attribute *attr,
 			const char *buf, size_t count)
 {
 	int ops_num, opp_val, req_clk;
+	int len = 0;
 	sscanf(buf, "%d", &ops_num);
 
 	switch (ops_num) {
@@ -170,6 +252,33 @@
 		dev_info(c2c_con.c2c_dev, "Get C2C aclk rate : %ld\n",
 					clk_get_rate(c2c_con.c2c_aclk));
 		break;
+
+
+	case 5: /* xmm6262 reset */ 
+		c2c_md_reset();
+		break;
+#ifdef XMM6262_WRITE_NVM
+	case 6: /* update static nvm data */
+		len = c2c_write_nvm_data(CP_NVM_STATIC);
+		dev_info(c2c_con.c2c_dev, "Write Static NVM(%d bytes)\n", len);
+		break;
+	case 7: /* update dynaic nvm data */
+		len = c2c_write_nvm_data(CP_NVM_DYNAMIC);
+		dev_info(c2c_con.c2c_dev, "Write Dynamic NVM(%d bytes)\n", len);
+		break;
+	case 8: /* update calibration nvm data */
+		len = c2c_write_nvm_data(CP_NVM_CAL);
+		dev_info(c2c_con.c2c_dev, "Write Calibration NVM(%d bytes)\n", len);
+		break;
+	case 9: /* update all nvm data */
+		len = c2c_write_nvm_data(CP_NVM_STATIC);
+		dev_info(c2c_con.c2c_dev, "Write Static NVM(%d bytes)\n", len);
+		len = c2c_write_nvm_data(CP_NVM_DYNAMIC);
+		dev_info(c2c_con.c2c_dev, "Write Dynamic NVM(%d bytes)\n", len);
+		len = c2c_write_nvm_data(CP_NVM_CAL);
+		dev_info(c2c_con.c2c_dev, "Write Calibration NVM(%d bytes)\n", len);
+		break;
+#endif
 	default:
 		dev_info(c2c_con.c2c_dev, "Wrong C2C operation number\n");
 		dev_info(c2c_con.c2c_dev, "---C2C Operation Number---\n");
@@ -177,12 +286,43 @@
 		dev_info(c2c_con.c2c_dev, "2. Set OPP25\n");
 		dev_info(c2c_con.c2c_dev, "3. Set OPP50\n");
 		dev_info(c2c_con.c2c_dev, "4. Set OPP100\n");
+                dev_info(c2c_con.c2c_dev, "5. XMM6262 Reset\n");
+#ifdef XMM6262_WRITE_NVM
+                dev_info(c2c_con.c2c_dev, "6. Update XMM6262 static nvm data\n");
+                dev_info(c2c_con.c2c_dev, "7. Update XMM6262 dynamic nvm data\n");
+                dev_info(c2c_con.c2c_dev, "8. Update XMM6262 calibration nvm data\n");
+                dev_info(c2c_con.c2c_dev, "9. Update XMM6262 all nvm data\n");
+#endif
+		break;
 	}
-
 	return count;
 }
 
 static DEVICE_ATTR(c2c_ctrl, 0644, c2c_ctrl_show, c2c_ctrl_store);
+#if DEBUG_PORT
+static ssize_t debug_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+        return 0;
+}
+
+static ssize_t debug_store(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+        unsigned int arg,value,*addr;
+        int opp_val, req_clk;
+	int len = 0;
+	sscanf(buf, "%x", &arg);
+        //        printk("Contet at addr %x .\n",addr);
+        addr = ioremap(arg,4);
+        value = readl(addr);
+        printk("Content at addr %x is %x.\n",arg,value);
+        iounmap(addr);
+        return count;
+}
+
+static DEVICE_ATTR(debug_attr, 0644, debug_show, debug_store);
+#endif
 
 int c2c_open(struct inode *inode, struct file *filp)
 {
@@ -192,11 +332,42 @@
 	return 0;
 }
 
+int c2c_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	unsigned long physical = C2C_CP_RGN_ADDR + (vma->vm_pgoff << PAGE_SHIFT);
+	unsigned long size = vma->vm_end - vma->vm_start;
+
+	vma->vm_flags |= (VM_IO | VM_RESERVED);
+
+	physical = __phys_to_pfn(physical);
+
+	if (remap_pfn_range(vma, vma->vm_start, physical, size,
+			vma->vm_page_prot)) {
+		dev_info(c2c_con.c2c_dev, KERN_ERR "MMAP remap_pfn_range error!\n");
+		return -EAGAIN;
+	}
+
+	printk("vm_pgoff		[%08x]\n", vma->vm_pgoff << PAGE_SHIFT);
+	printk("vm_start		[%08x]\n", vma->vm_start);
+	printk("vm_end			[%08x]\n", vma->vm_end);
+	printk("vm_flags		[%08x]\n", vma->vm_flags);
+
+	return 0;
+}
+
 static long c2c_ioctl(struct file *filp, unsigned int cmd,
 		unsigned long arg)
 {
-	c2c_reset_ops();
-
+ 	switch (cmd) {
+	case 1:
+		c2c_reset_ops();
+		break;
+	case 5: /* cp reset */  
+		c2c_md_reset();
+		break;
+        default:
+		dev_info(c2c_con.c2c_dev, "Wrong C2C operation number\n");
+        }
 	return 0;
 }
 
@@ -204,6 +375,7 @@
 	.owner	= THIS_MODULE,
 	.unlocked_ioctl	= c2c_ioctl,
 	.open	= c2c_open,
+	.mmap	= c2c_mmap,
 };
 
 static struct miscdevice char_dev = {
@@ -277,8 +449,8 @@
 		/*
 		    OPP mode GENI/O bit definition[29:27]
 		    OPP100 GENI/O[29:28] : 1 1
-		    OPP50 GENI/O[29:28] : 1 0
-		    OPP25 GENI/O[29:28] : 0 1
+		    OPP50  GENI/O[29:28] : 1 0
+		    OPP25  GENI/O[29:28] : 0 1
 		    GENI[27] is only used for making interrupt.
 		*/
 		opp_val = (c2c_readl(EXYNOS_C2C_GENO_STATUS) >> 28) & 3;
@@ -318,6 +490,7 @@
 	/* Memory I/F latency change */
 	if ((raw_irq >> C2C_GENIO_LATENCY_INT) & 1) {
 		latency_val = (c2c_readl(EXYNOS_C2C_GENO_STATUS) >> 30) & 3;
+                dev_info(c2c_con.c2c_dev,"C2C Latency INT occured\n");	//ylk
 		switch (latency_val) {
 		case 3:
 			dev_info(c2c_con.c2c_dev, "Set Min latency\n");
@@ -387,7 +560,10 @@
 	clk_set_rate(c2c_con.c2c_sclk, (default_clk + 1)  * MHZ);
 	clk_set_rate(c2c_con.c2c_aclk, ((default_clk / 2) + 1) * MHZ);
 
-	dev_info(c2c_con.c2c_dev, "Get C2C sclk rate : %ld\n",
+        //ylk 20120307
+        dev_info(c2c_con.c2c_dev,"CLK_DIV_DMC1 is %x\n",readl(ioremap(0x10040504,4)));
+
+        dev_info(c2c_con.c2c_dev, "Get C2C sclk rate : %ld\n",
 				clk_get_rate(c2c_con.c2c_sclk));
 	dev_info(c2c_con.c2c_dev, "Get C2C aclk rate : %ld\n",
 				clk_get_rate(c2c_con.c2c_aclk));
@@ -426,6 +602,8 @@
 				c2c_readl(EXYNOS_C2C_FCLK_FREQ));
 	dev_info(c2c_con.c2c_dev, "RX_MAX_FREQ register : %d\n",
 				c2c_readl(EXYNOS_C2C_RX_MAX_FREQ));
+        dev_info(c2c_con.c2c_dev, "TX_MAX_FREQ register : %d\n",
+                 c2c_readl(EXYNOS_C2C_TX_MAX_FREQ));
 	dev_info(c2c_con.c2c_dev, "IRQ_EN_SET1 register : 0x%x\n",
 				c2c_readl(EXYNOS_C2C_IRQ_EN_SET1));
 
@@ -528,6 +706,59 @@
 }
 EXPORT_SYMBOL(c2c_reset_interrupt);
 #endif
+static void c2c_md_reset(void)
+{
+#ifdef CONFIG_SMM6260_MODEM
+	printk("It is not suggested to reset modem in C2C.(xujie)\n");
+#else
+        if(gpio_request(EXYNOS4_GPC0(2) ,"MD_RSTN"))
+        {
+          printk("Request GPIO GPC0_2 err!\r\n");
+          goto poweron_err;
+        }
+        else
+        {
+          gpio_direction_output(EXYNOS4_GPC0(2),1);
+        }
+
+        if(gpio_request(EXYNOS4_GPL2(1) ,"MD_RESETBB"))
+        { 
+          printk("Request GPIO GPL2_1 err!\r\n");
+          goto poweron_err;
+        }
+        else
+        {
+          gpio_direction_output(EXYNOS4_GPL2(1),1);
+        }
+
+        mdelay(5);
+
+        /* generate a pulse for GPC0_0 to boot Modem */
+        if(gpio_request(EXYNOS4_GPC0(0) ,"MD_PWON"))
+        {
+          printk("Request GPIO GPC0_0 err!\r\n");
+          goto poweron_err;
+        }
+        else
+        {
+          gpio_direction_output(EXYNOS4_GPC0(0),1);
+        }
+
+        mdelay(5);
+
+        printk("****************************************\n");
+        printk("* 6260  power on successfully!!!********\n");
+        printk("****************************************\n");
+
+        gpio_free(EXYNOS4_GPC0(0));
+        gpio_free(EXYNOS4_GPL2(1));
+        gpio_free(EXYNOS4_GPC0(2));
+#endif
+        return ;
+
+poweron_err:
+        printk("*** 6260  power on failed!!! ***\n");
+}
 
 static int __devinit samsung_c2c_probe(struct platform_device *pdev)
 {
@@ -537,7 +768,7 @@
 	int sscm_irq0, sscm_irq1;
 	int err = 0;
 
-	c2c_con.c2c_dev = &pdev->dev;
+        c2c_con.c2c_dev = &pdev->dev;
 
 	/* resource for AP's SSCM region */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -624,7 +855,14 @@
 		goto release_sscm_irq1;
 	}
 
-	return 0;
+        if(c2c_con.c2c_sysreg) 
+          printk("samsung-c2c: the AP side C2C SYSREG = %x\n",*(int *)c2c_con.c2c_sysreg);
+
+        printk("0x1004109C: %x, 0x10042000: %x\n", readl(ioremap(0x1004109C,4)),readl(ioremap(0x10042000,4)));
+#if DEBUG_PORT
+        device_create_file(&pdev->dev,&dev_attr_debug_attr);
+#endif        
+        return 0;
 
 release_sscm_irq1:
 	free_irq(sscm_irq1, pdev);
@@ -662,7 +900,7 @@
 
 static int samsung_c2c_resume(struct platform_device *dev)
 {
-	struct exynos_c2c_platdata *pdata = dev->dev.platform_data;
+        struct exynos_c2c_platdata *pdata = dev->dev.platform_data;
 
 	if ((soc_is_exynos4212() || soc_is_exynos4412())
 		&& samsung_rev() == EXYNOS4412_REV_0) {
diff -ruNa TC4_Kernel_3.0/drivers/net/Makefile modem/drivers/net/Makefile
--- TC4_Kernel_3.0/drivers/net/Makefile	2012-05-15 15:08:22.000000000 +0800
+++ modem/drivers/net/Makefile	2012-06-07 19:58:14.000000000 +0800
@@ -286,6 +286,8 @@
 obj-$(CONFIG_USB_ZD1201)        += usb/
 obj-$(CONFIG_USB_IPHETH)        += usb/
 obj-$(CONFIG_USB_CDC_PHONET)   += usb/
+#wjp add for usb raw_ip
+obj-$(CONFIG_USB_NET_RAW_IP)    += usb/
 
 obj-$(CONFIG_WLAN) += wireless/
 obj-$(CONFIG_NET_TULIP) += tulip/
diff -ruNa TC4_Kernel_3.0/drivers/net/usb/Kconfig modem/drivers/net/usb/Kconfig
--- TC4_Kernel_3.0/drivers/net/usb/Kconfig	2012-05-15 15:08:20.000000000 +0800
+++ modem/drivers/net/usb/Kconfig	2012-06-07 19:58:14.000000000 +0800
@@ -458,4 +458,13 @@
 
 	  http://ubuntuforums.org/showpost.php?p=10589647&postcount=17
 
+#wjp add for usb raw_ip
+config USB_NET_RAW_IP
+       tristate "RAW-IP Driver for XMM6260 modems"
+       help
+           Choose this option if you have a XMM6260 modem device with RAW-IP suport.
+
+           To compile this driver as a module, choose M here: the
+           module will be called rmnet.
+           
 endmenu
diff -ruNa TC4_Kernel_3.0/drivers/net/usb/Makefile modem/drivers/net/usb/Makefile
--- TC4_Kernel_3.0/drivers/net/usb/Makefile	2012-05-15 15:08:20.000000000 +0800
+++ modem/drivers/net/usb/Makefile	2012-06-07 19:58:14.000000000 +0800
@@ -26,6 +26,9 @@
 obj-$(CONFIG_USB_NET_KALMIA)	+= kalmia.o
 obj-$(CONFIG_USB_IPHETH)	+= ipheth.o
 obj-$(CONFIG_USB_SIERRA_NET)	+= sierra_net.o
+#wjp for usb raw_ip
+obj-$(CONFIG_USB_NET_RAW_IP)   += raw_ip_net.o
+
 obj-$(CONFIG_USB_NET_CX82310_ETH)	+= cx82310_eth.o
 obj-$(CONFIG_USB_NET_CDC_NCM)	+= cdc_ncm.o
 obj-$(CONFIG_USB_VL600)		+= lg-vl600.o
diff -ruNa TC4_Kernel_3.0/drivers/net/usb/raw_ip_net.c modem/drivers/net/usb/raw_ip_net.c
--- TC4_Kernel_3.0/drivers/net/usb/raw_ip_net.c	1970-01-01 08:00:00.000000000 +0800
+++ modem/drivers/net/usb/raw_ip_net.c	2012-06-07 19:58:14.000000000 +0800
@@ -0,0 +1,762 @@
+/*
+ * raw_ip_net.c
+ *
+ * USB network driver for RAW-IP modems.
+ *
+ * Copyright (c) 2011, NVIDIA Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/etherdevice.h>
+#include <linux/usb.h>
+
+#define BASEBAND_USB_NET_DEV_NAME		"rmnet%d"
+
+/* ethernet packet ethertype for IP packets */
+#define NET_IP_ETHERTYPE		0x08, 0x00
+
+#define	TX_TIMEOUT		10
+
+#ifndef USB_NET_BUFSIZ
+#define USB_NET_BUFSIZ				8192
+#endif  /* USB_NET_BUFSIZ */
+
+/* maximum interface number supported */
+#define MAX_INTFS	3
+
+//#undef pr_debug 
+//#define pr_debug printk
+
+MODULE_LICENSE("GPL");
+
+int g_i;
+
+#define usb_net_raw_ip_vid 0x1519
+#define usb_net_raw_ip_pid  0x0020
+unsigned long usb_net_raw_ip_intf[MAX_INTFS] = { 0x03, 0x05, 0x07 };
+unsigned long usb_net_raw_ip_rx_debug;
+unsigned long usb_net_raw_ip_tx_debug;
+
+//module_param(usb_net_raw_ip_vid, ulong, 0644);
+//MODULE_PARM_DESC(usb_net_raw_ip_vid, "usb net (raw-ip) - USB VID");
+//module_param(usb_net_raw_ip_pid, ulong, 0644);
+//MODULE_PARM_DESC(usb_net_raw_ip_pid, "usb net (raw-ip) - USB PID");
+module_param(usb_net_raw_ip_rx_debug, ulong, 0644);
+MODULE_PARM_DESC(usb_net_raw_ip_rx_debug, "usb net (raw-ip) - rx debug");
+module_param(usb_net_raw_ip_tx_debug, ulong, 0644);
+MODULE_PARM_DESC(usb_net_raw_ip_tx_debug, "usb net (raw-ip) - tx debug");
+
+struct baseband_usb {
+	int baseband_index;
+	struct {
+		struct usb_driver *driver;
+		struct usb_device *device;
+		struct usb_interface *interface;
+		struct {
+			struct {
+				unsigned int in;
+				unsigned int out;
+			} isoch, bulk, interrupt;
+		} pipe;
+		/* currently active rx urb */
+		struct urb *rx_urb;
+		/* currently active tx urb */
+		struct urb *tx_urb;
+	} usb;
+};
+
+static struct baseband_usb *baseband_usb_net[MAX_INTFS] = { 0, 0, 0};
+
+static struct net_device *usb_net_raw_ip_dev[MAX_INTFS] = { 0, 0, 0};
+
+static unsigned int g_usb_interface_index[MAX_INTFS];
+static struct usb_interface *g_usb_interface[MAX_INTFS];
+
+static int usb_net_raw_ip_rx_urb_submit(struct baseband_usb *usb);
+static void usb_net_raw_ip_rx_urb_comp(struct urb *urb);
+static void usb_net_raw_ip_tx_urb_comp(struct urb *urb);
+static int baseband_usb_driver_probe(struct usb_interface *intf, const struct usb_device_id *id);
+
+static void baseband_usb_driver_disconnect(struct usb_interface *intf)
+{
+	pr_debug("%s intf %p\n", __func__, intf);
+}
+
+#ifdef CONFIG_PM
+static int baseband_usb_driver_suspend(struct usb_interface *intf,
+	pm_message_t message)
+{
+	int i;
+
+	pr_debug("%s intf %p\n", __func__, intf);
+//	i = intf->cur_altsetting->desc.bInterfaceNumber;
+//	i = (i-1)/2;
+	for (i = 0; i < MAX_INTFS; i++)
+	{
+		pr_debug("[%d]\n", i);
+		if (!baseband_usb_net[i])
+			continue;
+		if (baseband_usb_net[i]->usb.interface != intf) {
+			pr_debug("%p != %p\n",
+				baseband_usb_net[i]->usb.interface, intf);
+			continue;
+		}
+		if (!baseband_usb_net[i]->usb.rx_urb) {
+			pr_debug("rx_usb already killed\n");
+			continue;
+		}
+		/* kill usb rx */
+		usb_kill_urb(baseband_usb_net[i]->usb.rx_urb);
+		baseband_usb_net[i]->usb.rx_urb = (struct urb *) 0;
+	}
+
+	return 0;
+}
+
+static int baseband_usb_driver_resume(struct usb_interface *intf)
+{
+	int i, err;
+
+	pr_debug("%s intf %p\n", __func__, intf);
+//	i = intf->cur_altsetting->desc.bInterfaceNumber;
+//	i = (i-1)/2;
+	for (i = 0; i < MAX_INTFS; i++)
+	{
+		pr_debug("[%d]\n", i);
+		if (!baseband_usb_net[i])
+			continue;
+		if (baseband_usb_net[i]->usb.interface != intf) {
+			pr_debug("%p != %p\n",
+				baseband_usb_net[i]->usb.interface, intf);
+			continue;
+		}
+		if (baseband_usb_net[i]->usb.rx_urb) {
+			pr_debug("rx_usb already exists\n");
+			continue;
+		}
+		/* start usb rx */
+		err = usb_net_raw_ip_rx_urb_submit(baseband_usb_net[i]);
+		if (err < 0) {
+			pr_err("submit rx failed - err %d\n", err);
+			continue;
+		}
+	}
+
+	return 0;
+}
+static int baseband_usb_driver_reset_resume(struct usb_interface *intf)
+{
+	pr_debug("%s intf %p\n", __func__, intf);
+	return baseband_usb_driver_resume(intf);
+}
+#endif /* CONFIG_PM */
+
+static struct usb_device_id baseband_usb_driver_id_table[]={
+	{ USB_DEVICE(usb_net_raw_ip_vid, usb_net_raw_ip_pid),},
+		{ }
+	};
+
+//static char baseband_usb_driver_name[MAX_INTFS][32];
+
+static struct usb_driver baseband_usb_driver = {
+	
+		.name ="baseband_raw_ip_driver",
+		.probe = baseband_usb_driver_probe,
+		.disconnect = baseband_usb_driver_disconnect,
+		.id_table = baseband_usb_driver_id_table,
+#ifdef CONFIG_PM
+		.suspend = baseband_usb_driver_suspend,
+		.resume = baseband_usb_driver_resume,
+		.reset_resume = baseband_usb_driver_reset_resume,
+		.supports_autosuspend = 1,
+#endif
+	};
+
+
+static void find_usb_pipe(struct baseband_usb *usb)
+{
+	struct usb_device *usbdev = usb->usb.device;
+	struct usb_interface *intf = usb->usb.interface;
+	unsigned char numendpoint = intf->cur_altsetting->desc.bNumEndpoints;
+	struct usb_host_endpoint *endpoint = intf->cur_altsetting->endpoint;
+	unsigned char n;
+
+	for (n = 0; n < numendpoint; n++) {
+		if (usb_endpoint_is_isoc_in(&endpoint[n].desc)) {
+			pr_debug("endpoint[%d] isochronous in\n", n);
+			usb->usb.pipe.isoch.in = usb_rcvisocpipe(usbdev,
+				endpoint[n].desc.bEndpointAddress);
+		} else if (usb_endpoint_is_isoc_out(&endpoint[n].desc)) {
+			pr_debug("endpoint[%d] isochronous out\n", n);
+			usb->usb.pipe.isoch.out = usb_sndisocpipe(usbdev,
+				endpoint[n].desc.bEndpointAddress);
+		} else if (usb_endpoint_is_bulk_in(&endpoint[n].desc)) {
+			pr_debug("endpoint[%d] bulk in\n", n);
+			usb->usb.pipe.bulk.in = usb_rcvbulkpipe(usbdev,
+				endpoint[n].desc.bEndpointAddress);
+		} else if (usb_endpoint_is_bulk_out(&endpoint[n].desc)) {
+			pr_debug("endpoint[%d] bulk out\n", n);
+			usb->usb.pipe.bulk.out = usb_sndbulkpipe(usbdev,
+				endpoint[n].desc.bEndpointAddress);
+		} else if (usb_endpoint_is_int_in(&endpoint[n].desc)) {
+			pr_debug("endpoint[%d] interrupt in\n", n);
+			usb->usb.pipe.interrupt.in = usb_rcvintpipe(usbdev,
+				endpoint[n].desc.bEndpointAddress);
+		} else if (usb_endpoint_is_int_out(&endpoint[n].desc)) {
+			pr_debug("endpoint[%d] interrupt out\n", n);
+			usb->usb.pipe.interrupt.out = usb_sndintpipe(usbdev,
+				endpoint[n].desc.bEndpointAddress);
+		} else {
+			pr_debug("endpoint[%d] skipped\n", n);
+		}
+	}
+}
+
+void baseband_usb_close(struct baseband_usb *usb);
+
+struct baseband_usb *baseband_usb_open(struct baseband_usb *usb,int index,
+	unsigned int intf)
+{
+//	struct baseband_usb *usb;
+	int err;
+
+	pr_debug("baseband_usb_open {\n");
+
+	/* allocate baseband usb structure */
+//	usb = kzalloc(sizeof(struct baseband_usb),
+	//	GFP_KERNEL);
+//	if (!usb)
+//		return (struct baseband_usb *) 0;
+
+	/* open usb driver */
+/*	sprintf(baseband_usb_driver_name[index],
+		"baseband_usb_%x_%x_%x",
+		vid, pid, intf);
+	baseband_usb_driver_id_table[index][0].match_flags =
+		USB_DEVICE_ID_MATCH_DEVICE;
+	baseband_usb_driver_id_table[index][0].idVendor = vid;
+	baseband_usb_driver_id_table[index][0].idProduct = pid;*/
+	g_usb_interface_index[index] = intf;
+//	g_usb_interface[index] = (struct usb_interface *) 0;
+/*	err = usb_register(&baseband_usb_driver[index]);
+	if (err < 0) {
+		pr_err("cannot open usb driver - err %d\n", err);
+		goto error_exit;
+	}*/
+	usb->baseband_index = index;
+	usb->usb.driver = &baseband_usb_driver;
+	if (!g_usb_interface[index]) {
+		pr_err("cannot open usb driver - !g_usb_interface[%d]\n",
+			index);
+		goto error_exit;
+	}
+	usb->usb.device = interface_to_usbdev(g_usb_interface[index]);
+	usb->usb.interface = g_usb_interface[index];
+	find_usb_pipe(usb);
+	usb->usb.rx_urb = (struct urb *) 0;
+	usb->usb.tx_urb = (struct urb *) 0;
+//	g_usb_interface_index[index] = ~0U;
+//	g_usb_interface[index] = (struct usb_interface *) 0;
+	pr_debug("usb->usb.driver->name %s\n", usb->usb.driver->name);
+	pr_debug("usb->usb.device %p\n", usb->usb.device);
+	pr_debug("usb->usb.interface %p\n", usb->usb.interface);
+	pr_debug("usb->usb.pipe.isoch.in %x\n", usb->usb.pipe.isoch.in);
+	pr_debug("usb->usb.pipe.isoch.out %x\n", usb->usb.pipe.isoch.out);
+	pr_debug("usb->usb.pipe.bulk.in %x\n", usb->usb.pipe.bulk.in);
+	pr_debug("usb->usb.pipe.bulk.out %x\n", usb->usb.pipe.bulk.out);
+	pr_debug("usb->usb.pipe.interrupt.in %x\n", usb->usb.pipe.interrupt.in);
+	pr_debug("usb->usb.pipe.interrupt.out %x\n",
+		usb->usb.pipe.interrupt.out);
+
+	pr_debug("baseband_usb_open }\n");
+	return usb;
+
+error_exit:
+	return (struct baseband_usb *) 0;
+}
+
+void baseband_usb_close(struct baseband_usb *usb)
+{
+	pr_debug("baseband_usb_close {\n");
+
+	/* check input */
+	if (!usb)
+		return;
+
+	/* close usb driver */
+	if (usb->usb.driver) {
+		pr_debug("close usb driver {\n");
+//		usb_deregister(usb->usb.driver);
+		usb->usb.driver = (struct usb_driver *) 0;
+		pr_debug("close usb driver }\n");
+	}
+
+	/* free baseband usb structure */
+//	kfree(usb);
+
+	pr_debug("baseband_usb_close }\n");
+}
+
+static int baseband_usb_netdev_init(struct net_device *dev)
+{
+	pr_debug("baseband_usb_netdev_init\n");
+	return 0;
+}
+
+static void baseband_usb_netdev_uninit(struct net_device *dev)
+{
+	pr_debug("baseband_usb_netdev_uninit\n");
+}
+
+static int baseband_usb_netdev_open(struct net_device *dev)
+{
+	int res;
+	struct baseband_usb *baseband_usb = netdev_priv(dev);/*wjp for pm*/
+	
+	
+	pr_debug("baseband_usb_netdev_open\n");
+	
+	res = usb_autopm_get_interface(baseband_usb->usb.interface);
+	if (res) {
+		err("Interface cannot be resumed.");
+		return -EIO;
+	}
+	netif_start_queue(dev);
+	return 0;
+}
+
+static int baseband_usb_netdev_stop(struct net_device *dev)
+{
+	int res;
+	struct baseband_usb *baseband_usb = netdev_priv(dev);/*wjp for pm*/
+
+	
+	pr_debug("baseband_usb_netdev_stop\n");
+	netif_stop_queue(dev);
+
+	usb_autopm_put_interface(baseband_usb->usb.interface);
+	return 0;
+}
+
+static netdev_tx_t baseband_usb_netdev_start_xmit(
+	struct sk_buff *skb, struct net_device *dev)
+{
+	int i = 0;
+	struct baseband_usb *usb = netdev_priv(dev);/*wjp for pm*/
+	struct urb *urb;
+	unsigned char *buf;
+	int err;
+
+	pr_debug("baseband_usb_netdev_start_xmit\n");
+
+	/* check input */
+	if (!skb) {
+		pr_err("no skb\n");
+		return -EINVAL;
+	}
+
+	/* allocate urb */
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!urb) {
+		pr_err("usb_alloc_urb() failed\n");
+		return -ENOMEM;
+	}
+	buf = kzalloc(skb->len - 14, GFP_ATOMIC);
+	if (!buf) {
+		pr_err("usb buffer kzalloc() failed\n");
+		usb_free_urb(urb);
+		return -ENOMEM;
+	}
+	err = skb_copy_bits(skb, 14, buf, skb->len - 14);
+	if (err < 0) {
+		pr_err("skb_copy_bits() failed - %d\n", err);
+		kfree(buf);
+		usb_free_urb(urb);
+		return err;
+	}
+	usb_fill_bulk_urb(urb, usb->usb.device, usb->usb.pipe.bulk.out,
+		buf, skb->len - 14,
+		usb_net_raw_ip_tx_urb_comp,
+		usb);
+	urb->transfer_flags = URB_ZERO_PACKET;
+
+	/* submit tx urb */
+	usb->usb.tx_urb = urb;
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err < 0) {
+		pr_err("usb_submit_urb() failed - err %d\n", err);
+		usb->usb.tx_urb = (struct urb *) 0;
+		kfree(urb->transfer_buffer);
+		usb_free_urb(urb);
+		kfree_skb(skb);
+		return err;
+	}
+
+	/* free skb */
+	consume_skb(skb);
+
+	return NETDEV_TX_OK;
+}
+
+static struct net_device_ops usb_net_raw_ip_ops = {
+	.ndo_init =		baseband_usb_netdev_init,
+	.ndo_uninit =		baseband_usb_netdev_uninit,
+	.ndo_open =		baseband_usb_netdev_open,
+	.ndo_stop =		baseband_usb_netdev_stop,
+	.ndo_start_xmit =	baseband_usb_netdev_start_xmit,
+};
+
+static int usb_net_raw_ip_rx_urb_submit(struct baseband_usb *usb)
+{
+	struct urb *urb;
+	void *buf;
+	int err;
+
+	pr_debug("usb_net_raw_ip_rx_urb_submit { usb %p\n", usb);
+
+	/* check input */
+	if (usb->usb.rx_urb) {
+		pr_err("previous urb still active\n");
+		return -1;
+	}
+
+	/* allocate rx urb */
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!urb) {
+		pr_err("usb_alloc_urb() failed\n");
+		return -ENOMEM;
+	}
+	buf = kzalloc(USB_NET_BUFSIZ, GFP_ATOMIC);
+	if (!buf) {
+		pr_err("usb buffer kzalloc() failed\n");
+		usb_free_urb(urb);
+		return -ENOMEM;
+	}
+	usb_fill_bulk_urb(urb, usb->usb.device, usb->usb.pipe.bulk.in,
+		buf, USB_NET_BUFSIZ,
+		usb_net_raw_ip_rx_urb_comp,
+		usb);
+	urb->transfer_flags = 0;
+
+	/* submit rx urb */
+	usb_mark_last_busy(usb->usb.device);
+	usb->usb.rx_urb = urb;
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err < 0) {
+		pr_err("usb_submit_urb() failed - err %d\n", err);
+		usb->usb.rx_urb = (struct urb *) 0;
+		kfree(urb->transfer_buffer);
+		usb_free_urb(urb);
+		return err;
+	}
+
+	pr_debug("usb_net_raw_ip_rx_urb_submit }\n");
+	return err;
+}
+
+static void usb_net_raw_ip_rx_urb_comp(struct urb *urb)
+{
+	struct baseband_usb *usb = (struct baseband_usb *) urb->context;
+	int i = usb->baseband_index;
+	struct sk_buff *skb;
+	unsigned char *dst;
+	unsigned char ethernet_header[14] = {
+		/* Destination MAC */
+		0x00, 0x00,
+		0x00, 0x00,
+		0x00, 0x00,
+		/* Source MAC */
+		0x00, 0x00,
+		0x00, 0x00,
+		0x00, 0x00,
+		/* EtherType */
+		NET_IP_ETHERTYPE,
+	};
+
+	pr_debug("usb_net_raw_ip_rx_urb_comp { urb %p\n", urb);
+
+	/* check input */
+	if (!urb) {
+		pr_err("no urb\n");
+		return;
+	}
+	if (urb->status == -ENOENT) {
+		pr_info("rx urb killed\n");
+		return;
+	}
+	if (urb->status) {
+		pr_info("rx urb status %d\n", urb->status);
+	}
+
+	/* put rx urb data in rx buffer */
+	if (urb->actual_length) {
+		pr_debug("usb_net_raw_ip_rx_urb_comp - "
+			"urb->actual_length %d\n", urb->actual_length);
+		/* allocate skb with space for
+		 * - dummy ethernet header
+		 * - rx IP packet from modem
+		 */
+		skb = netdev_alloc_skb(usb_net_raw_ip_dev[i],
+			NET_IP_ALIGN + 14 + urb->actual_length);
+		if (skb) {
+			/* generate a dummy ethernet header
+			 * since modem sends IP packets without
+			 * any ethernet headers
+			 */
+			memcpy(ethernet_header + 0,
+				usb_net_raw_ip_dev[i]->dev_addr, 6);
+			memcpy(ethernet_header + 6,
+				"0x01\0x02\0x03\0x04\0x05\0x06", 6);
+			/* fill skb with
+			 * - dummy ethernet header
+			 * - rx IP packet from modem
+			 */
+			skb_reserve(skb, NET_IP_ALIGN);
+			dst = skb_put(skb, 14);
+			memcpy(dst, ethernet_header, 14);
+			dst = skb_put(skb, urb->actual_length);
+			memcpy(dst, urb->transfer_buffer, urb->actual_length);
+			skb->protocol = eth_type_trans(skb,
+				usb_net_raw_ip_dev[i]);
+			/* pass skb to network stack */
+			if (netif_rx(skb) < 0) {
+				pr_err("usb_net_raw_ip_rx_urb_comp_work - "
+					"netif_rx(%p) failed\n", skb);
+				kfree_skb(skb);
+			}
+		} else {
+			pr_err("usb_net_raw_ip_rx_urb_comp_work - "
+				"netdev_alloc_skb() failed\n");
+		}
+	}
+
+	/* free rx urb */
+	if (urb->transfer_buffer) {
+		kfree(urb->transfer_buffer);
+		urb->transfer_buffer = (void *) 0;
+	}
+	usb_free_urb(urb);
+	usb->usb.rx_urb = (struct urb *) 0;
+
+	/* submit next rx urb */
+	usb_net_raw_ip_rx_urb_submit(usb);
+
+	pr_debug("usb_net_raw_ip_rx_urb_comp }\n");
+}
+
+static void usb_net_raw_ip_tx_urb_comp(struct urb *urb)
+{
+	struct baseband_usb *usb = (struct baseband_usb *) urb->context;
+
+	pr_debug("usb_net_raw_ip_tx_urb_comp {\n");
+
+	/* free tx urb */
+	if (urb->transfer_buffer) {
+		kfree(urb->transfer_buffer);
+		urb->transfer_buffer = (void *) 0;
+	}
+	usb_free_urb(urb);
+	usb->usb.tx_urb = (struct urb *) 0;
+
+	pr_debug("usb_net_raw_ip_tx_urb_comp }\n");
+}
+
+static int baseband_usb_driver_probe(struct usb_interface *intf,
+	const struct usb_device_id *id)
+{
+//	int i = g_i;
+	int i;
+	int err =0;
+	pr_debug("%s(%d) { intf %p id %p\n", __func__, __LINE__, intf, id);
+
+	pr_debug("i %d\n", i);
+
+	pr_debug("intf->cur_altsetting->desc.bInterfaceNumber %02x\n",
+		intf->cur_altsetting->desc.bInterfaceNumber);
+	pr_debug("intf->cur_altsetting->desc.bAlternateSetting %02x\n",
+		intf->cur_altsetting->desc.bAlternateSetting);
+	pr_debug("intf->cur_altsetting->desc.bNumEndpoints %02x\n",
+		intf->cur_altsetting->desc.bNumEndpoints);
+	pr_debug("intf->cur_altsetting->desc.bInterfaceClass %02x\n",
+		intf->cur_altsetting->desc.bInterfaceClass);
+	pr_debug("intf->cur_altsetting->desc.bInterfaceSubClass %02x\n",
+		intf->cur_altsetting->desc.bInterfaceSubClass);
+	pr_debug("intf->cur_altsetting->desc.bInterfaceProtocol %02x\n",
+		intf->cur_altsetting->desc.bInterfaceProtocol);
+	pr_debug("intf->cur_altsetting->desc.iInterface %02x\n",
+		intf->cur_altsetting->desc.iInterface);
+/*
+	if (g_usb_interface_index[i] !=
+		intf->cur_altsetting->desc.bInterfaceNumber) {
+		pr_debug("%s(%d) } -ENODEV\n", __func__, __LINE__);
+		return -ENODEV;
+	} else {
+		g_usb_interface[i] = intf;
+	}*/
+	for (i = 0; i < MAX_INTFS; i++)
+	{
+	 	if(intf->cur_altsetting->desc.bInterfaceNumber == usb_net_raw_ip_intf[i] )
+	 	{
+	 		g_usb_interface[i] = intf;
+			break;
+	 	}
+	}
+	printk("\n**********wjp********* %d  \n",i);
+	if(i >= MAX_INTFS )
+		{
+			printk("the current interface number is %d",intf->cur_altsetting->desc.bInterfaceNumber);
+			return -ENODEV;
+		}
+	baseband_usb_open(baseband_usb_net[i],i, usb_net_raw_ip_intf[i]);
+
+			/* start usb rx */
+	err = usb_net_raw_ip_rx_urb_submit(baseband_usb_net[i]);
+	if (err < 0) {
+			pr_err("submit rx failed - err %d\n", err);
+//			goto error_exit;
+		}		
+	pr_debug("%s(%d) }\n", __func__, __LINE__);
+	return 0;
+}
+
+
+
+static int usb_net_raw_ip_init(void)
+{
+	int i;
+	int err;
+	struct baseband_usb *baseband_usb;
+	
+
+	pr_debug("usb_net_raw_ip_init {\n");
+
+	/* create multiple raw-ip network devices */
+	for (i = 0; i < MAX_INTFS; i++) {
+		/* open baseband usb */
+//		g_i = i;
+/*		baseband_usb_net[i] = baseband_usb_open(i, usb_net_raw_ip_vid,
+			usb_net_raw_ip_pid, usb_net_raw_ip_intf[i]);
+		if (!baseband_usb_net[i]) {
+			pr_err("cannot open baseband usb net\n");
+			err = -1;
+			goto error_exit;
+		}*/
+		
+		/* register network device */
+		usb_net_raw_ip_dev[i] = alloc_netdev(sizeof(*baseband_usb),
+			BASEBAND_USB_NET_DEV_NAME,
+			ether_setup);
+		if (!usb_net_raw_ip_dev[i]) {
+			pr_err("alloc_netdev() failed\n");
+			err = -ENOMEM;
+			goto error_exit;
+		}
+
+		baseband_usb = netdev_priv(usb_net_raw_ip_dev[i]);
+		
+		baseband_usb_net[i] = baseband_usb;
+//		baseband_usb_open(baseband_usb,i, usb_net_raw_ip_vid,
+//			usb_net_raw_ip_pid, usb_net_raw_ip_intf[i]);
+		if (!baseband_usb_net[i]) {
+			pr_err("cannot open baseband usb net\n");
+			err = -1;
+			goto error_exit;
+		}
+
+
+		usb_net_raw_ip_dev[i]->netdev_ops = &usb_net_raw_ip_ops;
+		usb_net_raw_ip_dev[i]->watchdog_timeo = TX_TIMEOUT;
+		random_ether_addr(usb_net_raw_ip_dev[i]->dev_addr);
+		err = register_netdev(usb_net_raw_ip_dev[i]);
+		if (err < 0) {
+			pr_err("cannot register network device - %d\n", err);
+			goto error_exit;
+		}
+		pr_debug("registered baseband usb network device"
+				" - dev %p name %s\n", usb_net_raw_ip_dev[i],
+				 BASEBAND_USB_NET_DEV_NAME);
+		/* start usb rx */
+//		err = usb_net_raw_ip_rx_urb_submit(baseband_usb_net[i]);
+//		if (err < 0) {
+//			pr_err("submit rx failed - err %d\n", err);
+//			goto error_exit;
+//		}
+	}
+
+	err = usb_register(&baseband_usb_driver);
+	if (err < 0) {
+		pr_err("cannot open usb driver - err %d\n", err);
+		goto error_exit;
+	}
+
+	pr_debug("usb_net_raw_ip_init }\n");
+	return 0;
+
+error_exit:
+	/* destroy multiple raw-ip network devices */
+	for (i = 0; i < MAX_INTFS; i++) {
+		/* unregister network device */
+		if (usb_net_raw_ip_dev[i]) {
+			unregister_netdev(usb_net_raw_ip_dev[i]);
+			free_netdev(usb_net_raw_ip_dev[i]);
+			usb_net_raw_ip_dev[i] = (struct net_device *) 0;
+		}
+		/* close baseband usb */
+/*		if (baseband_usb_net[i]) {
+			baseband_usb_close(baseband_usb_net[i]);
+			baseband_usb_net[i] = (struct baseband_usb *) 0;
+		} */
+	}
+	usb_deregister(&baseband_usb_driver);
+	return err;
+}
+
+static void usb_net_raw_ip_exit(void)
+{
+	int i;
+
+	pr_debug("usb_net_raw_ip_exit {\n");
+
+	/* destroy multiple raw-ip network devices */
+	for (i = 0; i < MAX_INTFS; i++) {
+		/* unregister network device */
+		if (usb_net_raw_ip_dev[i]) {
+			unregister_netdev(usb_net_raw_ip_dev[i]);
+			free_netdev(usb_net_raw_ip_dev[i]);
+			usb_net_raw_ip_dev[i] = (struct net_device *) 0;
+		}
+		/* close baseband usb */
+/*		if (baseband_usb_net[i]) {
+			baseband_usb_close(baseband_usb_net[i]);
+			baseband_usb_net[i] = (struct baseband_usb *) 0;
+		}*/
+	}
+	usb_deregister(&baseband_usb_driver);
+
+	pr_debug("usb_net_raw_ip_exit }\n");
+}
+
+module_init(usb_net_raw_ip_init);
+//late_initcall(usb_net_raw_ip_init);
+module_exit(usb_net_raw_ip_exit);
+
diff -ruNa TC4_Kernel_3.0/drivers/regulator/s5m8767.c modem/drivers/regulator/s5m8767.c
--- TC4_Kernel_3.0/drivers/regulator/s5m8767.c	2012-05-15 15:08:19.000000000 +0800
+++ modem/drivers/regulator/s5m8767.c	2012-07-04 15:30:18.000000000 +0800
@@ -161,7 +161,7 @@
 	case S5M8767_LDO7:
 	//case S5M8767_LDO9: //Robin, ldo9 is for lcd,it's better to power on/off in lcd driver..
 	//case S5M8767_LDO13:
-	case S5M8767_LDO11 ... S5M8767_LDO12://zhangdong, reduce sleep current
+	case S5M8767_LDO11:// ... S5M8767_LDO12://zhangdong, reduce sleep current
 	case S5M8767_LDO14 ... S5M8767_LDO15:
 	case S5M8767_LDO17:
 		 ret = 1;
diff -ruNa TC4_Kernel_3.0/drivers/smm6260_phone/Kconfig modem/drivers/smm6260_phone/Kconfig
--- TC4_Kernel_3.0/drivers/smm6260_phone/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ modem/drivers/smm6260_phone/Kconfig	2012-07-04 15:30:18.000000000 +0800
@@ -0,0 +1,22 @@
+#
+#
+#
+
+menuconfig SMM6260_PHONE
+	tristate "Smm6260 Phone Interface"
+	default n
+	---help---
+		smm6260 phone interface.
+if SMM6260_PHONE
+
+config SMM6260_MODEM
+	tristate "SMM6260 Modem support"
+	help
+	  Say Y here to enable SMM6260 modem control support.
+
+config MODEM_BOOT_IN_UBOOT
+	tristate "modem is booted in uboot"
+	help
+	  Say Y here to enable uboot power up modem.
+	  
+endif # SMM6260_PHONE
diff -ruNa TC4_Kernel_3.0/drivers/smm6260_phone/Makefile modem/drivers/smm6260_phone/Makefile
--- TC4_Kernel_3.0/drivers/smm6260_phone/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ modem/drivers/smm6260_phone/Makefile	2012-07-04 15:30:18.000000000 +0800
@@ -0,0 +1,8 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-$(CONFIG_SMM6260_MODEM) += smm6260_modem.o
+
diff -ruNa TC4_Kernel_3.0/drivers/smm6260_phone/smm6260_modem.c modem/drivers/smm6260_phone/smm6260_modem.c
--- TC4_Kernel_3.0/drivers/smm6260_phone/smm6260_modem.c	1970-01-01 08:00:00.000000000 +0800
+++ modem/drivers/smm6260_phone/smm6260_modem.c	2012-07-04 15:30:18.000000000 +0800
@@ -0,0 +1,1146 @@
+/*
+ * Modem control driver
+ *
+ * Copyright (C) 2010 Samsung Electronics Co.Ltd
+ * Author: Suchang Woo <suchang.woo@samsung.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define DEBUG
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/kdev_t.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#ifdef CONFIG_HAS_WAKELOCK
+#include <linux/wakelock.h>
+#endif
+#include <mach/modem.h>
+#include <linux/modemctl.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+
+extern void usb_host_phy_init(void);
+extern void usb_host_phy_off(void);
+extern void usb_host_phy_suspend(void);
+extern int usb_host_phy_resume(void);
+enum {
+	HOST_WAKEUP_LOW = 1,
+	HOST_WAKEUP_WAIT_RESET,
+} HOST_WAKEUP_STATE;
+
+enum {
+	MODEM_EVENT_RESET,
+	MODEM_EVENT_CRASH,
+	MODEM_EVENT_DUMP,
+	MODEM_EVENT_CONNECT,
+	MODEM_EVENT_RESET_DONE,
+} MODEM_EVENT_TYPE;
+
+/* FIXME: Don't use this except pm */
+struct modemctl *global_mc;
+extern int acm_init(void);
+extern int smd_init(void);
+extern void  acm_exit(void);
+extern void smd_exit(void);
+extern int acm_request_resume(void);
+extern int  s5pv210_ehci_power(int value);
+static int modem_boot_enumeration(struct modemctl *mc);
+static int modem_main_enumeration(struct modemctl *mc);
+
+int mc_reconnect_gpio(void)
+{
+	struct modemctl *mc = global_mc;
+
+	if (!mc)
+		return -EFAULT;
+	printk("TRY Reconnection.................................\n");
+
+	gpio_set_value(mc->gpio_active_state, 0);
+	msleep(10);
+	gpio_set_value(mc->gpio_ipc_slave_wakeup, 1);
+	msleep(10);
+	gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+	msleep(10);
+	gpio_set_value(mc->gpio_active_state, 1);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mc_reconnect_gpio);
+int mc_is_suspend_request(void)
+{
+
+	printk(KERN_DEBUG "%s:suspend requset val=%d\n", __func__,
+		gpio_get_value(global_mc->gpio_suspend_request));
+	return gpio_get_value(global_mc->gpio_suspend_request);
+}
+EXPORT_SYMBOL_GPL(mc_is_suspend_request);
+int mc_prepare_resume(int ms_time)
+{
+	int val;
+	struct completion done;
+	struct modemctl *mc = global_mc;
+	//printk("[XJ] %s\n",__FUNCTION__);
+	if (!mc)
+		return -EFAULT;
+
+	if (mc->cpreset_flag == 1){
+		printk("[XJ] skip wakeup CP for reset happening!\n");
+		return MC_CP_RESET;
+		}
+
+	val = gpio_get_value(mc->gpio_ipc_slave_wakeup);
+	if (val) {
+		gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+		dev_info(mc->dev, "svn SLAV_WUP:reset\n");
+	}
+	val = gpio_get_value(mc->gpio_ipc_host_wakeup);
+	if (val == HOST_WUP_LEVEL) {
+		dev_info(mc->dev, "svn HOST_WUP:high!\n");
+		return MC_HOST_HIGH;
+	}
+
+	init_completion(&done);
+	mc->l2_done = &done;
+	gpio_set_value(mc->gpio_ipc_slave_wakeup, 1);
+	dev_info(mc->dev, "AP>>CP:  SLAV_WUP:1,%d\n",
+		gpio_get_value(mc->gpio_ipc_slave_wakeup));
+
+	if (!wait_for_completion_timeout(&done, ms_time)) {
+		val = gpio_get_value(mc->gpio_ipc_host_wakeup);
+		if (val == HOST_WUP_LEVEL) {
+			dev_err(mc->dev, "maybe complete late.. %d\n", ms_time);
+			mc->l2_done = NULL;
+			return MC_SUCCESS;
+		}
+		dev_err(mc->dev, "Modem wakeup timeout %d\n", ms_time);
+		gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+		dev_info(mc->dev, "AP>>CP:  SLAV_WUP:0,%d\n",
+			gpio_get_value(mc->gpio_ipc_slave_wakeup));
+		mc->l2_done = NULL;
+		return MC_HOST_TIMEOUT;
+	}
+	return MC_SUCCESS;
+}
+EXPORT_SYMBOL_GPL(mc_prepare_resume);
+
+//#ifdef CONFIG_SEC_DEBUG
+/*
+ * HSIC CP uploas scenario -
+ * 1. CP send Crash message
+ * 2. Rild save the ram data to file via HSIC
+ * 3. Rild call the kernel_upload() for AP ram dump
+ */
+static void enumeration(struct modemctl *mc)
+{
+	 gpio_set_value(mc->gpio_active_state, 0);
+}
+//#else
+//static void enumeration(struct modemctl *mc) {}
+//#endif
+
+static int modem_on(struct modemctl *mc)
+{
+	dev_info(mc->dev, "%s\n", __func__);
+	if (!mc->ops || !mc->ops->modem_on)
+		return -ENXIO;
+	//mc->poweroff_flag = 0;
+
+	gpio_set_value(GPIO_XUJIE_MONITOR, 0);
+	gpio_set_value(GPIO_XUJIE_MONITOR, 1);
+
+	//disable_irq(mc->irq[1]);
+	mc->ops->modem_on();
+	//enable_irq(mc->irq[1]);
+	gpio_set_value(GPIO_XUJIE_MONITOR, 0);
+	return 0;
+}
+
+static int modem_off(struct modemctl *mc)
+{
+	dev_info(mc->dev, "%s\n", __func__);
+	if (!mc->ops || !mc->ops->modem_off)
+		return -ENXIO;
+	//disable_irq(mc->irq[0]);
+	gpio_set_value(GPIO_XUJIE_MONITOR, 0);
+	gpio_set_value(GPIO_XUJIE_MONITOR, 1);
+	//disable_irq(mc->irq[1]);
+	msleep(10);
+	//mc->poweroff_flag = 1;
+	mc->ops->modem_off();
+	//enable_irq(mc->irq[1]);	
+	
+	gpio_set_value(GPIO_XUJIE_MONITOR, 0);
+	return 0;
+}
+
+static int modem_reset(struct modemctl *mc)
+{
+	dev_info(mc->dev, "%s\n", __func__);
+	if (!mc->ops || !mc->ops->modem_reset)
+		return -ENXIO;
+	//disable_irq(mc->irq[2]);
+	mc->ops->modem_reset();
+	//enable_irq(mc->irq[2]);
+	return 0;
+}
+
+static int modem_boot(struct modemctl *mc)
+{
+	dev_info(mc->dev, "%s\n", __func__);
+	if (!mc->ops || !mc->ops->modem_boot)
+		return -ENXIO;
+
+	mc->ops->modem_boot();
+
+	return 0;
+}
+
+static int modem_get_active(struct modemctl *mc)
+{
+	dev_info(mc->dev, "%s\n", __func__);
+	if (!mc->gpio_active_state || !mc->gpio_cp_reset)
+		return -ENXIO;
+
+	dev_info(mc->dev, "cp %d phone %d\n",
+			gpio_get_value(mc->gpio_cp_reset),
+			gpio_get_value(mc->gpio_active_state));
+
+	if (gpio_get_value(mc->gpio_cp_reset))
+		return gpio_get_value(mc->gpio_active_state);
+
+	return 0;
+}
+
+static ssize_t show_control(struct device *d,
+		struct device_attribute *attr, char *buf)
+{
+	char *p = buf;
+	struct modemctl *mc = dev_get_drvdata(d);
+	struct modem_ops *ops = mc->ops;
+
+	if (ops) {
+		if (ops->modem_on)
+			p += sprintf(p, "on ");
+		if (ops->modem_off)
+			p += sprintf(p, "off ");
+		if (ops->modem_reset)
+			p += sprintf(p, "reset ");
+		if (ops->modem_boot)
+			p += sprintf(p, "boot ");
+	} else {
+		p += sprintf(p, "(No ops)");
+	}
+
+	p += sprintf(p, "\n");
+	return p - buf;
+}
+extern void smm6260_reset(void);
+
+static ssize_t store_control(struct device *d,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct modemctl *mc = dev_get_drvdata(d);
+printk("---%s():%s\n",__FUNCTION__,buf);
+	if (!strncmp(buf, "testreset", 9)) {
+		printk("---%s():case for test reset\n",__FUNCTION__);
+//		printk("---test report event MODEM_EVENT_RESET\n");
+//		crash_event(MODEM_EVENT_RESET); //report MODEM_EVENT_RESET in mc->do_reset_work
+		printk("---%s():direct reset in kernel\n",__FUNCTION__);
+		mc->boot_done = 0;
+		if (!work_pending(&mc->do_reset_work))
+			schedule_work(&mc->do_reset_work);
+//		smm6260_reset(); //lisw: do the reset function in a dependant thread
+		return count;
+	}
+
+	if (!strncmp(buf, "on", 2)) {
+		modem_on(mc);
+		return count;
+	}
+
+	if (!strncmp(buf, "off", 3)) {
+		modem_off(mc);
+		return count;
+	}
+
+	if (!strncmp(buf, "reset", 5)) {
+		modem_reset(mc);
+		return count;
+	}
+
+	if (!strncmp(buf, "boot", 4)) {
+		modem_boot(mc);
+		return count;
+	}
+
+	if (!strncmp(buf, "renum", 6)) {
+		enumeration(mc);
+		return count;
+	}
+	if (!strncmp(buf, "phon", 4)) {
+		gpio_set_value(mc->gpio_phone_on, 0);
+		mdelay(1);
+		gpio_set_value(mc->gpio_phone_on, 1);
+		return count;
+	}
+	if (!strncmp(buf, "gsw=0", 5)) {
+		gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+		return count;
+	}
+	if (!strncmp(buf, "gsw=1", 5)) {
+		gpio_set_value(mc->gpio_ipc_slave_wakeup, 1);
+		return count;
+	}
+	if (!strncmp(buf, "gat=0", 5)) {
+		gpio_set_value(mc->gpio_active_state, 0);
+		return count;
+	}
+	if (!strncmp(buf, "gat=1", 5)) {
+		gpio_set_value(mc->gpio_active_state, 1);
+		return count;
+	}	
+	return count;
+}
+
+static ssize_t show_status(struct device *d,
+		struct device_attribute *attr, char *buf)
+{
+	char *p = buf;
+	struct modemctl *mc = dev_get_drvdata(d);
+
+	p += sprintf(p, "%d\n", modem_get_active(mc));
+
+	return p - buf;
+}
+
+static ssize_t show_wakeup(struct device *d,
+		struct device_attribute *attr, char *buf)
+{
+	struct modemctl *mc = dev_get_drvdata(d);
+	int count = 0;
+
+	if (!mc->gpio_ipc_host_wakeup)
+		return -ENXIO;
+
+	count += sprintf(buf + count, "%d\n",
+			mc->wakeup_flag);
+
+	return count;
+}
+
+static ssize_t store_wakeup(struct device *d,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct modemctl *mc = dev_get_drvdata(d);
+
+	if (!strncmp(buf, "reset", 5)) {
+		mc->wakeup_flag = HOST_WAKEUP_WAIT_RESET;
+		dev_info(mc->dev, "%s: wakup_flag %d\n",
+			__func__, mc->wakeup_flag);
+		return count;
+	}
+	return 0;
+
+}
+
+static ssize_t show_debug(struct device *d,
+		struct device_attribute *attr, char *buf)
+{
+	char *p = buf;
+	int i;
+	struct modemctl *mc = dev_get_drvdata(d);
+
+	for (i = 0; i < ARRAY_SIZE(mc->irq); i++) {
+		if (mc->irq[i])
+			p += sprintf(p, "Irq %d: %d\n", i, mc->irq[i]);
+	}
+
+	p += sprintf(p, "GPIO ----\n");
+
+	if (mc->gpio_phone_on)
+		p += sprintf(p, "\t%3d %d : phone on\n", mc->gpio_phone_on,
+				gpio_get_value(mc->gpio_phone_on));
+	if (mc->gpio_phone_active)
+		p += sprintf(p, "\t%3d %d : phone active\n",
+				mc->gpio_phone_active,
+				gpio_get_value(mc->gpio_phone_active));
+	if (mc->gpio_pda_active)
+		p += sprintf(p, "\t%3d %d : pda active\n", mc->gpio_pda_active,
+				gpio_get_value(mc->gpio_pda_active));
+	if (mc->gpio_cp_reset)
+		p += sprintf(p, "\t%3d %d : CP reset\n", mc->gpio_cp_reset,
+				gpio_get_value(mc->gpio_cp_reset));
+	if (mc->gpio_usim_boot)
+		p += sprintf(p, "\t%3d %d : USIM boot\n", mc->gpio_usim_boot,
+				gpio_get_value(mc->gpio_usim_boot));
+	if (mc->gpio_flm_sel)
+		p += sprintf(p, "\t%3d %d : FLM sel\n", mc->gpio_flm_sel,
+				gpio_get_value(mc->gpio_flm_sel));
+
+	p += sprintf(p, "Support types ---\n");
+
+	return p - buf;
+}
+static DEVICE_ATTR(control, 0664, show_control, store_control);
+static DEVICE_ATTR(status, S_IRUGO, show_status, NULL);
+static DEVICE_ATTR(wakeup, 0664, show_wakeup, store_wakeup);
+static DEVICE_ATTR(debug, S_IRUGO, show_debug, NULL);
+
+static struct attribute *modem_attributes[] = {
+	&dev_attr_control.attr,
+	&dev_attr_status.attr,
+	&dev_attr_wakeup.attr,
+	&dev_attr_debug.attr,
+	NULL
+};
+
+static const struct attribute_group modem_group = {
+	.attrs = modem_attributes,
+};
+
+void crash_event(int type)
+{
+	char *envs[2] = { NULL, NULL };
+
+	if (!global_mc)
+		return;
+
+	switch (type)
+	{
+
+	case MODEM_EVENT_RESET:
+		envs[0] = "MAILBOX=cp_reset";
+		kobject_uevent_env(&global_mc->dev->kobj, KOBJ_OFFLINE, envs);
+		wake_up_interruptible(&global_mc->wq);
+		printk("%s: MODEM_EVENT_RESET\n", __func__);
+		break;
+	case MODEM_EVENT_DUMP:	
+		envs[0] = "MAILBOX=cp_dump";
+		kobject_uevent_env(&global_mc->dev->kobj, KOBJ_OFFLINE, envs);
+		wake_up_interruptible(&global_mc->wq);
+		printk("%s: MODEM_EVENT_DUMP\n", __func__);
+		break;
+	case MODEM_EVENT_CONNECT:
+		envs[0] = "MAILBOX=cp_connect";
+		kobject_uevent_env(&global_mc->dev->kobj, KOBJ_ONLINE, envs);
+		wake_up_interruptible(&global_mc->wq);
+		printk("%s: MODEM_EVENT_CONNECT\n", __func__);
+		break;
+	case MODEM_EVENT_CRASH:
+		envs[0] = "MAILBOX=cp_crash";
+		kobject_uevent_env(&global_mc->dev->kobj, KOBJ_OFFLINE, envs);
+		wake_up_interruptible(&global_mc->wq);
+		printk("%s: MODEM_EVENT_CRASH\n", __func__);
+		break;
+	case MODEM_EVENT_RESET_DONE:
+		msleep(10000);
+		wake_unlock(&global_mc->reset_lock);
+		envs[0] = "MAILBOX=cp_reset_done";
+		kobject_uevent_env(&global_mc->dev->kobj, KOBJ_OFFLINE, envs);
+		wake_up_interruptible(&global_mc->wq);
+		printk("%s: MODEM_EVENT_RESET_DONE\n", __func__);
+		break;
+	}
+}
+
+
+extern int s5p_ehci_power(int value);
+
+static irqreturn_t modem_resume_thread(int irq, void *dev_id)
+{
+	struct modemctl *mc = (struct modemctl *)dev_id;
+	int val = gpio_get_value(mc->gpio_ipc_host_wakeup);
+	int err;
+	dev_info(mc->dev, "CP>>AP:  HOST_WUP:%d\n", val);
+	//printk("[XJ] mc->in_l3_state=%d\n",mc->in_l3_state);
+	
+	if((mc->ready_to_boot==1)&&(mc->boot_done == 0) && (val == HOST_WUP_LEVEL)){
+			printk("\n ---%s():power on modem success\n",__FUNCTION__);
+			mc->ready_to_boot=0;
+			mc->boot_done =1;
+			#ifdef CONFIG_USB_EHCI_S5P	
+				s5p_ehci_power(1);//power on hsic
+			#endif
+			printk("---%s():prepare to simple enumeration!\n",__FUNCTION__);
+
+			return IRQ_HANDLED;
+		}
+
+	if (val != HOST_WUP_LEVEL) {
+		if(mc->in_l3_state==1){
+			if(gpio_get_value(mc->gpio_ipc_slave_wakeup)) {
+				gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+				dev_info(mc->dev, "AP>>CP:	SLAV_WUP:0,%d\n",
+				gpio_get_value(mc->gpio_ipc_slave_wakeup));
+			}
+			mc->in_l3_state=0;
+			printk("---HOST_WUP_LEVEL is 1 means L3 to L0 transfer over\n ");
+			return IRQ_HANDLED;
+		}
+		else{
+			if (mc->l2_done) {
+				complete(mc->l2_done);
+				mc->l2_done = NULL;
+			}
+			if(gpio_get_value(mc->gpio_ipc_slave_wakeup)) {
+				gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+				dev_info(mc->dev, "AP>>CP:	SLAV_WUP:0,%d\n",
+				gpio_get_value(mc->gpio_ipc_slave_wakeup));
+			}
+			mc->debug_cnt = 0;
+			return IRQ_HANDLED;
+		}
+	}
+	
+	if((mc)&&(mc->in_l3_state==1)&&(val == HOST_WUP_LEVEL)){
+		if ((mc->in_l3_state==1)) {			//xujie temp
+		#if (0) 
+		{
+			if (mc->l3_done) {                   
+				complete(mc->l3_done);
+				mc->l3_done = NULL;
+			}
+			printk("---use l3_done for L3 to L0 transfer\n ");
+		}
+		#endif
+			return IRQ_HANDLED;
+		}
+	}
+
+	if (val == HOST_WUP_LEVEL) {
+		err = acm_request_resume();
+		if (err < 0)
+			dev_err(mc->dev, "request resume failed: %d\n", err);
+			mc->debug_cnt++;
+	}
+	
+	if (mc->debug_cnt > 30) {
+		dev_err(mc->dev, "Abnormal Host wakeup -- over 30times");
+		//disable_irq(irq);
+		mc->debug_cnt = 0;
+		if(mc->boot_done)
+		{
+			mc->cpcrash_flag = 1;
+			crash_event(MODEM_EVENT_CRASH);
+		}		
+	}
+
+	if (!val
+		&& mc->wakeup_flag == HOST_WAKEUP_WAIT_RESET) {
+		mc->wakeup_flag = HOST_WAKEUP_LOW;
+		dev_info(mc->dev, "%s: wakeup flag (%d)\n",
+			__func__, mc->wakeup_flag);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+static irqreturn_t modem_resume_thread(int irq, void *dev_id)
+{
+	struct modemctl *mc = (struct modemctl *)dev_id;
+	int val = gpio_get_value(mc->gpio_ipc_host_wakeup);
+	int err;
+	dev_info(mc->dev, "CP>>AP:  HOST_WUP:%d\n", val);
+	//printk("[XJ] mc->ready_to_boot:%d, mc->boot_done:%d, reset_flag:%d\n",mc->ready_to_boot,mc->boot_done,mc->reset_flag);
+#if 0//lisw: Cp initialize resume can happen in both L0 and L2 state, so this is useless.
+	printk("---CP>>AP:  mc->boot_done=%d,mc->in_l0_state=%d\n",mc->boot_done,mc->in_l0_state);
+	if((mc->boot_done == 1)&&(mc->in_l0_state == 1)&&(val == HOST_WUP_LEVEL)){
+		mc->in_l0_state = 0;
+		printk("---modem_resume_thread(): report event MODEM_EVENT_RESET in L0 state\n");
+		crash_event(MODEM_EVENT_RESET);	
+		return IRQ_HANDLED;
+	}
+#endif
+	
+#if 0	
+		if((mc->wait_boot_done) && (mc->boot_done == 0) && (val == HOST_WUP_LEVEL)){
+				complete(mc->wait_boot_done);
+				mc->wait_boot_done = NULL;
+				mc->boot_done =1;
+				printk("---modem boot done success in kernel\n");
+				return IRQ_HANDLED;
+		}
+#else
+		if((mc->ready_to_boot==1)&&(mc->boot_done == 0) && (val == HOST_WUP_LEVEL)){
+			if (1) //(mc->reset_flag == 0)
+				{
+				printk("\n ---%s():power on modem success\n",__FUNCTION__);
+	//			if (mc->wait_boot_done)
+	//				complete(mc->wait_boot_done);
+					mc->ready_to_boot=0;
+				mc->boot_done =1;
+#ifdef CONFIG_USB_EHCI_S5P	
+				s5p_ehci_power(1);//power on hsic
+#endif
+				printk("---%s():prepare to simple enumeration for c2c\n",__FUNCTION__);
+
+				return IRQ_HANDLED;
+				}
+			else
+				{
+					printk("\n reset function: skip the first interrrupt!\n");
+					mc->reset_flag = 0;
+				}
+		}
+#endif
+
+	if (val != HOST_WUP_LEVEL) {
+		if(mc->boot_done == 1){
+			printk("---%s():delete reset judge time\n",__FUNCTION__);
+			del_timer(&mc->reset_judge_timer);
+		}
+		if(mc->in_l3_state==1){
+			printk("---HOST_WUP_LEVEL is 1 means L3 to L0 transfer over\n ");
+			mc->in_l3_state=0;
+			return IRQ_HANDLED;
+		}
+		else{
+			if (mc->l2_done) {
+				complete(mc->l2_done);
+				mc->l2_done = NULL;
+			}
+			gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+			dev_info(mc->dev, "AP>>CP:	SLAV_WUP:0,%d\n",
+				gpio_get_value(mc->gpio_ipc_slave_wakeup));
+			mc->debug_cnt = 0;
+			return IRQ_HANDLED;
+		}
+	}
+	if((mc)&&(mc->in_l3_state==1)&&(val == HOST_WUP_LEVEL)){
+		if ((mc->in_l3_state==1)) {
+			if(mc->boot_done == 1){
+				printk("---%s():start resetjudge_timer in_l3_state\n",__FUNCTION__);
+				mod_timer(&mc->reset_judge_timer, jiffies + msecs_to_jiffies(1000));
+			}
+			
+			if (mc->l3_done) {
+				complete(mc->l3_done);
+				mc->l3_done = NULL;
+			}
+			printk("---use l3_done for L3 to L0 transfer\n ");
+			return IRQ_HANDLED;
+		}
+	}
+
+	if (val == HOST_WUP_LEVEL) {
+		if(mc->boot_done == 1){
+			printk("---%s():start reset judge_timer not in_l3_state\n",__FUNCTION__);
+			mod_timer(&mc->reset_judge_timer, jiffies + msecs_to_jiffies(1000));
+		}
+#ifdef CONFIG_USB_ACM				
+		err = acm_request_resume();
+#endif
+		if (err < 0)
+			dev_err(mc->dev, "request resume failed: %d\n", err);
+		mc->debug_cnt++;
+		
+
+	}
+	if (mc->debug_cnt > 30) {
+		dev_err(mc->dev, "Abnormal Host wakeup -- over 30times");
+		//disable_irq(irq);
+		mc->debug_cnt = 0;
+		if(mc->boot_done)
+		{
+			mc->cpcrash_flag = 1;
+			crash_event(MODEM_EVENT_CRASH);
+		}		
+	}
+
+	if (!val
+		&& mc->wakeup_flag == HOST_WAKEUP_WAIT_RESET) {
+		mc->wakeup_flag = HOST_WAKEUP_LOW;
+		dev_info(mc->dev, "%s: wakeup flag (%d)\n",
+			__func__, mc->wakeup_flag);
+	}
+
+	return IRQ_HANDLED;
+}
+*/
+static irqreturn_t modem_irq_handler(int irq, void *dev_id)
+{
+	struct modemctl *mc = (struct modemctl *)dev_id;
+	if(mc->boot_done)
+	{
+		int val = gpio_get_value(mc->gpio_suspend_request);
+//		dev_info(mc->dev, "%s: CP_REQUEST_SUSPEND_INT:%d\n", __func__, val);
+		//wake_lock_timeout(&mc->reset_lock, HZ*30);
+		//if (!work_pending(&mc->work.work))
+		//	schedule_delayed_work(&mc->work, msecs_to_jiffies(100));
+		/*schedule_work(&mc->work);*/
+	}
+	return IRQ_HANDLED;
+}
+
+static void mc_cpreset_worker(struct work_struct *work)
+{
+	struct modemctl *mc = container_of(work, struct modemctl, cpreset_work);
+	int val = gpio_get_value(mc->gpio_cp_reset_int);
+	printk("[XJ] mc->boot_done: %d\n",mc->boot_done);
+	
+	if(mc->boot_done)
+	{
+		printk("\n\n[XJ] *****CP reset report!*****\n\n");
+		disable_irq(mc->irq[2]);
+		modem_off(mc);
+		//smm6260_set_active_state(0);
+		mc->cpreset_flag =1;
+		crash_event(MODEM_EVENT_RESET);
+	}
+}
+static void do_reset_worker(struct work_struct *work)
+{
+	struct modemctl *mc = container_of(work, struct modemctl, do_reset_work);
+	dev_info(mc->dev,"---%s():start\n", __func__);
+	printk("[XJ] *********************\n");
+	printk("---%s(): report event MODEM_EVENT_RESET \n",__FUNCTION__);
+	printk("[XJ] *********************\n");
+	//del_timer(&mc->reset_judge_timer);
+	//global_mc->gModemPowerState=0;
+	//crash_event(MODEM_EVENT_RESET);
+	//xujie change the reset strategy from modem driver to user space in order to  coordinate with c2c and nvm.
+	//modem_reset(mc);     
+	disable_irq(mc->irq[2]);
+	modem_off(mc);
+	//smm6260_set_active_state(0);
+	mc->cpreset_flag =1;
+	crash_event(MODEM_EVENT_RESET);
+}
+
+static irqreturn_t modem_cpreset_irq(int irq, void *dev_id)
+{
+	struct modemctl *mc = (struct modemctl *)dev_id;
+	int val = gpio_get_value(mc->gpio_cp_reset_int);
+
+	//dev_info(mc->dev, "%s: CP_RESET_INT:%d\n", __func__, val);
+	if(mc->boot_done) {
+		wake_lock_timeout(&mc->reset_lock, HZ*30);
+		}
+	else
+		return IRQ_HANDLED;
+	if (!work_pending(&mc->cpreset_work))
+		schedule_work(&mc->cpreset_work);
+
+	return IRQ_HANDLED;
+}
+
+static void _free_all(struct modemctl *mc)
+{
+	int i;
+
+	if (mc) {
+		if (mc->ops)
+			mc->ops = NULL;
+
+		if (mc->group)
+			sysfs_remove_group(&mc->dev->kobj, mc->group);
+
+		for (i = 0; i < ARRAY_SIZE(mc->irq); i++) {
+			if (mc->irq[i])
+				free_irq(mc->irq[i], mc);
+		}
+
+		kfree(mc);
+	}
+}
+int modem_open (struct inode *inode, struct file *file)
+{
+	return 0;
+}
+int modem_close (struct inode *inode, struct file *file)
+{
+	return 0;
+}
+int modem_ioctl (struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	printk("%s, cmd: 0x%x\n",__FUNCTION__, cmd);
+	if(!global_mc)
+		{
+			printk("[XJ] no global_mc!\n");
+			return -1;
+		}
+	switch(cmd)
+	{
+		case MODEM_POWER_MAIN_CMD:
+			modem_main_enumeration(global_mc);
+			break;
+		case MODEM_POWER_FLASH_CMD:
+			modem_boot_enumeration(global_mc);
+			break;
+		case MODEM_POWER_OFF_CMD:
+			modem_off(global_mc);
+			break;
+		case MODEM_POWER_ON_CMD:
+			modem_on(global_mc);
+			break;
+		case MODEM_POWER_RESET_CMD:
+			modem_reset(global_mc);
+			break;		
+	}
+	return 0;
+}
+
+static ssize_t modem_read (struct file *filp, char __user * buffer, size_t count, loff_t * offset)
+{
+	int flag = 0;
+	
+	printk("%s: call\n", __func__);
+	if(!global_mc)
+		return -EFAULT;
+	
+	wait_event_interruptible(global_mc->wq, (global_mc->cpcrash_flag || global_mc->cpreset_flag || global_mc->cpdump_flag));
+	
+	flag = (global_mc->cpcrash_flag << CRASH_STATE_OFFSET) |\
+		(global_mc->cpreset_flag << RESET_STATE_OFFSET) |\
+		(global_mc->cpdump_flag << DUMP_STATE_OFFSET);
+	printk("%s: modem event = 0x%x   1\n", __func__, flag);
+	if(copy_to_user(buffer, &flag, sizeof(flag)))
+		return -EFAULT;
+	global_mc->boot_done =0;
+	global_mc->cpcrash_flag =0;
+	global_mc->cpreset_flag =0;
+	global_mc->cpdump_flag =0 ;	
+	printk("%s: modem event = 0x%x   2\n", __func__, flag);
+	return 1;
+}
+static ssize_t modem_write (struct file *filp, const char __user *buffer, size_t count, loff_t *offset)
+{
+	if(!global_mc)
+		return -1;
+
+	if(count >= 4 && !strncmp(buffer, "main", 4))
+	{
+		modem_main_enumeration(global_mc);
+	}
+	if(count >= 5 && !strncmp(buffer, "flash", 5))
+	{
+		modem_boot_enumeration(global_mc);
+	}
+	if(count >= 3 && !strncmp(buffer, "off", 3))
+	{
+		modem_on(global_mc);
+	}
+	if(count >= 2 && !strncmp(buffer, "on", 2))
+	{
+		modem_off(global_mc);
+	}	
+	if(count >= 5 && !strncmp(buffer, "reset", 5))
+	{
+		modem_reset(global_mc);
+	}	
+	return count;
+}
+
+static struct file_operations modem_file_ops = {
+	.owner = THIS_MODULE,
+	.open = modem_open,
+	.release = modem_close,
+	.read = modem_read,
+	.write = modem_write,
+	.unlocked_ioctl = modem_ioctl,
+};
+
+static struct miscdevice modem_miscdev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "modemctl",
+	.fops = &modem_file_ops
+};
+static int modem_boot_enumeration(struct modemctl *mc)
+{
+//	struct completion done;
+
+	wake_lock(&mc->reset_lock);	
+	mc->boot_done =0;
+	mc->cpcrash_flag =0;
+	mc->cpreset_flag =0;
+	mc->cpdump_flag =0 ;
+	mc->boot_done =1;
+	wake_unlock(&mc->reset_lock);	
+	return 0;	
+}
+extern int s5p_ehci_power(int value);
+static int modem_main_enumeration(struct modemctl *mc)
+{
+	struct completion done;
+	unsigned long timeout;
+	//wake_lock(&mc->reset_lock);
+	mc->in_l3_state =0;
+	mc->ready_to_boot =0;
+	mc->boot_done =0;
+	mc->cpcrash_flag =0;
+	mc->cpreset_flag =0;
+	mc->cpdump_flag =0 ;
+
+	#ifdef CONFIG_USB_EHCI_S5P	
+		s5p_ehci_power(0);//power off hsic and remove modem devices for skip bootrom flash program
+		gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+		dev_info(mc->dev, "AP>>CP:	SLAV_WUP:0,%d\n",
+		gpio_get_value(mc->gpio_ipc_slave_wakeup));
+
+
+//	smm6260_set_active_state(1);
+	//modem_on(mc);//power on modem
+	#endif
+		printk("---the first time simple enumeration for c2c\n");
+	
+		mc->ready_to_boot=1;
+		
+	//wake_unlock(&mc->reset_lock);
+	return 0;
+}
+
+
+static int modem_reset_reintinalize(struct modemctl *mc)
+{
+	struct completion done;
+	unsigned long timeout;
+	//wake_lock(&mc->reset_lock);
+	mc->in_l3_state =0;
+	mc->ready_to_boot=1;
+	mc->boot_done =0;
+	mc->cpcrash_flag =0;
+	mc->cpreset_flag =0;
+	mc->cpdump_flag =0 ;
+	mc->reset_flag = 1;
+	mc->reset_count = 0;
+	
+	printk("[XJ] %s() start!\n",__FUNCTION__);
+	
+	s5p_ehci_power(0);//power off hsic and remove modem devices for skip bootrom flash program
+	gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+	dev_info(mc->dev, "AP>>CP:	SLAV_WUP:0,%d\n",
+	gpio_get_value(mc->gpio_ipc_slave_wakeup));
+	
+	modem_on(mc);
+	enable_irq(mc->irq[2]);
+	return 0;
+	
+}
+
+void do_modem_reset(){
+	printk("---%s()\n",__func__);
+	modem_reset_reintinalize(global_mc);
+}
+
+/* timer callback */
+static void reset_judge_timer_func (unsigned long _mc)
+{
+	struct modemctl *mc = (struct modemctl *)_mc;
+	dev_info(mc->dev,"---%s():start mc->boot_done =%d\n",__FUNCTION__,mc->boot_done );
+	mc->boot_done = 0;
+	//if (!work_pending(&mc->do_reset_work))
+		//schedule_work(&mc->do_reset_work);   //xujie
+}
+
+static int __devinit modem_probe(struct platform_device *pdev)
+{
+	struct modem_platform_data *pdata = pdev->dev.platform_data;
+	struct device *dev = &pdev->dev;
+	struct modemctl *mc;
+	int irq;
+	int error;
+	if (!pdata) {
+		dev_err(dev, "No platform data\n");
+		return -EINVAL;
+	}
+
+	mc = kzalloc(sizeof(struct modemctl), GFP_KERNEL);
+	if (!mc) {
+		dev_err(dev, "Failed to allocate device\n");
+		return -ENOMEM;
+	}
+	/////Added by lisw for modem reset function //////
+	mc->gModemPowerState=0;
+	mc->gCdcAcmSimpleEnumeratinoState=0;
+	init_timer(&mc->reset_judge_timer);
+	mc->reset_judge_timer.function = reset_judge_timer_func;
+	mc->reset_judge_timer.data = (unsigned long) mc;
+	///////////////END//////////////////////////
+	mc->gpio_phone_on = pdata->gpio_phone_on;
+	mc->gpio_phone_active = pdata->gpio_phone_active;
+	mc->gpio_pda_active = pdata->gpio_pda_active;
+	mc->gpio_cp_reset = pdata->gpio_cp_reset;
+	mc->gpio_cp_req_reset = pdata->gpio_cp_req_reset;
+	mc->gpio_ipc_slave_wakeup = pdata->gpio_ipc_slave_wakeup;
+	mc->gpio_ipc_host_wakeup = pdata->gpio_ipc_host_wakeup;
+	mc->gpio_suspend_request = pdata->gpio_suspend_request;
+	mc->gpio_active_state = pdata->gpio_active_state;
+	mc->gpio_usim_boot = pdata->gpio_usim_boot;
+	mc->gpio_flm_sel = pdata->gpio_flm_sel;
+	mc->gpio_cp_reset_int = pdata->gpio_cp_reset_int;
+		
+	//mc->gpio_cp_dump_int = pdata->gpio_cp_dump_int;
+	mc->ops = &pdata->ops;
+	mc->dev = dev;
+	dev_set_drvdata(mc->dev, mc);
+
+	error = sysfs_create_group(&mc->dev->kobj, &modem_group);
+	if (error) {
+		dev_err(dev, "Failed to create sysfs files\n");
+		goto fail;
+	}
+	mc->group = &modem_group;
+
+//	INIT_DELAYED_WORK(&mc->work, mc_work);
+	INIT_WORK(&mc->cpreset_work, mc_cpreset_worker);
+	INIT_WORK(&mc->do_reset_work, do_reset_worker);
+	wake_lock_init(&mc->reset_lock, WAKE_LOCK_SUSPEND, "modemctl");
+	init_waitqueue_head(&mc->wq);
+	mc->ops->modem_cfg();
+#if 0
+	irq = gpio_to_irq(pdata->gpio_suspend_request);
+
+	error = request_irq(irq, modem_irq_handler,
+			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+			"phone_request_suspend", mc);
+	if (error) {
+		dev_err(dev, "Active Failed to allocate an interrupt(%d)\n", irq);
+		goto fail;
+	}
+	mc->irq[0] = irq;
+	enable_irq_wake(irq);
+#endif
+	irq = gpio_to_irq(pdata->gpio_ipc_host_wakeup);
+
+	error = request_threaded_irq(irq, NULL, modem_resume_thread,
+			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+			"IPC_HOST_WAKEUP", mc);
+
+	if (error) {
+		dev_err(dev, "Resume thread Failed to allocate an interrupt(%d)\n", irq);
+		goto fail;
+	}
+	mc->irq[1] = irq;
+	enable_irq_wake(irq);
+
+	irq = gpio_to_irq(pdata->gpio_cp_reset_int);
+
+	error = request_threaded_irq(irq, NULL, modem_cpreset_irq,
+			IRQF_TRIGGER_RISING,
+			"CP_RESET_INT", mc);
+
+	if (error) {
+		dev_err(dev, "CP reset report Failed to allocate an interrupt(%d)\n", irq);
+		goto fail;
+	}
+	mc->irq[2] = irq;
+	//enable_irq_wake(irq);	
+
+	mc->debug_cnt = 0;
+
+	device_init_wakeup(&pdev->dev, pdata->wakeup);
+	platform_set_drvdata(pdev, mc);
+	global_mc = mc;
+
+	error = misc_register(&modem_miscdev);
+	if(error)
+	{
+		dev_err(dev, "Failed to register modem control device\n");
+		goto fail;
+	}
+#ifdef CONFIG_MODEM_BOOT_IN_UBOOT
+mc->boot_done =1;
+printk("--- modem boot done in uboot \n");
+#else
+	modem_main_enumeration(mc);//enumerate modem devices
+#endif
+
+	return 0;
+
+fail:
+	_free_all(mc);
+	return error;
+}
+
+static int __devexit modem_remove(struct platform_device *pdev)
+{
+	struct modemctl *mc = platform_get_drvdata(pdev);
+
+	flush_work(&mc->work.work);
+	flush_work(&mc->cpreset_work);
+	platform_set_drvdata(pdev, NULL);
+	wake_lock_destroy(&mc->reset_lock);
+
+	misc_deregister(&modem_miscdev);
+	_free_all(mc);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int modem_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct modemctl *mc = platform_get_drvdata(pdev);
+
+	if (mc->ops && mc->ops->modem_suspend)
+		mc->ops->modem_suspend();
+
+	if (device_may_wakeup(dev) && smm6260_is_on())
+		enable_irq_wake(mc->irq[1]);
+
+	return 0;
+}
+
+static int modem_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct modemctl *mc = platform_get_drvdata(pdev);
+
+	if (device_may_wakeup(dev) && smm6260_is_on())
+		disable_irq_wake(mc->irq[1]);
+
+	if (mc->ops && mc->ops->modem_resume)
+		mc->ops->modem_resume();
+
+	return 0;
+}
+
+static const struct dev_pm_ops modem_pm_ops = {
+	.suspend	= modem_suspend,
+	.resume		= modem_resume,
+};
+#endif
+
+static struct platform_driver modem_driver = {
+	.probe		= modem_probe,
+	.remove		= __devexit_p(modem_remove),
+	.driver		= {
+		.name	= "smm_modem",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm	= &modem_pm_ops,
+#endif
+	},
+};
+
+static int __init modem_init(void)
+{
+	platform_driver_register(&modem_driver);
+	return 0; 
+}
+
+static void __exit modem_exit(void)
+{
+	platform_driver_unregister(&modem_driver);
+}
+//module_init(modem_init);
+late_initcall(modem_init);
+
+module_exit(modem_exit);
diff -ruNa TC4_Kernel_3.0/drivers/smm6260_phone/smm6260_modem - .c modem/drivers/smm6260_phone/smm6260_modem - .c
--- TC4_Kernel_3.0/drivers/smm6260_phone/smm6260_modem - .c	1970-01-01 08:00:00.000000000 +0800
+++ modem/drivers/smm6260_phone/smm6260_modem - .c	2012-07-04 15:30:18.000000000 +0800
@@ -0,0 +1,1166 @@
+/*
+ * Modem control driver
+ *
+ * Copyright (C) 2010 Samsung Electronics Co.Ltd
+ * Author: Suchang Woo <suchang.woo@samsung.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define DEBUG
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+//#include <linux/io.h>
+#include <asm/io.h>
+
+#include <linux/delay.h>
+#include <linux/kdev_t.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#ifdef CONFIG_HAS_WAKELOCK
+#include <linux/wakelock.h>
+#endif
+#include <mach/modem.h>
+
+#include <mach/regs-gpio.h>
+#include <mach/regs-pmu.h>
+
+#include <linux/modemctl.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+
+extern void usb_host_phy_init(void);
+extern void usb_host_phy_off(void);
+extern void usb_host_phy_suspend(void);
+extern int usb_host_phy_resume(void);
+extern int smm6260_get_active_state(void);
+enum {
+	HOST_WAKEUP_LOW = 1,
+	HOST_WAKEUP_WAIT_RESET,
+} HOST_WAKEUP_STATE;
+
+enum {
+	MODEM_EVENT_RESET,
+	MODEM_EVENT_CRASH,
+	MODEM_EVENT_DUMP,
+	MODEM_EVENT_CONNECT,
+	MODEM_EVENT_RESET_DONE,
+	MODEM_EVENT_RESET_IN_L3,
+} MODEM_EVENT_TYPE;
+
+/* FIXME: Don't use this except pm */
+struct modemctl *global_mc;
+extern int acm_init(void);
+extern int smd_init(void);
+extern void  acm_exit(void);
+extern void smd_exit(void);
+extern int acm_request_resume(void);
+extern int  s5pv210_ehci_power(int value);
+static int modem_boot_enumeration(struct modemctl *mc);
+static int modem_main_enumeration(struct modemctl *mc);
+
+int mc_reconnect_gpio(void)
+{
+	struct modemctl *mc = global_mc;
+
+	if (!mc)
+		return -EFAULT;
+	printk("TRY Reconnection.................................\n");
+
+	gpio_set_value(mc->gpio_active_state, 0);
+	msleep(10);
+	gpio_set_value(mc->gpio_ipc_slave_wakeup, 1);
+	msleep(10);
+	gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+	msleep(10);
+	gpio_set_value(mc->gpio_active_state, 1);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mc_reconnect_gpio);
+int mc_is_suspend_request(void)
+{
+
+	printk(KERN_DEBUG "%s:suspend requset val=%d\n", __func__,
+		gpio_get_value(global_mc->gpio_suspend_request));
+	return gpio_get_value(global_mc->gpio_suspend_request);
+}
+EXPORT_SYMBOL_GPL(mc_is_suspend_request);
+int mc_prepare_resume(int ms_time)
+{
+	int val;
+	struct completion done;
+	struct modemctl *mc = global_mc;
+	//printk("[XJ] why not sleep now!\n");
+	//dump_stack();
+	if (!mc)
+		return -EFAULT;
+
+	if (mc->cpreset_flag == 1){
+		printk("[XJ] skip wakeup CP for reset happening!\n");
+		return MC_CP_RESET;
+		}
+
+	val = gpio_get_value(mc->gpio_ipc_slave_wakeup);
+	if (val) {
+		gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+		dev_info(mc->dev, "svn SLAV_WUP:reset\n");
+	}
+	val = gpio_get_value(mc->gpio_ipc_host_wakeup);
+	if (val == HOST_WUP_LEVEL) {
+		dev_info(mc->dev, "svn HOST_WUP:high!\n");
+		return MC_HOST_HIGH;
+	}
+
+	init_completion(&done);
+	mc->l2_done = &done;
+	gpio_set_value(mc->gpio_ipc_slave_wakeup, 1);
+	dev_info(mc->dev, "AP>>CP:  SLAV_WUP:1,%d\n",
+		gpio_get_value(mc->gpio_ipc_slave_wakeup));
+
+	if (!wait_for_completion_timeout(&done, ms_time)) {
+		val = gpio_get_value(mc->gpio_ipc_host_wakeup);
+		if (val == HOST_WUP_LEVEL) {
+			dev_err(mc->dev, "maybe complete late.. %d\n", ms_time);
+			mc->l2_done = NULL;
+			return MC_SUCCESS;
+		}
+		dev_err(mc->dev, "Modem wakeup timeout %d\n", ms_time);
+		gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+		dev_info(mc->dev, "AP>>CP:  SLAV_WUP:0,%d\n",
+			gpio_get_value(mc->gpio_ipc_slave_wakeup));
+		mc->l2_done = NULL;
+		return MC_HOST_TIMEOUT;
+	}
+	return MC_SUCCESS;
+}
+EXPORT_SYMBOL_GPL(mc_prepare_resume);
+
+//#ifdef CONFIG_SEC_DEBUG
+/*
+ * HSIC CP uploas scenario -
+ * 1. CP send Crash message
+ * 2. Rild save the ram data to file via HSIC
+ * 3. Rild call the kernel_upload() for AP ram dump
+ */
+static void enumeration(struct modemctl *mc)
+{
+	 gpio_set_value(mc->gpio_active_state, 0);
+}
+//#else
+//static void enumeration(struct modemctl *mc) {}
+//#endif
+
+static int modem_on(struct modemctl *mc)
+{
+	dev_info(mc->dev, "%s\n", __func__);
+	if (!mc->ops || !mc->ops->modem_on)
+		return -ENXIO;
+	//mc->poweroff_flag = 0;
+
+	gpio_set_value(GPIO_XUJIE_MONITOR, 0);
+	gpio_set_value(GPIO_XUJIE_MONITOR, 1);
+
+	//disable_irq(mc->irq[1]);
+	mc->ops->modem_on();
+	//enable_irq(mc->irq[1]);
+	gpio_set_value(GPIO_XUJIE_MONITOR, 0);
+	return 0;
+}
+
+static int modem_off(struct modemctl *mc)
+{
+	dev_info(mc->dev, "%s\n", __func__);
+	if (!mc->ops || !mc->ops->modem_off)
+		return -ENXIO;
+	//disable_irq(mc->irq[0]);
+	gpio_set_value(GPIO_XUJIE_MONITOR, 0);
+	gpio_set_value(GPIO_XUJIE_MONITOR, 1);
+	//disable_irq(mc->irq[1]);
+	msleep(10);
+	//mc->poweroff_flag = 1;
+	mc->ops->modem_off();
+	//enable_irq(mc->irq[1]);	
+	
+	gpio_set_value(GPIO_XUJIE_MONITOR, 0);
+	return 0;
+}
+
+static int modem_reset(struct modemctl *mc)
+{
+	dev_info(mc->dev, "%s\n", __func__);
+	if (!mc->ops || !mc->ops->modem_reset)
+		return -ENXIO;
+	//disable_irq(mc->irq[2]);
+	mc->ops->modem_reset();
+	//enable_irq(mc->irq[2]);
+	return 0;
+}
+
+static int modem_boot(struct modemctl *mc)
+{
+	dev_info(mc->dev, "%s\n", __func__);
+	if (!mc->ops || !mc->ops->modem_boot)
+		return -ENXIO;
+
+	mc->ops->modem_boot();
+
+	return 0;
+}
+
+static int modem_get_active(struct modemctl *mc)
+{
+	dev_info(mc->dev, "%s\n", __func__);
+	if (!mc->gpio_active_state || !mc->gpio_cp_reset)
+		return -ENXIO;
+
+	dev_info(mc->dev, "cp %d phone %d\n",
+			gpio_get_value(mc->gpio_cp_reset),
+			gpio_get_value(mc->gpio_active_state));
+
+	if (gpio_get_value(mc->gpio_cp_reset))
+		return gpio_get_value(mc->gpio_active_state);
+
+	return 0;
+}
+
+static ssize_t show_control(struct device *d,
+		struct device_attribute *attr, char *buf)
+{
+	char *p = buf;
+	struct modemctl *mc = dev_get_drvdata(d);
+	struct modem_ops *ops = mc->ops;
+
+	if (ops) {
+		if (ops->modem_on)
+			p += sprintf(p, "on ");
+		if (ops->modem_off)
+			p += sprintf(p, "off ");
+		if (ops->modem_reset)
+			p += sprintf(p, "reset ");
+		if (ops->modem_boot)
+			p += sprintf(p, "boot ");
+	} else {
+		p += sprintf(p, "(No ops)");
+	}
+
+	p += sprintf(p, "\n");
+	return p - buf;
+}
+extern void smm6260_reset(void);
+
+static ssize_t store_control(struct device *d,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct modemctl *mc = dev_get_drvdata(d);
+printk("---%s():%s\n",__FUNCTION__,buf);
+	if (!strncmp(buf, "testreset", 9)) {
+		printk("---%s():case for test reset\n",__FUNCTION__);
+//		printk("---test report event MODEM_EVENT_RESET\n");
+//		crash_event(MODEM_EVENT_RESET); //report MODEM_EVENT_RESET in mc->do_reset_work
+		printk("---%s():direct reset in kernel\n",__FUNCTION__);
+		mc->boot_done = 0;
+		if (!work_pending(&mc->do_reset_work))
+			schedule_work(&mc->do_reset_work);
+//		smm6260_reset(); //lisw: do the reset function in a dependant thread
+		return count;
+	}
+
+	if (!strncmp(buf, "on", 2)) {
+		modem_on(mc);
+		return count;
+	}
+
+	if (!strncmp(buf, "off", 3)) {
+		modem_off(mc);
+		return count;
+	}
+
+	if (!strncmp(buf, "reset", 5)) {
+		modem_reset(mc);
+		return count;
+	}
+
+	if (!strncmp(buf, "boot", 4)) {
+		modem_boot(mc);
+		return count;
+	}
+
+	if (!strncmp(buf, "renum", 6)) {
+		enumeration(mc);
+		return count;
+	}
+	if (!strncmp(buf, "phon", 4)) {
+		gpio_set_value(mc->gpio_phone_on, 0);
+		mdelay(1);
+		gpio_set_value(mc->gpio_phone_on, 1);
+		return count;
+	}
+	if (!strncmp(buf, "gsw=0", 5)) {
+		gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+		return count;
+	}
+	if (!strncmp(buf, "gsw=1", 5)) {
+		gpio_set_value(mc->gpio_ipc_slave_wakeup, 1);
+		return count;
+	}
+	if (!strncmp(buf, "gat=0", 5)) {
+		gpio_set_value(mc->gpio_active_state, 0);
+		return count;
+	}
+	if (!strncmp(buf, "gat=1", 5)) {
+		gpio_set_value(mc->gpio_active_state, 1);
+		return count;
+	}	
+	return count;
+}
+
+static ssize_t show_status(struct device *d,
+		struct device_attribute *attr, char *buf)
+{
+	char *p = buf;
+	struct modemctl *mc = dev_get_drvdata(d);
+
+	p += sprintf(p, "%d\n", modem_get_active(mc));
+
+	return p - buf;
+}
+
+static ssize_t show_wakeup(struct device *d,
+		struct device_attribute *attr, char *buf)
+{
+	struct modemctl *mc = dev_get_drvdata(d);
+	int count = 0;
+
+	if (!mc->gpio_ipc_host_wakeup)
+		return -ENXIO;
+
+	count += sprintf(buf + count, "%d\n",
+			mc->wakeup_flag);
+
+	return count;
+}
+
+static ssize_t store_wakeup(struct device *d,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct modemctl *mc = dev_get_drvdata(d);
+
+	if (!strncmp(buf, "reset", 5)) {
+		mc->wakeup_flag = HOST_WAKEUP_WAIT_RESET;
+		dev_info(mc->dev, "%s: wakup_flag %d\n",
+			__func__, mc->wakeup_flag);
+		return count;
+	}
+	return 0;
+
+}
+
+static ssize_t show_debug(struct device *d,
+		struct device_attribute *attr, char *buf)
+{
+	char *p = buf;
+	int i;
+	struct modemctl *mc = dev_get_drvdata(d);
+
+	for (i = 0; i < ARRAY_SIZE(mc->irq); i++) {
+		if (mc->irq[i])
+			p += sprintf(p, "Irq %d: %d\n", i, mc->irq[i]);
+	}
+
+	p += sprintf(p, "GPIO ----\n");
+
+	if (mc->gpio_phone_on)
+		p += sprintf(p, "\t%3d %d : phone on\n", mc->gpio_phone_on,
+				gpio_get_value(mc->gpio_phone_on));
+	if (mc->gpio_phone_active)
+		p += sprintf(p, "\t%3d %d : phone active\n",
+				mc->gpio_phone_active,
+				gpio_get_value(mc->gpio_phone_active));
+	if (mc->gpio_pda_active)
+		p += sprintf(p, "\t%3d %d : pda active\n", mc->gpio_pda_active,
+				gpio_get_value(mc->gpio_pda_active));
+	if (mc->gpio_cp_reset)
+		p += sprintf(p, "\t%3d %d : CP reset\n", mc->gpio_cp_reset,
+				gpio_get_value(mc->gpio_cp_reset));
+	if (mc->gpio_usim_boot)
+		p += sprintf(p, "\t%3d %d : USIM boot\n", mc->gpio_usim_boot,
+				gpio_get_value(mc->gpio_usim_boot));
+	if (mc->gpio_flm_sel)
+		p += sprintf(p, "\t%3d %d : FLM sel\n", mc->gpio_flm_sel,
+				gpio_get_value(mc->gpio_flm_sel));
+
+	p += sprintf(p, "Support types ---\n");
+
+	return p - buf;
+}
+static DEVICE_ATTR(control, 0664, show_control, store_control);
+static DEVICE_ATTR(status, S_IRUGO, show_status, NULL);
+static DEVICE_ATTR(wakeup, 0664, show_wakeup, store_wakeup);
+static DEVICE_ATTR(debug, S_IRUGO, show_debug, NULL);
+
+static struct attribute *modem_attributes[] = {
+	&dev_attr_control.attr,
+	&dev_attr_status.attr,
+	&dev_attr_wakeup.attr,
+	&dev_attr_debug.attr,
+	NULL
+};
+
+static const struct attribute_group modem_group = {
+	.attrs = modem_attributes,
+};
+
+void crash_event(int type)
+{
+	char *envs[2] = { NULL, NULL };
+
+	if (!global_mc)
+		return;
+
+	switch (type)
+	{
+
+	case MODEM_EVENT_RESET:
+		envs[0] = "MAILBOX=cp_reset";
+		kobject_uevent_env(&global_mc->dev->kobj, KOBJ_OFFLINE, envs);
+		wake_up_interruptible(&global_mc->wq);
+		printk("%s: MODEM_EVENT_RESET\n", __func__);
+		break;
+	case MODEM_EVENT_DUMP:	
+		envs[0] = "MAILBOX=cp_dump";
+		kobject_uevent_env(&global_mc->dev->kobj, KOBJ_OFFLINE, envs);
+		wake_up_interruptible(&global_mc->wq);
+		printk("%s: MODEM_EVENT_DUMP\n", __func__);
+		break;
+	case MODEM_EVENT_CONNECT:
+		envs[0] = "MAILBOX=cp_connect";
+		kobject_uevent_env(&global_mc->dev->kobj, KOBJ_ONLINE, envs);
+		wake_up_interruptible(&global_mc->wq);
+		printk("%s: MODEM_EVENT_CONNECT\n", __func__);
+		break;
+	case MODEM_EVENT_CRASH:
+		envs[0] = "MAILBOX=cp_crash";
+		kobject_uevent_env(&global_mc->dev->kobj, KOBJ_OFFLINE, envs);
+		wake_up_interruptible(&global_mc->wq);
+		printk("%s: MODEM_EVENT_CRASH\n", __func__);
+		break;
+	case MODEM_EVENT_RESET_DONE:
+		msleep(10000);
+		//global_mc->cpreset_flag == 0;
+		wake_unlock(&global_mc->reset_lock);
+		envs[0] = "MAILBOX=cp_reset_done";
+		kobject_uevent_env(&global_mc->dev->kobj, KOBJ_OFFLINE, envs);
+		wake_up_interruptible(&global_mc->wq);
+		printk("%s: MODEM_EVENT_RESET_DONE\n", __func__);
+		break;
+	case MODEM_EVENT_RESET_IN_L3:   //CP reset in L3, don't need power off/on CP, only reset ril.   xujie
+		envs[0] = "MAILBOX=cp_reset_in_l3";
+		kobject_uevent_env(&global_mc->dev->kobj, KOBJ_OFFLINE, envs);
+		wake_up_interruptible(&global_mc->wq);
+		printk("%s: MODEM_EVENT_RESET_IN_L3\n", __func__);
+		break;
+	}
+}
+
+
+extern int s5p_ehci_power(int value);
+
+static irqreturn_t modem_resume_thread(int irq, void *dev_id)
+{
+	struct modemctl *mc = (struct modemctl *)dev_id;
+	int val = gpio_get_value(mc->gpio_ipc_host_wakeup);
+	int err;
+	dev_info(mc->dev, "CP>>AP:  HOST_WUP:%d\n", val);
+
+	if((mc->cpreset_in_l3 == 1)&&(val != HOST_WUP_LEVEL)&&(smm6260_get_active_state())){
+		mc->cpreset_in_l3 = 0;
+		crash_event(MODEM_EVENT_RESET_IN_L3);
+		//mod_timer(&mc->reset_judge_timer, jiffies + msecs_to_jiffies(30000));
+		//printk("[XJ] CP reset in normal mode!\n");
+	}
+		
+	if((mc->ready_to_boot==1)&&(mc->boot_done == 0) && (val == HOST_WUP_LEVEL)){
+			printk("\n ---%s():power on modem success\n",__FUNCTION__);
+			mc->ready_to_boot=0;
+			mc->boot_done =1;
+			#ifdef CONFIG_USB_EHCI_S5P	
+				s5p_ehci_power(1);//power on hsic
+			#endif
+			printk("---%s():prepare to simple enumeration for c2c\n",__FUNCTION__);
+
+			return IRQ_HANDLED;
+		}
+
+	if (val != HOST_WUP_LEVEL) {
+			if(mc->cpreset_in_l3 == 1){
+			return IRQ_HANDLED;
+		}
+		if(mc->in_l3_state==1){
+			if(gpio_get_value(mc->gpio_ipc_slave_wakeup)) {
+				gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+				dev_info(mc->dev, "AP>>CP:	SLAV_WUP:0,%d\n",
+				gpio_get_value(mc->gpio_ipc_slave_wakeup));
+			}
+			mc->in_l3_state=0;
+			printk("---HOST_WUP_LEVEL is 1 means L3 to L0 transfer over\n ");
+			return IRQ_HANDLED;
+		}
+		else{
+			if (mc->l2_done) {
+				complete(mc->l2_done);
+				mc->l2_done = NULL;
+			}
+			if(gpio_get_value(mc->gpio_ipc_slave_wakeup)) {
+				gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+				dev_info(mc->dev, "AP>>CP:	SLAV_WUP:0,%d\n",
+				gpio_get_value(mc->gpio_ipc_slave_wakeup));
+			}
+			mc->debug_cnt = 0;
+			return IRQ_HANDLED;
+		}
+	}
+	
+	if((mc)&&(mc->in_l3_state==1)&&(val == HOST_WUP_LEVEL)){
+		if ((mc->in_l3_state==1)) {			//xujie temp
+		#if (0) 
+		{
+			if (mc->l3_done) {                   
+				complete(mc->l3_done);
+				mc->l3_done = NULL;
+			}
+			printk("---use l3_done for L3 to L0 transfer\n ");
+		}
+		#endif
+			return IRQ_HANDLED;
+		}
+	}
+
+	if (val == HOST_WUP_LEVEL) {
+		err = acm_request_resume();
+		if (err < 0)
+			dev_err(mc->dev, "request resume failed: %d\n", err);
+			mc->debug_cnt++;
+	}
+	
+	if (mc->debug_cnt > 30) {
+		dev_err(mc->dev, "Abnormal Host wakeup -- over 30times");
+		//disable_irq(irq);
+		mc->debug_cnt = 0;
+		if(mc->boot_done)
+		{
+			mc->cpcrash_flag = 1;
+			crash_event(MODEM_EVENT_CRASH);
+		}		
+	}
+
+	if (!val
+		&& mc->wakeup_flag == HOST_WAKEUP_WAIT_RESET) {
+		mc->wakeup_flag = HOST_WAKEUP_LOW;
+		dev_info(mc->dev, "%s: wakeup flag (%d)\n",
+			__func__, mc->wakeup_flag);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+static irqreturn_t modem_resume_thread(int irq, void *dev_id)
+{
+	struct modemctl *mc = (struct modemctl *)dev_id;
+	int val = gpio_get_value(mc->gpio_ipc_host_wakeup);
+	int err;
+	dev_info(mc->dev, "CP>>AP:  HOST_WUP:%d\n", val);
+	//printk("[XJ] mc->ready_to_boot:%d, mc->boot_done:%d, reset_flag:%d\n",mc->ready_to_boot,mc->boot_done,mc->reset_flag);
+#if 0//lisw: Cp initialize resume can happen in both L0 and L2 state, so this is useless.
+	printk("---CP>>AP:  mc->boot_done=%d,mc->in_l0_state=%d\n",mc->boot_done,mc->in_l0_state);
+	if((mc->boot_done == 1)&&(mc->in_l0_state == 1)&&(val == HOST_WUP_LEVEL)){
+		mc->in_l0_state = 0;
+		printk("---modem_resume_thread(): report event MODEM_EVENT_RESET in L0 state\n");
+		crash_event(MODEM_EVENT_RESET);	
+		return IRQ_HANDLED;
+	}
+#endif
+	
+#if 0	
+		if((mc->wait_boot_done) && (mc->boot_done == 0) && (val == HOST_WUP_LEVEL)){
+				complete(mc->wait_boot_done);
+				mc->wait_boot_done = NULL;
+				mc->boot_done =1;
+				printk("---modem boot done success in kernel\n");
+				return IRQ_HANDLED;
+		}
+#else
+		if((mc->ready_to_boot==1)&&(mc->boot_done == 0) && (val == HOST_WUP_LEVEL)){
+			if (1) //(mc->reset_flag == 0)
+				{
+				printk("\n ---%s():power on modem success\n",__FUNCTION__);
+	//			if (mc->wait_boot_done)
+	//				complete(mc->wait_boot_done);
+					mc->ready_to_boot=0;
+				mc->boot_done =1;
+#ifdef CONFIG_USB_EHCI_S5P	
+				s5p_ehci_power(1);//power on hsic
+#endif
+				printk("---%s():prepare to simple enumeration for c2c\n",__FUNCTION__);
+
+				return IRQ_HANDLED;
+				}
+			else
+				{
+					printk("\n reset function: skip the first interrrupt!\n");
+					mc->reset_flag = 0;
+				}
+		}
+#endif
+
+	if (val != HOST_WUP_LEVEL) {
+		if(mc->boot_done == 1){
+			printk("---%s():delete reset judge time\n",__FUNCTION__);
+			del_timer(&mc->reset_judge_timer);
+		}
+		if(mc->in_l3_state==1){
+			printk("---HOST_WUP_LEVEL is 1 means L3 to L0 transfer over\n ");
+			mc->in_l3_state=0;
+			return IRQ_HANDLED;
+		}
+		else{
+			if (mc->l2_done) {
+				complete(mc->l2_done);
+				mc->l2_done = NULL;
+			}
+			gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+			dev_info(mc->dev, "AP>>CP:	SLAV_WUP:0,%d\n",
+				gpio_get_value(mc->gpio_ipc_slave_wakeup));
+			mc->debug_cnt = 0;
+			return IRQ_HANDLED;
+		}
+	}
+	if((mc)&&(mc->in_l3_state==1)&&(val == HOST_WUP_LEVEL)){
+		if ((mc->in_l3_state==1)) {
+			if(mc->boot_done == 1){
+				printk("---%s():start resetjudge_timer in_l3_state\n",__FUNCTION__);
+				mod_timer(&mc->reset_judge_timer, jiffies + msecs_to_jiffies(1000));
+			}
+			
+			if (mc->l3_done) {
+				complete(mc->l3_done);
+				mc->l3_done = NULL;
+			}
+			printk("---use l3_done for L3 to L0 transfer\n ");
+			return IRQ_HANDLED;
+		}
+	}
+
+	if (val == HOST_WUP_LEVEL) {
+		if(mc->boot_done == 1){
+			printk("---%s():start reset judge_timer not in_l3_state\n",__FUNCTION__);
+			mod_timer(&mc->reset_judge_timer, jiffies + msecs_to_jiffies(1000));
+		}
+#ifdef CONFIG_USB_ACM				
+		err = acm_request_resume();
+#endif
+		if (err < 0)
+			dev_err(mc->dev, "request resume failed: %d\n", err);
+		mc->debug_cnt++;
+		
+
+	}
+	if (mc->debug_cnt > 30) {
+		dev_err(mc->dev, "Abnormal Host wakeup -- over 30times");
+		//disable_irq(irq);
+		mc->debug_cnt = 0;
+		if(mc->boot_done)
+		{
+			mc->cpcrash_flag = 1;
+			crash_event(MODEM_EVENT_CRASH);
+		}		
+	}
+
+	if (!val
+		&& mc->wakeup_flag == HOST_WAKEUP_WAIT_RESET) {
+		mc->wakeup_flag = HOST_WAKEUP_LOW;
+		dev_info(mc->dev, "%s: wakeup flag (%d)\n",
+			__func__, mc->wakeup_flag);
+	}
+
+	return IRQ_HANDLED;
+}
+*/
+static irqreturn_t modem_irq_handler(int irq, void *dev_id)
+{
+	struct modemctl *mc = (struct modemctl *)dev_id;
+	if(mc->boot_done)
+	{
+		int val = gpio_get_value(mc->gpio_suspend_request);
+//		dev_info(mc->dev, "%s: CP_REQUEST_SUSPEND_INT:%d\n", __func__, val);
+		//wake_lock_timeout(&mc->reset_lock, HZ*30);
+		//if (!work_pending(&mc->work.work))
+		//	schedule_delayed_work(&mc->work, msecs_to_jiffies(100));
+		/*schedule_work(&mc->work);*/
+	}
+	return IRQ_HANDLED;
+}
+
+static void mc_cpreset_worker(struct work_struct *work)
+{
+	struct modemctl *mc = container_of(work, struct modemctl, cpreset_work);
+	int val = gpio_get_value(mc->gpio_cp_reset_int);
+	printk("[XJ] mc->boot_done: %d\n",mc->boot_done);
+	
+	if((mc->boot_done)&&(mc->cpreset_flag !=1))
+	{
+		printk("\n\n[XJ] *****CP reset report!*****\n\n");
+		disable_irq(mc->irq[2]);
+		modem_off(mc);
+		//smm6260_set_active_state(0);
+		mc->cpreset_flag =1;
+		crash_event(MODEM_EVENT_RESET);
+	}
+}
+static void do_reset_worker(struct work_struct *work)
+{
+	struct modemctl *mc = container_of(work, struct modemctl, do_reset_work);
+	dev_info(mc->dev,"---%s():start\n", __func__);
+	//printk("[XJ] *********************\n");
+	//printk("---%s(): report event MODEM_EVENT_RESET \n",__FUNCTION__);
+	//printk("[XJ] *********************\n");
+	//del_timer(&mc->reset_judge_timer);
+	//global_mc->gModemPowerState=0;
+	//crash_event(MODEM_EVENT_RESET);
+	//xujie change the reset strategy from modem driver to user space in order to  coordinate with c2c and nvm.
+	//modem_reset(mc);               
+}
+
+static irqreturn_t modem_cpreset_irq(int irq, void *dev_id)
+{
+	struct modemctl *mc = (struct modemctl *)dev_id;
+	int val = gpio_get_value(mc->gpio_cp_reset_int);
+
+	//dev_info(mc->dev, "%s: CP_RESET_INT:%d\n", __func__, val);
+
+	if(mc->cpreset_in_l3 == 1)
+		return IRQ_HANDLED;
+	if(mc->boot_done) {
+		wake_lock_timeout(&mc->reset_lock, HZ*30);
+		}
+	else
+		return IRQ_HANDLED;
+	if (!work_pending(&mc->cpreset_work))
+		schedule_work(&mc->cpreset_work);
+
+	return IRQ_HANDLED;
+}
+
+static void _free_all(struct modemctl *mc)
+{
+	int i;
+
+	if (mc) {
+		if (mc->ops)
+			mc->ops = NULL;
+
+		if (mc->group)
+			sysfs_remove_group(&mc->dev->kobj, mc->group);
+
+		for (i = 0; i < ARRAY_SIZE(mc->irq); i++) {
+			if (mc->irq[i])
+				free_irq(mc->irq[i], mc);
+		}
+
+		kfree(mc);
+	}
+}
+int modem_open (struct inode *inode, struct file *file)
+{
+	return 0;
+}
+int modem_close (struct inode *inode, struct file *file)
+{
+	return 0;
+}
+int modem_ioctl (struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	printk("%s, cmd: 0x%x\n",__FUNCTION__, cmd);
+	if(!global_mc)
+		{
+			printk("[XJ] no global_mc!\n");
+			return -1;
+		}
+	switch(cmd)
+	{
+		case MODEM_POWER_MAIN_CMD:
+			modem_main_enumeration(global_mc);
+			break;
+		case MODEM_POWER_FLASH_CMD:
+			modem_boot_enumeration(global_mc);
+			break;
+		case MODEM_POWER_OFF_CMD:
+			modem_off(global_mc);
+			break;
+		case MODEM_POWER_ON_CMD:
+			modem_on(global_mc);
+			break;
+		case MODEM_POWER_RESET_CMD:
+			modem_reset(global_mc);
+			break;		
+	}
+	return 0;
+}
+
+static ssize_t modem_read (struct file *filp, char __user * buffer, size_t count, loff_t * offset)
+{
+	int flag = 0;
+	
+	printk("%s: call\n", __func__);
+	if(!global_mc)
+		return -EFAULT;
+	
+	wait_event_interruptible(global_mc->wq, (global_mc->cpcrash_flag || global_mc->cpreset_flag || global_mc->cpdump_flag));
+	
+	flag = (global_mc->cpcrash_flag << CRASH_STATE_OFFSET) |\
+		(global_mc->cpreset_flag << RESET_STATE_OFFSET) |\
+		(global_mc->cpdump_flag << DUMP_STATE_OFFSET);
+	printk("%s: modem event = 0x%x   1\n", __func__, flag);
+	if(copy_to_user(buffer, &flag, sizeof(flag)))
+		return -EFAULT;
+	global_mc->boot_done =0;
+	global_mc->cpcrash_flag =0;
+	global_mc->cpreset_flag =0;
+	global_mc->cpdump_flag =0 ;	
+	printk("%s: modem event = 0x%x   2\n", __func__, flag);
+	return 1;
+}
+static ssize_t modem_write (struct file *filp, const char __user *buffer, size_t count, loff_t *offset)
+{
+	if(!global_mc)
+		return -1;
+
+	if(count >= 4 && !strncmp(buffer, "main", 4))
+	{
+		modem_main_enumeration(global_mc);
+	}
+	if(count >= 5 && !strncmp(buffer, "flash", 5))
+	{
+		modem_boot_enumeration(global_mc);
+	}
+	if(count >= 3 && !strncmp(buffer, "off", 3))
+	{
+		modem_on(global_mc);
+	}
+	if(count >= 2 && !strncmp(buffer, "on", 2))
+	{
+		modem_off(global_mc);
+	}	
+	if(count >= 5 && !strncmp(buffer, "reset", 5))
+	{
+		modem_reset(global_mc);
+	}	
+	return count;
+}
+
+static struct file_operations modem_file_ops = {
+	.owner = THIS_MODULE,
+	.open = modem_open,
+	.release = modem_close,
+	.read = modem_read,
+	.write = modem_write,
+	.unlocked_ioctl = modem_ioctl,
+};
+
+static struct miscdevice modem_miscdev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "modemctl",
+	.fops = &modem_file_ops
+};
+static int modem_boot_enumeration(struct modemctl *mc)
+{
+//	struct completion done;
+
+	wake_lock(&mc->reset_lock);	
+	mc->boot_done =0;
+	mc->cpcrash_flag =0;
+	mc->cpreset_flag =0;
+	mc->cpdump_flag =0 ;
+	mc->boot_done =1;
+	wake_unlock(&mc->reset_lock);	
+	return 0;	
+}
+extern int s5p_ehci_power(int value);
+static int modem_main_enumeration(struct modemctl *mc)
+{
+	struct completion done;
+	unsigned long timeout;
+	//wake_lock(&mc->reset_lock);
+	mc->in_l3_state =0;
+	mc->ready_to_boot =0;
+	mc->boot_done =0;
+	mc->cpcrash_flag =0;
+	mc->cpreset_flag =0;
+	mc->cpdump_flag =0 ;
+
+	#ifdef CONFIG_USB_EHCI_S5P	
+		s5p_ehci_power(0);//power off hsic and remove modem devices for skip bootrom flash program
+		gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+		dev_info(mc->dev, "AP>>CP:	SLAV_WUP:0,%d\n",
+		gpio_get_value(mc->gpio_ipc_slave_wakeup));
+	#endif
+		printk("---the first time simple enumeration for c2c\n");
+	
+		mc->ready_to_boot=1;
+		
+	//wake_unlock(&mc->reset_lock);
+	return 0;
+}
+
+
+static int modem_reset_reintinalize(struct modemctl *mc)
+{
+	struct completion done;
+	unsigned long timeout;
+	//wake_lock(&mc->reset_lock);
+	mc->in_l3_state =0;
+	mc->ready_to_boot=1;
+	mc->boot_done =0;
+	mc->cpcrash_flag =0;
+	mc->cpreset_flag =0;
+	mc->cpdump_flag =0 ;
+	mc->reset_flag = 1;
+	mc->reset_count = 0;
+	
+	printk("[XJ] %s() start!\n",__FUNCTION__);
+	
+	s5p_ehci_power(0);//power off hsic and remove modem devices for skip bootrom flash program
+	gpio_set_value(mc->gpio_ipc_slave_wakeup, 0);
+	dev_info(mc->dev, "AP>>CP:	SLAV_WUP:0,%d\n",
+	gpio_get_value(mc->gpio_ipc_slave_wakeup));
+	
+	modem_on(mc);
+	enable_irq(mc->irq[2]);
+	return 0;
+	
+}
+
+void do_modem_reset(){
+	printk("---%s()\n",__func__);
+	modem_reset_reintinalize(global_mc);
+}
+
+/* timer callback */
+static void reset_judge_timer_func (unsigned long _mc)
+{
+	struct modemctl *mc = (struct modemctl *)_mc;
+	dev_info(mc->dev,"---%s():start mc->boot_done =%d\n",__FUNCTION__,mc->boot_done );
+	//mc->boot_done = 0;
+	if (!work_pending(&mc->cpreset_work))
+		schedule_work(&mc->cpreset_work);   //xujie
+}
+
+static int __devinit modem_probe(struct platform_device *pdev)
+{
+	struct modem_platform_data *pdata = pdev->dev.platform_data;
+	struct device *dev = &pdev->dev;
+	struct modemctl *mc;
+	int irq;
+	int error;
+	if (!pdata) {
+		dev_err(dev, "No platform data\n");
+		return -EINVAL;
+	}
+
+	mc = kzalloc(sizeof(struct modemctl), GFP_KERNEL);
+	if (!mc) {
+		dev_err(dev, "Failed to allocate device\n");
+		return -ENOMEM;
+	}
+	/////Added by lisw for modem reset function //////
+	mc->gModemPowerState=0;
+	mc->gCdcAcmSimpleEnumeratinoState=0;
+	init_timer(&mc->reset_judge_timer);
+	mc->reset_judge_timer.function = reset_judge_timer_func;
+	mc->reset_judge_timer.data = (unsigned long) mc;
+	///////////////END//////////////////////////
+	mc->gpio_phone_on = pdata->gpio_phone_on;
+	mc->gpio_phone_active = pdata->gpio_phone_active;
+	mc->gpio_pda_active = pdata->gpio_pda_active;
+	mc->gpio_cp_reset = pdata->gpio_cp_reset;
+	mc->gpio_cp_req_reset = pdata->gpio_cp_req_reset;
+	mc->gpio_ipc_slave_wakeup = pdata->gpio_ipc_slave_wakeup;
+	mc->gpio_ipc_host_wakeup = pdata->gpio_ipc_host_wakeup;
+	mc->gpio_suspend_request = pdata->gpio_suspend_request;
+	mc->gpio_active_state = pdata->gpio_active_state;
+	mc->gpio_usim_boot = pdata->gpio_usim_boot;
+	mc->gpio_flm_sel = pdata->gpio_flm_sel;
+	mc->gpio_cp_reset_int = pdata->gpio_cp_reset_int;
+		
+	//mc->gpio_cp_dump_int = pdata->gpio_cp_dump_int;
+	mc->ops = &pdata->ops;
+	mc->dev = dev;
+	dev_set_drvdata(mc->dev, mc);
+
+	error = sysfs_create_group(&mc->dev->kobj, &modem_group);
+	if (error) {
+		dev_err(dev, "Failed to create sysfs files\n");
+		goto fail;
+	}
+	mc->group = &modem_group;
+
+//	INIT_DELAYED_WORK(&mc->work, mc_work);
+	INIT_WORK(&mc->cpreset_work, mc_cpreset_worker);
+	INIT_WORK(&mc->do_reset_work, do_reset_worker);
+	wake_lock_init(&mc->reset_lock, WAKE_LOCK_SUSPEND, "modemctl");
+	init_waitqueue_head(&mc->wq);
+	mc->ops->modem_cfg();
+#if 0
+	irq = gpio_to_irq(pdata->gpio_suspend_request);
+
+	error = request_irq(irq, modem_irq_handler,
+			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+			"phone_request_suspend", mc);
+	if (error) {
+		dev_err(dev, "Active Failed to allocate an interrupt(%d)\n", irq);
+		goto fail;
+	}
+	mc->irq[0] = irq;
+	enable_irq_wake(irq);
+#endif
+	irq = gpio_to_irq(pdata->gpio_ipc_host_wakeup);
+
+	error = request_threaded_irq(irq, NULL, modem_resume_thread,
+			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+			"IPC_HOST_WAKEUP", mc);
+
+	if (error) {
+		dev_err(dev, "Resume thread Failed to allocate an interrupt(%d)\n", irq);
+		goto fail;
+	}
+	mc->irq[1] = irq;
+	enable_irq_wake(irq);
+
+	irq = gpio_to_irq(pdata->gpio_cp_reset_int);
+
+	error = request_threaded_irq(irq, NULL, modem_cpreset_irq,
+			IRQF_TRIGGER_RISING,
+			"CP_RESET_INT", mc);
+
+	if (error) {
+		dev_err(dev, "CP reset report Failed to allocate an interrupt(%d)\n", irq);
+		goto fail;
+	}
+	mc->irq[2] = irq;
+	//enable_irq_wake(irq);	
+
+	mc->debug_cnt = 0;
+
+	device_init_wakeup(&pdev->dev, pdata->wakeup);
+	platform_set_drvdata(pdev, mc);
+	global_mc = mc;
+
+	error = misc_register(&modem_miscdev);
+	if(error)
+	{
+		dev_err(dev, "Failed to register modem control device\n");
+		goto fail;
+	}
+#ifdef CONFIG_MODEM_BOOT_IN_UBOOT
+mc->boot_done =1;
+printk("--- modem boot done in uboot \n");
+#else
+	modem_main_enumeration(mc);//enumerate modem devices
+#endif
+
+	return 0;
+
+fail:
+	_free_all(mc);
+	return error;
+}
+
+static int __devexit modem_remove(struct platform_device *pdev)
+{
+	struct modemctl *mc = platform_get_drvdata(pdev);
+
+	flush_work(&mc->work.work);
+	flush_work(&mc->cpreset_work);
+	platform_set_drvdata(pdev, NULL);
+	wake_lock_destroy(&mc->reset_lock);
+
+	misc_deregister(&modem_miscdev);
+	_free_all(mc);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int modem_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct modemctl *mc = platform_get_drvdata(pdev);
+
+	if (mc->ops && mc->ops->modem_suspend)
+		mc->ops->modem_suspend();
+
+	if (device_may_wakeup(dev) && smm6260_is_on())
+		enable_irq_wake(mc->irq[1]);
+
+	return 0;
+}
+
+static int modem_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct modemctl *mc = platform_get_drvdata(pdev);
+
+	if (device_may_wakeup(dev) && smm6260_is_on())
+		disable_irq_wake(mc->irq[1]);
+
+	if (mc->ops && mc->ops->modem_resume)
+		mc->ops->modem_resume();
+
+	return 0;
+}
+
+static const struct dev_pm_ops modem_pm_ops = {
+	.suspend	= modem_suspend,
+	.resume		= modem_resume,
+};
+#endif
+
+static struct platform_driver modem_driver = {
+	.probe		= modem_probe,
+	.remove		= __devexit_p(modem_remove),
+	.driver		= {
+		.name	= "smm_modem",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm	= &modem_pm_ops,
+#endif
+	},
+};
+
+static int __init modem_init(void)
+{
+	platform_driver_register(&modem_driver);
+	return 0; 
+}
+
+static void __exit modem_exit(void)
+{
+	platform_driver_unregister(&modem_driver);
+}
+//module_init(modem_init);
+late_initcall(modem_init);
+
+module_exit(modem_exit);
diff -ruNa TC4_Kernel_3.0/drivers/tty/Kconfig modem/drivers/tty/Kconfig
--- TC4_Kernel_3.0/drivers/tty/Kconfig	2012-05-15 15:08:20.000000000 +0800
+++ modem/drivers/tty/Kconfig	2012-06-07 19:58:14.000000000 +0800
@@ -319,6 +319,13 @@
 	  This line discipline provides support for the GSM MUX protocol and
 	  presents the mux as a set of 61 individual tty devices.
 
+config RMNET
+	tristate "RMNET line discipline support "
+	depends on NET
+	help
+	  This line discipline provides support for raw-ip mode over CDC_ACM .
+
+
 config TRACE_ROUTER
 	tristate "Trace data router for MIPI P1149.7 cJTAG standard"
 	depends on TRACE_SINK
diff -ruNa TC4_Kernel_3.0/drivers/tty/Makefile modem/drivers/tty/Makefile
--- TC4_Kernel_3.0/drivers/tty/Makefile	2012-05-15 15:08:20.000000000 +0800
+++ modem/drivers/tty/Makefile	2012-06-07 19:58:14.000000000 +0800
@@ -26,5 +26,6 @@
 obj-$(CONFIG_SYNCLINK_GT)	+= synclink_gt.o
 obj-$(CONFIG_SYNCLINKMP)	+= synclinkmp.o
 obj-$(CONFIG_SYNCLINK)		+= synclink.o
-
+#wjp add rmnet.c
+obj-$(CONFIG_RMNET)		+= rmnet.o
 obj-y += ipwireless/
diff -ruNa TC4_Kernel_3.0/drivers/tty/rmnet.c modem/drivers/tty/rmnet.c
--- TC4_Kernel_3.0/drivers/tty/rmnet.c	1970-01-01 08:00:00.000000000 +0800
+++ modem/drivers/tty/rmnet.c	2012-06-07 19:58:14.000000000 +0800
@@ -0,0 +1,396 @@
+/*
+ * xmd_rmnet.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ * Author: Brian Swetland <swetland@google.com>
+ *
+ * Copyright (C) 2011 Intel Mobile Communications GmbH. All rights reserved.
+ * Author: Srinivas M <srinivasaraox.mandadapu@intel.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * RMNET Driver modified by Intel from Google msm_rmnet.c
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/skbuff.h>
+#include <linux/tty.h>
+#include <linux/netdevice.h>
+#include <linux/poll.h>
+#include <linux/crc-ccitt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <asm/uaccess.h>
+#include <asm/string.h>
+#include <linux/types.h>
+#include <linux/compiler.h>
+#include <linux/signal.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/etherdevice.h>
+#include <linux/ipv6.h>
+#include <linux/ip.h>
+#include <asm/byteorder.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+MODULE_LICENSE("GPL");
+
+/**************************DEFINES***************************/
+#define RMNET_ETH_HDR_SIZE   14
+#define RMNET_MTU_SIZE 1514
+#define RMNET_IPV4_VER 0x4
+#define RMNET_IPV6_VER 0x6
+#define IPV6_HEADER_SZ 40
+#define IPV6_PROTO_TYPE 0x08DD
+#define N_RMNET 	25
+/************************************************************/
+
+/************************STRUCTURES**************************/
+struct rmnet_private
+{	
+	struct net_device_stats stats;
+	struct tty_struct *tty;
+	struct mutex txrx_mutex_lock;
+	struct net_device *dev;
+};
+/************************************************************/
+
+/**********************GLOBAL VARIABLES**********************/
+struct rmnet_private *g_rmnet_private;
+/************************************************************/
+
+/*******************FUNCTION DECLARATION*********************/
+static int rmnet_init(void);
+static void ifx_netif_rx_cb(struct net_device *ptr_dev, const unsigned char *rx_addr, int sz);
+/************************************************************/
+
+/*******************FUNCTION DEFINITIONS********************/
+
+/*********************** Line disc driver operations starts *****************************/
+static int rmnet_asynctty_open(struct tty_struct *tty)
+{		
+	
+	if (tty->ops->write == NULL)
+	{
+		return -EOPNOTSUPP;
+	}
+
+	if(g_rmnet_private != NULL)
+	{
+		g_rmnet_private->tty = tty;
+		tty->disc_data = g_rmnet_private;
+	}	
+	
+	return 0;
+}
+
+static int rmnet_asynctty_ioctl(struct tty_struct *tty, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	return 0;
+}
+
+/* May sleep, don't call from interrupt level or with interrupts disabled */
+static void rmnet_asynctty_receive(struct tty_struct *tty, const unsigned char *buf,
+		char *cflags, int count)
+{	
+	struct rmnet_private *p = tty->disc_data;
+	
+
+	if(p->dev)
+	{
+		ifx_netif_rx_cb(p->dev, buf, count);
+	}
+        	
+}
+
+static unsigned int rmnet_asynctty_poll(struct tty_struct *tty, struct file *file, poll_table *wait)
+{
+	
+	/* Not implemented */
+	return 0;
+}
+
+static ssize_t rmnet_asynctty_write(struct tty_struct *tty, struct file *file,
+		const unsigned char *buf, size_t count)
+{
+	
+	/* Not implemented */
+	return -EAGAIN;
+}
+
+/*Line disc info*/
+static struct tty_ldisc_ops rmnet_ldisc = {
+	.owner  = THIS_MODULE,
+	.magic	= TTY_LDISC_MAGIC,
+	.name	= "ip_ldisc",
+	.open	= rmnet_asynctty_open,
+	.write	= rmnet_asynctty_write,
+	.ioctl	= rmnet_asynctty_ioctl,
+	.poll	= rmnet_asynctty_poll,
+	.receive_buf = rmnet_asynctty_receive,
+};
+/************************ Line disc driver operations ends ******************************/
+
+
+/**************************** Net driver operations starts ******************************/
+/* Receive data from TTY and forward it to TCP/IP stack 
+    The implementation also handles partial packets.
+    Ethernet header is appended to the IP datagram before passing it to TCP/IP stack.
+*/
+void ifx_netif_rx_cb(struct net_device *dev, const unsigned char *buf, int sz)
+{
+	struct rmnet_private *p = netdev_priv(dev);
+	static struct sk_buff *skb;
+	static unsigned short ip_data_in_skb;
+	static void *ptr = NULL;
+	static unsigned short len = 0; /* IP datagram length */
+	int ver = 0;
+	unsigned short tempval;
+	static int counter;
+	
+	
+	while(sz) {
+		if (len == 0) {
+#if defined(__BIG_ENDIAN_BITFIELD)
+			ver = buf[0] & 0x0F;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+			ver = (buf[0] & 0xF0) >> 4;
+#endif
+			if (ver == RMNET_IPV4_VER) {
+				len = (buf[2]<<8)| buf[3];
+			} else if (ver == RMNET_IPV6_VER) {
+				len = IPV6_HEADER_SZ + ((buf[4]<<8)| buf[5]);
+			} else {
+				return;
+			}
+			if (len + RMNET_ETH_HDR_SIZE > RMNET_MTU_SIZE) {
+				ptr = 0;
+				sz -= len;
+				buf += len;
+				len = 0;
+				continue;
+			} else {
+			    len += RMNET_ETH_HDR_SIZE;
+				skb = dev_alloc_skb(len + NET_IP_ALIGN);
+				if (skb == NULL) {
+					/* TODO: We need to handle this case later */
+					return;
+				}
+				skb->dev = dev;
+				skb_reserve(skb, NET_IP_ALIGN);
+				ptr = skb_put(skb, len);
+				/* adding ethernet header */
+				{
+					char temp[] = {0xB6,0x91,0x24,0xa8,0x14,0x72,0xb6,0x91,0x24,
+								   0xa8,0x14,0x72,0x08,0x0};
+					struct ethhdr *eth_hdr = (struct ethhdr *) temp;
+
+					if (ver == RMNET_IPV6_VER) {
+						eth_hdr->h_proto = htons(IPV6_PROTO_TYPE);
+					}
+
+					memcpy((void *)eth_hdr->h_dest,
+						   (void*)dev->dev_addr,
+						   sizeof(eth_hdr->h_dest));
+					memcpy((void *)ptr,
+						   (void *)eth_hdr,
+						   sizeof(struct ethhdr));
+				}
+			}
+		}
+
+		tempval = (sz < (len - RMNET_ETH_HDR_SIZE - ip_data_in_skb))? sz:(len - RMNET_ETH_HDR_SIZE - ip_data_in_skb);
+		memcpy(ptr + RMNET_ETH_HDR_SIZE + ip_data_in_skb, buf, tempval);
+		ip_data_in_skb += tempval;			
+		sz -= tempval;
+		buf += tempval;
+		if (ip_data_in_skb < (len - RMNET_ETH_HDR_SIZE)) {
+			continue;
+		}
+		skb->protocol = eth_type_trans(skb, dev);
+		p->stats.rx_packets++;
+		p->stats.rx_bytes += skb->len;
+		netif_rx(skb);
+		len = 0;
+		ip_data_in_skb = 0;
+	}
+}
+
+static int rmnet_open(struct net_device *dev)
+{
+	
+	netif_start_queue(dev);
+	return 0;
+}
+
+static int rmnet_stop(struct net_device *dev)
+{
+	
+	netif_stop_queue(dev);
+	return 0;
+}
+
+/* Receive data from TCP/IP stack and forward it to TTY 
+    Ethernet header is removed before sending IP datagram to the modem.
+    IP Datagram length is appended before the IP packet as per modem requirement.
+*/
+static int rmnet_xmit(struct sk_buff *skb, struct net_device *dev)
+{	
+	struct rmnet_private *p;
+	
+	
+	if((skb==NULL)||(dev==NULL))
+	{
+		return 0;
+	}
+	
+	p = netdev_priv(dev);
+
+	if(p && p->tty)
+	{
+		//pr_info("Dest MAC Addr = %x %x %x %x %x %x\n", skb->data[0], skb->data[1], skb->data[2], skb->data[3], skb->data[4], skb->data[5]);		    
+		//pr_info("Src MAC Addr = %x %x %x %x %x %x\n", skb->data[6], skb->data[7], skb->data[8], skb->data[9], skb->data[10], skb->data[11]);
+		//pr_info("Eth Protocol type %x %x \nIP datagram start %x %x %x %x %x %x\n", skb->data[12],skb->data[13],skb->data[14],skb->data[15],skb->data[16],skb->data[17],skb->data[18],skb->data[19]);
+
+		/* 
+		IMPORTANT: IP Datagram length is appended in Network byte order, before the IP packet as per modem requirement.
+		This will not be required as and when modem starts supporting streaming data for USB HSIC/HS USB.
+		*/
+		//skb->data[12] =(skb->len - RMNET_ETH_HDR_SIZE) >> 8;
+		//skb->data[13]	= (skb->len - RMNET_ETH_HDR_SIZE) & 0xFF ;  
+
+	//	pr_info("\n=================>>>\nlength MSB = %x LSB = %x \nIP datagram start %x %x %x %x %x %x\n\n", skb->data[12],skb->data[13], skb->data[14],skb->data[15],skb->data[16],skb->data[17],skb->data[18],skb->data[19]);
+
+		set_bit(TTY_DO_WRITE_WAKEUP, &(p->tty->flags));	
+		// p->tty->ops->write(p->tty, (&skb->data[RMNET_ETH_HDR_SIZE - 2]), ((skb->len+2) - RMNET_ETH_HDR_SIZE));
+		p->tty->ops->write(p->tty, (&skb->data[RMNET_ETH_HDR_SIZE]), ((skb->len) - RMNET_ETH_HDR_SIZE));
+
+		p->stats.tx_packets++;
+		p->stats.tx_bytes += skb->len;		
+	}	
+
+	dev_kfree_skb_irq(skb);
+	return NETDEV_TX_OK;
+}
+
+static void rmnet_set_multicast_list(struct net_device *dev)
+{
+	
+	/* Not implemented */
+}
+
+static struct net_device_stats *rmnet_get_stats(struct net_device *dev)
+{	
+	struct rmnet_private *p = netdev_priv(dev);
+	
+	
+	return &p->stats;
+}
+
+static void rmnet_tx_timeout(struct net_device *dev)
+{
+	
+	/* Not implemented */
+}
+
+/* Net device info */
+static struct net_device_ops rmnet_ops = {
+	.ndo_open = rmnet_open,
+	.ndo_stop = rmnet_stop,
+	.ndo_start_xmit = rmnet_xmit,
+	.ndo_get_stats = rmnet_get_stats,
+	.ndo_set_multicast_list = rmnet_set_multicast_list,	
+	.ndo_tx_timeout = rmnet_tx_timeout,
+};
+
+static void __init rmnet_setup(struct net_device *dev)
+{
+	
+	dev->netdev_ops = &rmnet_ops;
+	dev->watchdog_timeo = 20; /* ??? */
+	ether_setup(dev);	
+	random_ether_addr(dev->dev_addr);
+}
+
+static int __init rmnet_init(void)
+{		
+	int ret;
+	struct net_device *dev;
+	struct rmnet_private *p;
+	
+
+	dev = alloc_netdev(sizeof(struct rmnet_private),
+			   "rmnet0", rmnet_setup);
+
+	if (!dev)
+		return -ENOMEM;
+
+	p = netdev_priv(dev);
+	g_rmnet_private = p;
+	p->dev = dev;
+	ret = register_netdev(dev);
+	
+	if (ret < 0) {
+		free_netdev(dev);
+		return ret;
+	}
+
+	return 0;
+}
+/***************************** Net driver operations ends *******************************/
+
+/***************************** rmnet driver entry/exit **********************************/
+static int __init rmnet_async_init(void)
+{	
+	int err = -EFAULT;
+	
+
+	/* 
+	    The N_RMNET value should not be used by any other line disc driver in the system.
+	    Refer to the list of line disciplines listed in tty.h file.
+	    The same value (as N_RMNET) should also be used by application when setting up the line disc association:
+		int fdrmnet = open("/dev/ttyACM1",  O_RDWR | O_NOCTTY | O_NONBLOCK);
+		int ldisc = N_RMNET;
+		ioctl (fdrmnet, TIOCSETD, &ldisc);
+	    In some older Linux kernels, dynamically adding new line disc driver is not allowed.
+	    In such cases,
+	       either an existing line disc number (but not used in the system) can be used, or
+	       a new one needs to be added in tty.h and the kernel needs to be rebuild.
+	*/
+	err = tty_register_ldisc(N_RMNET, &rmnet_ldisc);
+	if (err != 0)
+	{
+	}
+	rmnet_init();
+
+	
+	return err;
+}
+
+static void __exit rmnet_async_cleanup(void)
+{
+	
+	unregister_netdev(g_rmnet_private->dev);	
+	if (tty_unregister_ldisc(N_RMNET) != 0) {
+	}
+}
+
+module_init(rmnet_async_init);
+module_exit(rmnet_async_cleanup);
+/****************************************************************************************/
+
diff -ruNa TC4_Kernel_3.0/drivers/usb/class/cdc-acm.c modem/drivers/usb/class/cdc-acm.c
--- TC4_Kernel_3.0/drivers/usb/class/cdc-acm.c	2012-05-15 15:08:14.000000000 +0800
+++ modem/drivers/usb/class/cdc-acm.c	2012-07-04 15:29:45.000000000 +0800
@@ -47,13 +47,22 @@
 #include <asm/byteorder.h>
 #include <asm/unaligned.h>
 #include <linux/list.h>
+#ifdef CONFIG_HAS_WAKELOCK
+#include <linux/wakelock.h>
+#endif
+#include <linux/gpio.h>
 
 #include "cdc-acm.h"
+#include <linux/modemctl.h>
+#include <mach/modem.h>
 
 
 #define DRIVER_AUTHOR "Armin Fuerst, Pavel Machek, Johannes Erdfelt, Vojtech Pavlik, David Kubicek, Johan Hovold"
 #define DRIVER_DESC "USB Abstract Control Model driver for USB modems and ISDN adapters"
 
+
+
+
 static struct usb_driver acm_driver;
 static struct tty_driver *acm_tty_driver;
 static struct acm *acm_table[ACM_TTY_MINORS];
@@ -64,6 +73,95 @@
 
 static const struct tty_port_operations acm_port_ops = {
 };
+struct acm share_acm;
+#ifdef CONFIG_HAS_WAKELOCK
+enum {
+	ACM_WLOCK_RUNTIME,
+	ACM_WLOCK_DORMANCY,
+} ACM_WLOCK_TYPE;
+
+#define ACM_DEFAULT_WAKE_TIME (6*HZ)
+#define ACM_SUSPEND_UNLOCK_DELAY msecs_to_jiffies(200)//(5*HZ)
+
+static inline void acm_wake_lock_init(struct acm *acm)
+{
+	wake_lock_init(&acm->pm_lock, WAKE_LOCK_SUSPEND, "cdc-acm");
+	wake_lock_init(&acm->dormancy_lock, WAKE_LOCK_SUSPEND, "acm-dormancy");
+	acm->wake_time = ACM_DEFAULT_WAKE_TIME;
+}
+
+static inline void acm_wake_lock_destroy(struct acm *acm)
+{
+	wake_lock_destroy(&acm->pm_lock);
+	wake_lock_destroy(&acm->dormancy_lock);
+}
+
+static inline void _wake_lock(struct acm *acm, int type)
+{
+	if (acm->usb_connected)
+		switch (type) {
+		case ACM_WLOCK_DORMANCY:
+			wake_lock(&acm->dormancy_lock);
+			break;
+		case ACM_WLOCK_RUNTIME:
+		default:
+			wake_lock(&acm->pm_lock);
+			break;
+		}
+}
+
+static inline void _wake_unlock(struct acm *acm, int type)
+{
+	if (acm)
+		switch (type) {
+		case ACM_WLOCK_DORMANCY:
+			wake_unlock(&acm->dormancy_lock);
+			break;
+		case ACM_WLOCK_RUNTIME:
+		default:
+			wake_unlock(&acm->pm_lock);
+			break;
+		}
+}
+
+static inline void _wake_lock_timeout(struct acm *acm, int type)
+{
+	switch (type) {
+	case ACM_WLOCK_DORMANCY:
+		wake_lock_timeout(&acm->dormancy_lock, acm->wake_time);
+		break;
+	case ACM_WLOCK_RUNTIME:
+	default:
+		wake_lock_timeout(&acm->pm_lock, ACM_SUSPEND_UNLOCK_DELAY);
+	}
+}
+
+static inline void _wake_lock_settime(struct acm *acm, long time)
+{
+	if (acm)
+		acm->wake_time = time;
+}
+
+static inline long _wake_lock_gettime(struct acm *acm)
+{
+	return acm ? acm->wake_time : ACM_DEFAULT_WAKE_TIME;
+}
+#else
+#define _wake_lock_init(acm) do { } while (0)
+#define _wake_lock_destroy(acm) do { } while (0)
+#define _wake_lock(acm, type) do { } while (0)
+#define _wake_unlock(acm, type) do { } while (0)
+#define _wake_lock_timeout(acm, type) do { } while (0)
+#define _wake_lock_settime(acm, time) do { } while (0)
+#define _wake_lock_gettime(acm) (0)
+#endif
+
+#define wake_lock_pm(acm)	_wake_lock(acm, ACM_WLOCK_RUNTIME)
+#define wake_lock_data(acm)	_wake_lock(acm, ACM_WLOCK_DORMANCY)
+#define wake_unlock_pm(acm)	_wake_unlock(acm, ACM_WLOCK_RUNTIME)
+#define wake_unlock_data(acm)	_wake_unlock(acm, ACM_WLOCK_DORMANCY)
+#define wake_lock_timeout_pm(acm) _wake_lock_timeout(acm, ACM_WLOCK_RUNTIME)
+#define wake_lock_timeout_data(acm) _wake_lock_timeout(acm, ACM_WLOCK_DORMANCY)
 
 /*
  * Functions for ACM control messages.
@@ -92,6 +190,25 @@
 #define acm_send_break(acm, ms) \
 	acm_ctrl_msg(acm, USB_CDC_REQ_SEND_BREAK, ms, NULL, 0)
 
+static int acm_net_wb_alloc(struct acm *acm)
+{
+	int i, wbn;
+	struct acm_wb *wb;
+
+	wbn = 0;
+	i = 0;
+	for (;;) {
+		wb = &acm->wb[wbn];
+		if ((wb->use)&&(wb->submitted!=1)) {
+			wb->submitted = 1;
+			return wbn;
+		}
+		wbn = (wbn + 1) % ACM_NW;
+		if (++i >= ACM_NW)
+			return -1;
+	}
+}
+
 /*
  * Write buffer management.
  * All of these assume proper locks taken by the caller.
@@ -108,6 +225,7 @@
 		wb = &acm->wb[wbn];
 		if (!wb->use) {
 			wb->use = 1;
+			wb->submitted = 0;
 			return wbn;
 		}
 		wbn = (wbn + 1) % ACM_NW;
@@ -165,12 +283,160 @@
 	}
 	return rc;
 }
+static int acm_initiated_resume(struct acm *acm)
+	{
+		int err;
+		struct usb_device *udev = acm->dev;
+		struct acm *parent_acm; 
+		//printk("%s: DPM resume\n", __func__);
+		if (udev) {
+			struct device *dev = &udev->dev;
+			int spin = 10, spin2 = 30;
+			int host_wakeup_done = 0;
+			int _host_high_cnt = 0, _host_timeout_cnt = 0;
+			parent_acm = acm->parent;
+			//printk("[XJ]dev->power.runtime_status: %d\n", dev->power.runtime_status);
+	retry:
+			switch (dev->power.runtime_status) {
+			case RPM_SUSPENDED:
+				if (parent_acm->dpm_suspending || host_wakeup_done) {
+					dev_info(&udev->dev,
+						"DPM Suspending, spin:%d\n", spin2);
+					if (spin2-- == 0) {
+						dev_err(&udev->dev,
+						"dpm resume timeout\n");
+						return -ETIMEDOUT;
+					}
+					msleep(30);
+					goto retry;
+				}
+				err = mc_prepare_resume(500);
+				switch (err) {
+				case MC_SUCCESS:
+					host_wakeup_done = 1;
+					_host_timeout_cnt = 0;
+					_host_high_cnt = 0;
+					goto retry; /*wait until RPM_ACTIVE states*/
+	
+				case MC_HOST_TIMEOUT:
+					_host_timeout_cnt++;
+					break;
+	
+				case MC_HOST_HIGH:
+					_host_high_cnt++;
+					break;
+				case MC_CP_RESET:
+					printk("CP reset,skip wakeup CP!\n");
+					return -EIO;
+				}
+				if (spin2-- == 0) {
+					dev_info(&udev->dev,
+					"svn initiated resume, RPM_SUSPEND timeout\n");
+					crash_event(0);   //MODEM_EVENT_RESET
+					return -ETIMEDOUT;
+				}
+				msleep(20);
+				goto retry;
+	
+			case RPM_SUSPENDING:
+				dev_info(&udev->dev,
+					"RPM Suspending, spin:%d\n", spin);
+				if (spin-- == 0) {
+					dev_err(&udev->dev,
+					"Modem suspending timeout\n");
+					return -ETIMEDOUT;
+				}
+				msleep(100);
+				goto retry;
+			case RPM_RESUMING:
+				dev_info(&udev->dev,
+					"RPM Resuming, spin:%d\n", spin2);
+				if (spin2-- == 0) {
+					dev_err(&udev->dev,
+					"Modem resume timeout\n");
+					return -ETIMEDOUT;
+				}
+				msleep(50);
+				goto retry;
+			case RPM_ACTIVE:
+				dev_dbg(&udev->dev,
+					"RPM Active, spin:%d\n", spin2);			
+				break;
+			default:
+				dev_info(&udev->dev,
+					"RPM EIO, spin:%d\n", spin2);				
+				return -EIO;
+			}
+		}
+		return 0;
+	}
+
+
+static void acm_net_write_worker(struct work_struct *work)
+
+{
+	struct acm *acm =
+		container_of(work, struct acm, net_write_worker);
+	int wbn;
+	while(1){
+		wbn = acm_net_wb_alloc(acm);
+	//	printk("--- net 222 alloc wbn=%d\n",wbn);
+		if(wbn == -1)
+			break;
+		unsigned long flags;
+		struct acm_wb *wb = &acm->wb[wbn];
+		int rc;
+		
+		acm_initiated_resume(acm);
+
+		spin_lock_irqsave(&acm->write_lock, flags);
+		if (!acm->dev) {
+			wb->use = 0;
+			spin_unlock_irqrestore(&acm->write_lock, flags);
+			continue;
+			//goto dirrect_end;
+	//		return -ENODEV;
+		}
+
+		dev_vdbg(&acm->data->dev, "%s - susp_count %d\n", __func__,
+								acm->susp_count);
+		usb_autopm_get_interface_async(acm->control);
+		if (acm->susp_count) {
+			if (!acm->delayed_wb)
+				acm->delayed_wb = wb;
+			else
+				usb_autopm_put_interface_async(acm->control);
+			spin_unlock_irqrestore(&acm->write_lock, flags);
+			continue;
+	//		goto dirrect_end;
+	//		return 0;	/* A white lie */
+		}
+		usb_mark_last_busy(acm->dev);
+
+		rc = acm_start_wb(acm, wb);
+	//	printk("--- wb->use =%d\n",wb->use);
+	//	wb->use = 0;
+		spin_unlock_irqrestore(&acm->write_lock, flags);
+		wake_lock_timeout_data(acm->parent);
+
+	}
+
+
+//dirrect_end:
+//	return rc;
+//	if(0){
+
+//	}
+
+}
 
 static int acm_write_start(struct acm *acm, int wbn)
 {
 	unsigned long flags;
 	struct acm_wb *wb = &acm->wb[wbn];
 	int rc;
+	
+	acm_initiated_resume(acm);
 
 	spin_lock_irqsave(&acm->write_lock, flags);
 	if (!acm->dev) {
@@ -194,6 +460,7 @@
 
 	rc = acm_start_wb(acm, wb);
 	spin_unlock_irqrestore(&acm->write_lock, flags);
+	wake_lock_timeout_data(acm->parent);
 
 	return rc;
 
@@ -283,7 +550,7 @@
 		tty = tty_port_tty_get(&acm->port);
 		newctrl = get_unaligned_le16(data);
 
-		if (tty) {
+		if (tty && ((acm==acm_table[0])||(acm == acm_table[3]))) {
 			if (!acm->clocal &&
 				(acm->ctrlin & ~newctrl & ACM_CTRL_DCD)) {
 				dev_dbg(&acm->control->dev,
@@ -332,6 +599,7 @@
 		return 0;
 
 	dev_vdbg(&acm->data->dev, "%s - urb %d\n", __func__, index);
+//	dev_err(&acm->data->dev, "---%s(): - urb %d\n", __func__, index);
 
 	res = usb_submit_urb(acm->read_urbs[index], mem_flags);
 	if (res) {
@@ -386,6 +654,8 @@
 
 	dev_vdbg(&acm->data->dev, "%s - urb %d, len %d\n", __func__,
 					rb->index, urb->actual_length);
+//	dev_err(&acm->data->dev, "---%s(): - urb %d, len %d\n", __func__,
+//					rb->index, urb->actual_length);
 	set_bit(rb->index, &acm->read_urbs_free);
 
 	if (!acm->dev) {
@@ -393,6 +663,7 @@
 		return;
 	}
 	usb_mark_last_busy(acm->dev);
+	wake_lock_timeout_data(acm->parent);
 
 	if (urb->status) {
 		dev_dbg(&acm->data->dev, "%s - non-zero urb status: %d\n",
@@ -467,6 +738,8 @@
 		rv = 0;
 
 	dev_dbg(&acm->control->dev, "%s\n", __func__);
+	
+	acm_initiated_resume(acm);
 
 	set_bit(TTY_NO_WRITE_SPLIT, &tty->flags);
 
@@ -476,7 +749,7 @@
 	if (usb_autopm_get_interface(acm->control) < 0)
 		goto early_bail;
 	else
-		acm->control->needs_remote_wakeup = 1;
+		acm->control->needs_remote_wakeup = 0;//1;
 
 	mutex_lock(&acm->mutex);
 	if (acm->port.count++) {
@@ -524,7 +797,10 @@
 	int i;
 
 	tty_unregister_device(acm_tty_driver, acm->minor);
-	usb_put_intf(acm->control);
+        //avoiding ttyACM1 duplicated name error
+        printk("---%s(): acm->minor=%d\n", __func__, acm->minor);
+        acm_tty_driver->ttys[acm->minor] = NULL;
+        usb_put_intf(acm->control);
 	acm_table[acm->minor] = NULL;
 	usb_free_urb(acm->ctrlurb);
 	for (i = 0; i < ACM_NW; i++)
@@ -586,6 +862,7 @@
 	mutex_unlock(&open_mutex);
 }
 
+
 static int acm_tty_write(struct tty_struct *tty,
 					const unsigned char *buf, int count)
 {
@@ -614,9 +891,28 @@
 	dev_vdbg(&acm->data->dev, "%s - write %d\n", __func__, count);
 	memcpy(wb->buf, buf, count);
 	wb->len = count;
+		if(count%512 == 0){
+			wb->urb->transfer_flags |= URB_ZERO_PACKET;
+		}
+		else
+			wb->urb->transfer_flags &= ~URB_ZERO_PACKET;
 	spin_unlock_irqrestore(&acm->write_lock, flags);
+	
+	wake_lock_pm(acm->parent);
+	//printk("\n--- acm=0x%x, table0=0x%x\n",acm,acm_table[0]);
+	if((acm == acm_table[0])||(acm == acm_table[3])){
+	//	printk("--- acm_tty_write(): case for tty write \n");
+		stat = acm_write_start(acm, wbn);
+	}
+	else{
+//		printk("\n--- acm_tty_write(): case for net write \n");	
+//		schedule_work(&acm->net_write_worker);
+		if(!work_pending(&acm->net_write_worker))
+			queue_work(acm->tx_workqueue, &acm->net_write_worker);
 
-	stat = acm_write_start(acm, wbn);
+	}
+	
+	
 	if (stat < 0)
 		return stat;
 	return count;
@@ -835,6 +1131,26 @@
 	return 0;
 }
 
+static void acm_runtime_start(struct work_struct *work)
+{
+	struct acm *acm =
+		container_of(work, struct acm, pm_runtime_work.work);
+	struct device *dev, *ppdev;
+
+	dev = &acm->dev->dev;
+	if (acm->dev && dev->parent) {
+		ppdev = dev->parent->parent;
+		/*enable runtime feature - once after boot*/
+		dev_info(dev, "ACM Runtime PM Start!!\n");
+		//usb_enable_autosuspend(acm->dev);
+		//pm_runtime_allow(dev);
+		
+		pm_runtime_allow(ppdev); /*ehci*/
+	}
+}
+//extern void pm_runtime_set_autosuspend_delay(struct device *dev, int delay);
+extern struct modemctl *global_mc;
+
 static int acm_probe(struct usb_interface *intf,
 		     const struct usb_device_id *id)
 {
@@ -848,6 +1164,7 @@
 	struct usb_endpoint_descriptor *epread = NULL;
 	struct usb_endpoint_descriptor *epwrite = NULL;
 	struct usb_device *usb_dev = interface_to_usbdev(intf);
+	struct usb_device *root_usbdev= to_usb_device(intf->dev.parent->parent);
 	struct acm *acm;
 	int minor;
 	int ctrlsize, readsize;
@@ -860,7 +1177,8 @@
 	int num_rx_buf;
 	int i;
 	int combined_interfaces = 0;
-
+	
+	//dump_stack();
 	/* normal quirks */
 	quirks = (unsigned long)id->driver_info;
 	num_rx_buf = (quirks == SINGLE_RX_URB) ? 1 : ACM_NR;
@@ -1062,9 +1380,9 @@
 
 	ctrlsize = le16_to_cpu(epctrl->wMaxPacketSize);
 	readsize = le16_to_cpu(epread->wMaxPacketSize) *
-				(quirks == SINGLE_RX_URB ? 1 : 2);
+				(quirks == SINGLE_RX_URB ? 1 : 64);
 	acm->combined_interfaces = combined_interfaces;
-	acm->writesize = le16_to_cpu(epwrite->wMaxPacketSize) * 20;
+	acm->writesize = le16_to_cpu(epwrite->wMaxPacketSize) * 64;
 	acm->control = control_interface;
 	acm->data = data_interface;
 	acm->minor = minor;
@@ -1076,6 +1394,8 @@
 	acm->readsize = readsize;
 	acm->rx_buflimit = num_rx_buf;
 	INIT_WORK(&acm->work, acm_softint);
+	INIT_WORK(&acm->net_write_worker, acm_net_write_worker);
+	acm->tx_workqueue = create_singlethread_workqueue("acm_txq");
 	spin_lock_init(&acm->write_lock);
 	spin_lock_init(&acm->read_lock);
 	mutex_init(&acm->mutex);
@@ -1086,6 +1406,10 @@
 	tty_port_init(&acm->port);
 	acm->port.ops = &acm_port_ops;
 
+	pm_runtime_set_autosuspend_delay(&usb_dev->dev,200);
+//	usb_dev->autosuspend_delay = msecs_to_jiffies(20000);      /* 200ms */
+//	root_usbdev->autosuspend_delay = msecs_to_jiffies(20000); // 400 is temporary value
+
 	buf = usb_alloc_coherent(usb_dev, ctrlsize, GFP_KERNEL, &acm->ctrl_dma);
 	if (!buf) {
 		dev_err(&intf->dev, "out of memory (ctrl buffer alloc)\n");
@@ -1218,8 +1542,28 @@
 	usb_get_intf(control_interface);
 	tty_register_device(acm_tty_driver, minor, &control_interface->dev);
 
+	usb_enable_autosuspend(acm->dev);
+	INIT_DELAYED_WORK(&acm->pm_runtime_work, acm_runtime_start);
+	share_acm.usb_connected = 1;
+	acm->parent = &share_acm;
+
 	acm_table[minor] = acm;
+	
+	if(minor==ACM_TTY_MINORS-1){
+		schedule_delayed_work(&acm->pm_runtime_work, msecs_to_jiffies(500));
+		if((global_mc)&&(global_mc->boot_done==1)){
+			if(global_mc->gCdcAcmSimpleEnumeratinoState==1){
+				printk("---%s(): not the first time cdc acm simple enum over\n",__FUNCTION__);
+				printk("---%s(): report for the reset and enumeration over\n",__FUNCTION__);
+				crash_event(4);		//MODEM_EVENT_RESET_DONE   xujie		
+			}
+			else{
+				global_mc->gCdcAcmSimpleEnumeratinoState=1;
+				printk("---%s(): the first time cdc acm simple enum over\n",__FUNCTION__);
+			}
 
+		}		
+	}
 	return 0;
 alloc_fail7:
 	for (i = 0; i < ACM_NW; i++)
@@ -1259,7 +1603,7 @@
 	struct acm *acm = usb_get_intfdata(intf);
 	struct usb_device *usb_dev = interface_to_usbdev(intf);
 	struct tty_struct *tty;
-
+	//printk("\n\n &&&&& acm_disconnect interface &&&&&\n\n");
 	/* sibling interface is already cleaning up */
 	if (!acm)
 		return;
@@ -1286,6 +1630,13 @@
 	if (!acm->combined_interfaces)
 		usb_driver_release_interface(&acm_driver, intf == acm->control ?
 					acm->data : acm->control);
+	
+	wake_unlock_pm(acm->parent);
+	acm_table[acm->minor] = NULL;
+	share_acm.usb_connected = 0;
+	share_acm.resume_debug = 0;
+	share_acm.dpm_suspending = 0;
+	share_acm.skip_hostwakeup = 0;
 
 	if (acm->port.count == 0) {
 		acm_tty_unregister(acm);
@@ -1306,6 +1657,14 @@
 {
 	struct acm *acm = usb_get_intfdata(intf);
 	int cnt;
+        
+	if(acm->suspended==1)
+		return 0;
+	
+	//gpio_set_value(GPIO_XUJIE_MONITOR, 0);    //xujie test monitor
+	//gpio_set_value(GPIO_XUJIE_MONITOR, 1);
+	acm->suspended=1;
+	wake_lock_timeout_pm(acm->parent);	
 
 	if (message.event & PM_EVENT_AUTO) {
 		int b;
@@ -1335,6 +1694,7 @@
 		stop_data_traffic(acm);
 
 	mutex_unlock(&acm->mutex);
+	//gpio_set_value(GPIO_XUJIE_MONITOR, 0);
 	return 0;
 }
 
@@ -1345,6 +1705,11 @@
 	int rv = 0;
 	int cnt;
 
+	if (!acm->suspended)
+		return 0;
+
+	acm->suspended=0;
+	wake_lock_pm(acm->parent);
 	spin_lock_irq(&acm->read_lock);
 	acm->susp_count -= 1;
 	cnt = acm->susp_count;
@@ -1391,8 +1756,8 @@
 	if (acm->port.count) {
 		tty = tty_port_tty_get(&acm->port);
 		if (tty) {
-			tty_hangup(tty);
-			tty_kref_put(tty);
+		//	tty_hangup(tty);
+		//	tty_kref_put(tty);
 		}
 	}
 	mutex_unlock(&acm->mutex);
@@ -1467,16 +1832,6 @@
 	},
 	{ USB_DEVICE(0x22b8, 0x6425), /* Motorola MOTOMAGX phones */
 	},
-	/* Motorola H24 HSPA module: */
-	{ USB_DEVICE(0x22b8, 0x2d91) }, /* modem                                */
-	{ USB_DEVICE(0x22b8, 0x2d92) }, /* modem           + diagnostics        */
-	{ USB_DEVICE(0x22b8, 0x2d93) }, /* modem + AT port                      */
-	{ USB_DEVICE(0x22b8, 0x2d95) }, /* modem + AT port + diagnostics        */
-	{ USB_DEVICE(0x22b8, 0x2d96) }, /* modem                         + NMEA */
-	{ USB_DEVICE(0x22b8, 0x2d97) }, /* modem           + diagnostics + NMEA */
-	{ USB_DEVICE(0x22b8, 0x2d99) }, /* modem + AT port               + NMEA */
-	{ USB_DEVICE(0x22b8, 0x2d9a) }, /* modem + AT port + diagnostics + NMEA */
-
 	{ USB_DEVICE(0x0572, 0x1329), /* Hummingbird huc56s (Conexant) */
 	.driver_info = NO_UNION_NORMAL, /* union descriptor misplaced on
 					   data interface instead of
@@ -1554,11 +1909,21 @@
 	{ NOKIA_PCSUITE_ACM_INFO(0x0335), }, /* Nokia E7 */
 	{ NOKIA_PCSUITE_ACM_INFO(0x03cd), }, /* Nokia C7 */
 	{ SAMSUNG_PCSUITE_ACM_INFO(0x6651), }, /* Samsung GTi8510 (INNOV8) */
-#if 1//shengliang
+#if 0//shengliang
 	{ INTEL_BOOTROM_ACM_INFO(0x0041),},/*intel xmm6260 bootrom hsic device*/
-	{ INTEL_PCSUITE_ACM_INFO(0x0020),},/*intel xmm6260 main hsic device*/
+	{ INTEL_PCSUITE_ACM_INFO(0x0020),
+		.driver_info = NO_UNION_NORMAL,/*wjp only bind driver for hisc0*/
+		},/*intel xmm6260 main hsic device*/
 #endif
-
+//wjp
+	{ //USB_DEVICE_AND_INTERFACE_INFO(0x01519, 0x0020, USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM, USB_CDC_ACM_PROTO_VENDOR),
+			.match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS,
+			.idVendor = 0x01519,
+			.idProduct = 0x0020,
+			.bInterfaceClass = USB_CLASS_COMM, 
+			.bInterfaceSubClass = USB_CDC_SUBCLASS_ACM, 
+//			.driver_info = NO_UNION_NORMAL /* has no union descriptor */
+		},
 	/* Support for Owen devices */
 	{ USB_DEVICE(0x03eb, 0x0030), }, /* Owen SI30 */
 
@@ -1631,6 +1996,99 @@
 	.tiocmget =		acm_tty_tiocmget,
 	.tiocmset =		acm_tty_tiocmset,
 };
+#define ACM_CONNECTED(acm)	(acm && acm->dev)
+#ifdef CONFIG_PM_RUNTIME
+int acm_request_resume(void)
+{
+	struct acm *acm=acm_table[0];
+	struct acm *parent_acm;
+	struct device *dev;
+	int err=0;
+
+	if (!ACM_CONNECTED(acm))
+		return 0;
+
+	parent_acm = acm->parent;
+	dev = &acm->dev->dev;
+
+	if (parent_acm->dpm_suspending) {
+		parent_acm->skip_hostwakeup = 1;
+		dev_dbg(dev,  "%s: suspending skip host wakeup\n",
+			__func__);
+		return 0;
+	}
+	
+	usb_mark_last_busy(acm->dev);
+
+	if (parent_acm->resume_debug >= 1) {
+		dev_dbg(dev,  "%s: resumeing, return\n", __func__);
+		return 0;
+	}
+
+	if (dev->power.status != DPM_OFF) {
+		wake_lock_pm(parent_acm);
+		dev_info(dev, "%s:run time resume\n", __func__);
+		parent_acm->resume_debug = 1;
+		err = pm_runtime_resume(dev);
+		if (!err && dev->power.timer_expires == 0
+			&& dev->power.request_pending == false) {
+			dev_dbg(dev, "%s:run time idle\n", __func__);
+			pm_runtime_idle(dev);
+		}
+		parent_acm->resume_debug = 0;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(acm_request_resume);
+#endif
+
+
+
+/*check the acm interface driver status after resume*/
+static void acm_post_resume_work(struct work_struct *work)
+{
+	struct acm *acm=acm_table[0];
+	struct acm *parent_acm =
+		container_of(work, struct acm, post_resume_work);
+	struct device *dev;
+	int spin = 10;
+	int err;
+
+	if (!ACM_CONNECTED(acm))
+		return;
+	dev = &acm->dev->dev;
+	if (parent_acm->skip_hostwakeup && smm6260_is_host_wakeup()) {
+		dev_info(dev,
+			"post resume host skip=%d, host gpio=%d, rpm_stat=%d",
+			parent_acm->skip_hostwakeup, smm6260_is_host_wakeup(),
+			dev->power.runtime_status);
+retry:
+		switch (dev->power.runtime_status) {
+		case RPM_SUSPENDED:
+			parent_acm->resume_debug = 1;
+			err = pm_runtime_resume(dev);
+			if (!err && dev->power.timer_expires == 0
+				&& dev->power.request_pending == false) {
+				dev_dbg(dev, "%s:run time idle\n",  __func__);
+				pm_runtime_idle(dev);
+			}
+			parent_acm->resume_debug = 0;
+			break;
+		case RPM_SUSPENDING:
+			if (spin--) {
+				dev_err(dev, "usbsvn suspending when resum spin=%d\n", spin);
+				msleep(20);
+				goto retry;
+			}
+		case RPM_RESUMING:
+		case RPM_ACTIVE:
+			break;
+		}
+		parent_acm->skip_hostwakeup = 0;
+	}
+}
+
 
 /*
  * Init / exit.
@@ -1660,6 +2118,15 @@
 		put_tty_driver(acm_tty_driver);
 		return retval;
 	}
+#ifdef CONFIG_HAS_WAKELOCK	
+	acm_wake_lock_init(&share_acm);
+#endif
+	share_acm.resume_debug = 0;
+	share_acm.dpm_suspending = 0;
+	share_acm.skip_hostwakeup = 0;
+	share_acm.usb_connected = 0;
+	share_acm.parent = NULL;
+	INIT_WORK(&share_acm.post_resume_work, acm_post_resume_work);
 
 	retval = usb_register(&acm_driver);
 	if (retval) {
@@ -1678,6 +2145,10 @@
 	usb_deregister(&acm_driver);
 	tty_unregister_driver(acm_tty_driver);
 	put_tty_driver(acm_tty_driver);
+	
+	wake_unlock_pm(&share_acm);
+	acm_wake_lock_destroy(&share_acm);	
+
 }
 
 module_init(acm_init);
diff -ruNa TC4_Kernel_3.0/drivers/usb/class/cdc-acm.h modem/drivers/usb/class/cdc-acm.h
--- TC4_Kernel_3.0/drivers/usb/class/cdc-acm.h	2012-05-15 15:08:14.000000000 +0800
+++ modem/drivers/usb/class/cdc-acm.h	2012-06-07 19:58:14.000000000 +0800
@@ -19,7 +19,7 @@
  */
 
 #define ACM_TTY_MAJOR		166
-#define ACM_TTY_MINORS		32
+#define ACM_TTY_MINORS		4//32
 
 /*
  * Requests.
@@ -60,13 +60,14 @@
  * powers of 2.
  */
 #define ACM_NW  16
-#define ACM_NR  16
+#define ACM_NR  1//16
 
 struct acm_wb {
 	unsigned char *buf;
 	dma_addr_t dmah;
 	int len;
 	int use;
+	int submitted;
 	struct urb		*urb;
 	struct acm		*instance;
 };
@@ -80,6 +81,7 @@
 };
 
 struct acm {
+	struct acm *parent;	
 	struct usb_device *dev;				/* the corresponding usb device */
 	struct usb_interface *control;			/* control interface */
 	struct usb_interface *data;			/* data interface */
@@ -100,9 +102,12 @@
 	int write_used;					/* number of non-empty write buffers */
 	int transmitting;
 	spinlock_t write_lock;
+	struct delayed_work	pm_runtime_work;/*work to enable runtime pm*/
 	struct mutex mutex;
 	struct usb_cdc_line_coding line;		/* bits, stop, parity */
 	struct work_struct work;			/* work queue entry for line discipline waking up */
+	unsigned int  dpm_suspending;
+	unsigned int  suspended;
 	unsigned int ctrlin;				/* input control lines (DCD, DSR, RI, break, overruns) */
 	unsigned int ctrlout;				/* output control lines (DTR, RTS) */
 	unsigned int writesize;				/* max packet size for the output bulk endpoint */
@@ -117,6 +122,17 @@
 	unsigned int throttle_req:1;			/* throttle requested */
 	u8 bInterval;
 	struct acm_wb *delayed_wb;			/* write queued for a device about to be woken */
+	unsigned int  skip_hostwakeup;
+	unsigned int  resume_debug;
+	unsigned int  usb_connected;
+	struct work_struct post_resume_work;
+	struct work_struct net_write_worker;
+	struct workqueue_struct *tx_workqueue;
+#ifdef CONFIG_HAS_WAKELOCK
+	struct wake_lock 	pm_lock;
+	struct wake_lock 	dormancy_lock;
+	long 			wake_time;
+#endif	
 };
 
 #define CDC_DATA_INTERFACE_TYPE	0x0a
diff -ruNa TC4_Kernel_3.0/drivers/usb/host/ehci-q.c modem/drivers/usb/host/ehci-q.c
--- TC4_Kernel_3.0/drivers/usb/host/ehci-q.c	2012-05-15 15:08:14.000000000 +0800
+++ modem/drivers/usb/host/ehci-q.c	2012-06-07 19:58:14.000000000 +0800
@@ -387,9 +387,9 @@
 						QTD_CERR(token) == 0 &&
 						++qh->xacterrs < QH_XACTERR_MAX &&
 						!urb->unlinked) {
-					ehci_dbg(ehci,
-	"detected XactErr len %zu/%zu retry %d\n",
-	qtd->length - QTD_LENGTH(token), qtd->length, qh->xacterrs);
+					//ehci_dbg(ehci,                           //in order to detect reset by xujie. 2012.5.30
+	//"detected XactErr len %zu/%zu retry %d\n",
+	//qtd->length - QTD_LENGTH(token), qtd->length, qh->xacterrs);
 
 					/* reset the token in the qtd and the
 					 * qh overlay (which still contains
diff -ruNa TC4_Kernel_3.0/drivers/usb/host/ehci-s5p.c modem/drivers/usb/host/ehci-s5p.c
--- TC4_Kernel_3.0/drivers/usb/host/ehci-s5p.c	2012-05-15 15:08:14.000000000 +0800
+++ modem/drivers/usb/host/ehci-s5p.c	2012-06-07 19:58:14.000000000 +0800
@@ -26,11 +26,18 @@
 #include <mach/modem.h>
 #include <linux/regulator/consumer.h>
 #include <mach/max8997.h>
+
+#include <linux/modemctl.h>
+
+
 #endif
 #include <plat/cpu.h>
 #include <plat/ehci.h>
 #include <plat/usb-phy.h>
 #include <plat/gpio-cfg.h>
+#include <mach/regs-pmu.h>
+#include <mach/regs-usb-host.h>
+#include <mach/board_rev.h>
 
 /* For ehci on/off sysfs */
 #ifdef CONFIG_SMM6260_MODEM
@@ -99,10 +106,12 @@
 		msleep(10);
 		val32 = ehci_readl(ehci, portsc);
 	} while (++retry_cnt < 30 && !(val32 & PORT_CONNECT));
+	//if(retry_cnt >= 30)
+		//crash_event(0);  //MODEM_EVENT_RESET
 	printk("\n\n%s: retry_cnt = %d\n", __func__, retry_cnt);
 }
 
-/*
+
 static struct regulator *usb_reg_ehci_analog, *usb_reg_ehci_core ,*usb_reg_hsic;
 
 void usb_host_phy_power_init(struct platform_device *pdev)
@@ -112,7 +121,7 @@
 
 
 	if (!usb_reg_ehci_core) {
-		usb_reg_ehci_core = regulator_get(&pdev->dev, "vdd_ldo11");
+		usb_reg_ehci_core = regulator_get(&pdev->dev, "vdd10_ush");
 		if (IS_ERR(usb_reg_ehci_core)) {
 			retval = PTR_ERR(usb_reg_ehci_core);
 			dev_err(&pdev->dev, "No VDD_USB_1.0V regualtor: %d\n",
@@ -122,7 +131,7 @@
 	}
 
 	if (!usb_reg_hsic) {
-		usb_reg_hsic = regulator_get(&pdev->dev, "vdd_ldo1");
+		usb_reg_hsic = regulator_get(&pdev->dev, "vdd18_hsic");
 		if (IS_ERR(usb_reg_hsic)) {
 			retval = PTR_ERR(usb_reg_hsic);
 			dev_err(&pdev->dev, "No VDD_USB_1.8V regualtor: %d\n",
@@ -132,7 +141,7 @@
 	}
 
 	if (!usb_reg_ehci_analog) {
-		usb_reg_ehci_analog = regulator_get(&pdev->dev, "vdd_ldo8");
+		usb_reg_ehci_analog = regulator_get(&pdev->dev, "vdd33_uotg");
 		if (IS_ERR(usb_reg_ehci_analog)) {
 			retval = PTR_ERR(usb_reg_ehci_analog);
 			dev_err(&pdev->dev, "No VDD_USB_3.3V regualtor: %d\n",
@@ -180,37 +189,64 @@
 	retval = regulator_is_enabled(usb_reg_ehci_core);
 	printk(KERN_DEBUG "ehci check ldo usb_reg_ehci_core(%d)\n", retval);
 }
-*/
-void usb_host_phy_power_init(struct platform_device *pdev)
-{
-	int retval;
-
-	PMIC_Control_Set(PMIC_CONTROL_VDD10_USH,POWERON);
-	PMIC_Control_Set(PMIC_CONTROL_VDD18_HSIC,POWERON);
-	PMIC_Control_Set(PMIC_CONTROL_VDD33_UOTG,POWERON);
-
 
 
-
-	printk(KERN_DEBUG "%s: ldo on\n", __func__);
-
-
-}
-void usb_host_phy_power_off(void)
+static int usb_host_phy_power_onoff(bool enable)
 {
-	int retval;
+	int ret=0;
 
-	PMIC_Control_Set(PMIC_CONTROL_VDD33_UOTG,POWEROFF);
-	PMIC_Control_Set(PMIC_CONTROL_VDD18_HSIC,POWEROFF);
-	PMIC_Control_Set(PMIC_CONTROL_VDD10_USH,POWEROFF);
-
-	printk(KERN_DEBUG "%s: ldo off\n", __func__);
+		struct regulator *vdd18_hsic_regulator;
+		struct regulator *vdd33_uotg_regulator;
+		struct regulator *vdd10_ush_regulator;
+	
+	
+		vdd33_uotg_regulator = regulator_get(NULL, "vdd33_uotg");
+		if (IS_ERR(vdd33_uotg_regulator)) {
+			pr_err("%s: failed to get %s\n", __func__, "vdd33_uotg");
+			ret = -ENODEV;
+		}
+	
+		vdd10_ush_regulator = regulator_get(NULL, "vdd10_ush");
+		if (IS_ERR(vdd10_ush_regulator)) {
+			pr_err("%s: failed to get %s\n", __func__, "vdd10_ush");
+			ret = -ENODEV;
+		}
+	
+		vdd18_hsic_regulator = regulator_get(NULL, "vdd18_hsic");
+		if (IS_ERR(vdd18_hsic_regulator)) {
+			pr_err("%s: failed to get %s\n", __func__, "vdd18_hsic");
+			ret = -ENODEV;
+		}
+	
+		if (enable) {
+			pr_info("%s: enable LDOs\n", __func__);
+		
+			if (!regulator_is_enabled(vdd18_hsic_regulator))
+				regulator_enable(vdd18_hsic_regulator);
+		if (!regulator_is_enabled(vdd33_uotg_regulator))
+				regulator_enable(vdd33_uotg_regulator);
+			if (!regulator_is_enabled(vdd10_ush_regulator))
+				regulator_enable(vdd10_ush_regulator);
+		
+		} else{
+				pr_info("%s: disable LDOs\n", __func__);
+				regulator_force_disable(vdd18_hsic_regulator);
+				regulator_force_disable(vdd33_uotg_regulator);
+				regulator_force_disable(vdd10_ush_regulator);
+		
+		}
+	
+		regulator_put(vdd18_hsic_regulator);
+		regulator_put(vdd33_uotg_regulator);
+		regulator_put(vdd10_ush_regulator);
 
+	return ret;
 }
-
 #endif
 
 #ifdef CONFIG_PM
+extern struct modemctl *global_mc;
+
 static int s5p_ehci_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
@@ -218,6 +254,7 @@
 	struct s5p_ehci_hcd *s5p_ehci = platform_get_drvdata(pdev);
 	struct usb_hcd *hcd = s5p_ehci->hcd;
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct modemctl *mc =  global_mc;
 	unsigned long flags;
 	int rc = 0;
 
@@ -248,7 +285,8 @@
 		pdata->phy_exit(pdev, S5P_USB_PHY_HOST);
 #ifdef CONFIG_SMM6260_MODEM
 	smm6260_set_active_state(0);
-	usb_host_phy_power_off();
+    mc->in_l3_state = 1;
+	rc = usb_host_phy_power_onoff(0);
 #endif
 fail:
 	clk_disable(s5p_ehci->clk);
@@ -263,14 +301,18 @@
 	struct s5p_ehci_hcd *s5p_ehci = platform_get_drvdata(pdev);
 	struct usb_hcd *hcd = s5p_ehci->hcd;
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int rc = 0;
 #ifdef CONFIG_SMM6260_MODEM	
-	usb_host_phy_power_init(pdev);
+	rc = usb_host_phy_power_onoff(1);
 #endif
 	clk_enable(s5p_ehci->clk);
 	pm_runtime_resume(&pdev->dev);
 
 	if (pdata->phy_init)
 		pdata->phy_init(pdev, S5P_USB_PHY_HOST);
+#ifdef CONFIG_SMM6260_MODEM
+		writel(0x03C00000, hcd->regs + 0x90);
+#endif
 
 	s5p_ehci_configurate(hcd);
 
@@ -311,7 +353,7 @@
 
 	hcd->state = HC_STATE_SUSPENDED;
 
-	return 0;
+	return rc;
 }
 
 #else
@@ -333,6 +375,7 @@
 		pdata->phy_suspend(pdev, S5P_USB_PHY_HOST);
 
 #ifdef CONFIG_USB_EXYNOS_SWITCH
+	if (samsung_board_rev_is_0_0()) {
 	(void) ehci_hub_control(hcd,
 			ClearPortFeature,
 			USB_PORT_FEAT_POWER,
@@ -341,6 +384,7 @@
 	ehci_readl(ehci, &ehci->regs->command);
 
 	msleep(20);
+	}
 #endif
 	return 0;
 }
@@ -382,6 +426,7 @@
 		hcd->state = HC_STATE_SUSPENDED;
 #ifdef CONFIG_USB_EXYNOS_SWITCH
 	} else {
+		if (samsung_board_rev_is_0_0()) {
 		(void) ehci_hub_control(ehci_to_hcd(ehci),
 				SetPortFeature,
 				USB_PORT_FEAT_POWER,
@@ -389,6 +434,7 @@
 		/* Flush those writes */
 		ehci_readl(ehci, &ehci->regs->command);
 		msleep(20);
+		}
 #endif
 	}
 
@@ -515,7 +561,7 @@
 		if (pdata && pdata->phy_exit)
 			pdata->phy_exit(pdev, S5P_USB_PHY_HOST);
 #ifdef CONFIG_SMM6260_MODEM
-			smm6260_set_active_state(0);
+		smm6260_set_active_state(0);
 #endif
 	} else if (power_on) {
 		printk(KERN_DEBUG "%s: EHCI turns on\n", __func__);
@@ -630,7 +676,7 @@
 		goto fail;
 	}
 #ifdef CONFIG_SMM6260_MODEM
-	usb_host_phy_power_init(pdev);
+//lisw debug	usb_host_phy_power_init(pdev);
 #endif
 	if (pdata->phy_init)
 		pdata->phy_init(pdev, S5P_USB_PHY_HOST);
@@ -662,6 +708,7 @@
 	s5p_dev = &pdev->dev;
 #endif
 #ifdef CONFIG_USB_EXYNOS_SWITCH
+	if (samsung_board_rev_is_0_0())
 	(void) ehci_hub_control(ehci_to_hcd(ehci),
 			ClearPortFeature,
 			USB_PORT_FEAT_POWER,
@@ -674,17 +721,26 @@
 #ifdef CONFIG_GPIO_SMM6260
 	set_hsic_host_active(1);
 #endif
-#if 0 //#ifdef CONFIG_SMM6260_MODEM
+
+#ifdef CONFIG_MODEM_BOOT_IN_UBOOT
+	#ifdef CONFIG_SMM6260_MODEM
 		err = gpio_request(GPIO_ACTIVE_STATE, "ACTIVE_STATE");
 		if (err) {
 			printk(KERN_ERR "fail to request gpio %s\n", "ACTIVE_STATE");
 		} else {
 			gpio_direction_output(GPIO_ACTIVE_STATE, 1);
 			s3c_gpio_setpull(GPIO_ACTIVE_STATE, S3C_GPIO_PULL_NONE);
+			
+			gpio_set_value(GPIO_ACTIVE_STATE, 1);
+			printk("%s: AP>>CP:   ACTIVE_STATE:%d\n",__FUNCTION__,1);
+
+			gpio_free(GPIO_ACTIVE_STATE);
 		}
 
-	smm6260_set_active_state(1);
-#endif	
+	//	smm6260_set_active_state(1);
+	#endif	
+#endif
+
 	return 0;
 
 fail:
diff -ruNa TC4_Kernel_3.0/.gitignore modem/.gitignore
--- TC4_Kernel_3.0/.gitignore	2012-05-15 15:08:06.000000000 +0800
+++ modem/.gitignore	1970-01-01 08:00:00.000000000 +0800
@@ -1,86 +0,0 @@
-#
-# NOTE! Don't add files that are generated in specific
-# subdirectories here. Add them in the ".gitignore" file
-# in that subdirectory instead.
-#
-# NOTE! Please use 'git ls-files -i --exclude-standard'
-# command after changing this file, to see if there are
-# any tracked files which get ignored after the change.
-#
-# Normal rules
-#
-.*
-*.o
-*.o.*
-*.a
-*.s
-*.ko
-*.so
-*.so.dbg
-*.mod.c
-*.i
-*.lst
-*.symtypes
-*.order
-modules.builtin
-*.elf
-*.bin
-*.gz
-*.bz2
-*.lzma
-*.xz
-*.lzo
-*.patch
-*.gcno
-
-#
-# Top-level generic files
-#
-/tags
-/TAGS
-/linux
-/vmlinux
-/vmlinuz
-/System.map
-/Module.markers
-/Module.symvers
-
-#
-# git files that we don't want to ignore even it they are dot-files
-#
-!.gitignore
-!.mailmap
-
-#
-# Generated include files
-#
-include/config
-include/linux/version.h
-include/generated
-arch/*/include/generated
-
-# stgit generated dirs
-patches-*
-
-# quilt's files
-patches
-series
-
-# cscope files
-cscope.*
-ncscope.*
-
-# gnu global files
-GPATH
-GRTAGS
-GSYMS
-GTAGS
-
-*.orig
-*~
-\#*#
-*.o.cmd
-*.o
-*.ko.cmd
-*.gitignore
-
diff -ruNa TC4_Kernel_3.0/include/linux/modemctl.h modem/include/linux/modemctl.h
--- TC4_Kernel_3.0/include/linux/modemctl.h	1970-01-01 08:00:00.000000000 +0800
+++ modem/include/linux/modemctl.h	2012-06-07 19:58:14.000000000 +0800
@@ -0,0 +1,91 @@
+/*
+ * Modem control driver
+ *
+ * Copyright (C) 2010 Samsung Electronics Co.Ltd
+ * Author: Suchang Woo <suchang.woo@samsung.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifdef CONFIG_HAS_WAKELOCK
+#include <linux/wakelock.h>
+#endif
+
+#ifndef __MODEM_CONTROL_H__
+#define __MODEM_CONTROL_H__
+
+#define MC_SUCCESS 0
+#define MC_HOST_HIGH 1
+#define MC_HOST_TIMEOUT 2
+#define MC_CP_RESET 3      //xujie, CP reset happened
+
+
+#define RESET_STATE_OFFSET		1
+#define CRASH_STATE_OFFSET	2
+#define DUMP_STATE_OFFSET		3
+
+#define MODEM_POWER_MAIN_CMD		0xC0//_IOWR('M', 0, int)
+#define MODEM_POWER_FLASH_CMD		0xC1//_IOWR('M', 1, int)
+#define MODEM_POWER_OFF_CMD			0xC2//_IOWR('M', 2, int)
+#define MODEM_POWER_ON_CMD			0xC3//_IOWR('M', 3, int)
+#define MODEM_POWER_RESET_CMD		0xC4//_IOWR('M', 4, int)
+
+struct modemctl {
+	int irq[3];
+	int in_l3_state;
+	int gModemPowerState;
+	int gCdcAcmSimpleEnumeratinoState;
+	struct timer_list	reset_judge_timer;	/*for judging a modem reset event */
+	
+	unsigned gpio_phone_on;
+	unsigned gpio_phone_active;
+	unsigned gpio_pda_active;
+	unsigned gpio_cp_reset;
+	unsigned gpio_usim_boot;
+	unsigned gpio_flm_sel;
+
+	unsigned gpio_cp_req_reset;
+	unsigned gpio_ipc_slave_wakeup;
+	unsigned gpio_ipc_host_wakeup;
+	unsigned gpio_suspend_request;
+	unsigned gpio_active_state;
+	unsigned gpio_cp_reset_int;
+	struct modem_ops *ops;
+	struct regulator *vcc;
+
+	struct device *dev;
+	const struct attribute_group *group;
+
+	struct delayed_work work;
+	struct work_struct resume_work;
+	struct work_struct cpreset_work;
+	struct work_struct do_reset_work;
+	int wakeup_flag; /*flag for CP boot GPIO sync flag*/
+	wait_queue_head_t		wq;
+	
+	int cpcrash_flag;
+	int cpreset_flag;
+	int cpdump_flag;
+	int boot_done;
+	int ready_to_boot;
+	int reset_flag;
+	int reset_count;
+	struct completion *l2_done;
+	struct completion *l3_done;
+	struct completion *wait_boot_done;
+#ifdef CONFIG_HAS_WAKELOCK
+	struct wake_lock reset_lock;
+#endif
+	int debug_cnt;
+};
+
+extern struct platform_device modemctl;
+
+
+void crash_event(int type);
+extern int mc_is_suspend_request(void);
+extern int mc_prepare_resume(int);
+extern int mc_reconnect_gpio(void);
+#endif /* __MODEM_CONTROL_H__ */
diff -ruNa TC4_Kernel_3.0/kernel_readme.txt modem/kernel_readme.txt
--- TC4_Kernel_3.0/kernel_readme.txt	2012-06-15 14:25:27.000000000 +0800
+++ modem/kernel_readme.txt	2012-07-04 15:30:18.000000000 +0800
@@ -1,4 +1,8 @@
-
+2012-6-25 Zhang Dong
+       1)modified proper ON and OFF of regulator related to MIPI
+       Modified files:
+       arch/arm/mach-exynos/mach-smdk4x12.c
+       drivers/media/video/samsung/tvout/s5p_tvout.c
 
 2012-6-15 Zhang Dong
         1)delete redundant log about max8903
diff -ruNa TC4_Kernel_3.0/.mailmap modem/.mailmap
--- TC4_Kernel_3.0/.mailmap	2012-05-15 15:08:13.000000000 +0800
+++ modem/.mailmap	1970-01-01 08:00:00.000000000 +0800
@@ -1,114 +0,0 @@
-#
-# This list is used by git-shortlog to fix a few botched name translations
-# in the git archive, either because the author's full name was messed up
-# and/or not always written the same way, making contributions from the
-# same person appearing not to be so or badly displayed.
-#
-# repo-abbrev: /pub/scm/linux/kernel/git/
-#
-
-Aaron Durbin <adurbin@google.com>
-Adam Oldham <oldhamca@gmail.com>
-Adam Radford <aradford@gmail.com>
-Adrian Bunk <bunk@stusta.de>
-Alan Cox <alan@lxorguk.ukuu.org.uk>
-Alan Cox <root@hraefn.swansea.linux.org.uk>
-Aleksey Gorelov <aleksey_gorelov@phoenix.com>
-Al Viro <viro@ftp.linux.org.uk>
-Al Viro <viro@zenIV.linux.org.uk>
-Andreas Herrmann <aherrman@de.ibm.com>
-Andrew Morton <akpm@osdl.org>
-Andrew Vasquez <andrew.vasquez@qlogic.com>
-Andy Adamson <andros@citi.umich.edu>
-Archit Taneja <archit@ti.com>
-Arnaud Patard <arnaud.patard@rtp-net.org>
-Arnd Bergmann <arnd@arndb.de>
-Axel Dyks <xl@xlsigned.net>
-Axel Lin <axel.lin@gmail.com>
-Ben Gardner <bgardner@wabtec.com>
-Ben M Cahill <ben.m.cahill@intel.com>
-Bjrn Steinbrink <B.Steinbrink@gmx.de>
-Brian Avery <b.avery@hp.com>
-Brian King <brking@us.ibm.com>
-Christoph Hellwig <hch@lst.de>
-Corey Minyard <minyard@acm.org>
-Damian Hobson-Garcia <dhobsong@igel.co.jp>
-David Brownell <david-b@pacbell.net>
-David Woodhouse <dwmw2@shinybook.infradead.org>
-Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
-Domen Puncer <domen@coderock.org>
-Douglas Gilbert <dougg@torque.net>
-Ed L. Cashin <ecashin@coraid.com>
-Evgeniy Polyakov <johnpol@2ka.mipt.ru>
-Felipe W Damasio <felipewd@terra.com.br>
-Felix Kuhling <fxkuehl@gmx.de>
-Felix Moeller <felix@derklecks.de>
-Filipe Lautert <filipe@icewall.org>
-Franck Bui-Huu <vagabon.xyz@gmail.com>
-Frank Zago <fzago@systemfabricworks.com>
-Greg Kroah-Hartman <greg@echidna.(none)>
-Greg Kroah-Hartman <gregkh@suse.de>
-Greg Kroah-Hartman <greg@kroah.com>
-Henk Vergonet <Henk.Vergonet@gmail.com>
-Henrik Kretzschmar <henne@nachtwindheim.de>
-Herbert Xu <herbert@gondor.apana.org.au>
-Jacob Shin <Jacob.Shin@amd.com>
-James Bottomley <jejb@mulgrave.(none)>
-James Bottomley <jejb@titanic.il.steeleye.com>
-James E Wilson <wilson@specifix.com>
-James Ketrenos <jketreno@io.(none)>
-Jean Tourrilhes <jt@hpl.hp.com>
-Jeff Garzik <jgarzik@pretzel.yyz.us>
-Jens Axboe <axboe@suse.de>
-Jens Osterkamp <Jens.Osterkamp@de.ibm.com>
-John Stultz <johnstul@us.ibm.com>
-Juha Yrjola <at solidboot.com>
-Juha Yrjola <juha.yrjola@nokia.com>
-Juha Yrjola <juha.yrjola@solidboot.com>
-Kay Sievers <kay.sievers@vrfy.org>
-Kenneth W Chen <kenneth.w.chen@intel.com>
-Koushik <raghavendra.koushik@neterion.com>
-Leonid I Ananiev <leonid.i.ananiev@intel.com>
-Linas Vepstas <linas@austin.ibm.com>
-Mark Brown <broonie@sirena.org.uk>
-Matthieu CASTET <castet.matthieu@free.fr>
-Mayuresh Janorkar <mayur@ti.com>
-Michael Buesch <mb@bu3sch.de>
-Michael Buesch <mbuesch@freenet.de>
-Michel Dnzer <michel@tungstengraphics.com>
-Mitesh shah <mshah@teja.com>
-Morten Welinder <terra@gnome.org>
-Morten Welinder <welinder@anemone.rentec.com>
-Morten Welinder <welinder@darter.rentec.com>
-Morten Welinder <welinder@troll.com>
-Mythri P K <mythripk@ti.com>
-Nguyen Anh Quynh <aquynh@gmail.com>
-Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
-Patrick Mochel <mochel@digitalimplant.org>
-Peter A Jonsson <pj@ludd.ltu.se>
-Peter Oruba <peter@oruba.de>
-Peter Oruba <peter.oruba@amd.com>
-Praveen BP <praveenbp@ti.com>
-Rajesh Shah <rajesh.shah@intel.com>
-Ralf Baechle <ralf@linux-mips.org>
-Ralf Wildenhues <Ralf.Wildenhues@gmx.de>
-Rmi Denis-Courmont <rdenis@simphalempin.com>
-Rudolf Marek <R.Marek@sh.cvut.cz>
-Rui Saraiva <rmps@joel.ist.utl.pt>
-Sachin P Sant <ssant@in.ibm.com>
-Sam Ravnborg <sam@mars.ravnborg.org>
-Sascha Hauer <s.hauer@pengutronix.de>
-S.alar Onur <caglar@pardus.org.tr>
-Simon Kelley <simon@thekelleys.org.uk>
-Stphane Witzmann <stephane.witzmann@ubpmes.univ-bpclermont.fr>
-Stephen Hemminger <shemminger@osdl.org>
-Sumit Semwal <sumit.semwal@ti.com>
-Tejun Heo <htejun@gmail.com>
-Thomas Graf <tgraf@suug.ch>
-Tony Luck <tony.luck@intel.com>
-Tsuneo Yoshioka <Tsuneo.Yoshioka@f-secure.com>
-Uwe Kleine-Knig <ukleinek@informatik.uni-freiburg.de>
-Uwe Kleine-Knig <ukl@pengutronix.de>
-Uwe Kleine-Knig <Uwe.Kleine-Koenig@digi.com>
-Valdis Kletnieks <Valdis.Kletnieks@vt.edu>
-Takashi YOSHII <takashi.yoshii.zj@renesas.com>
diff -ruNa TC4_Kernel_3.0/sound/soc/codecs/wm8994.c modem/sound/soc/codecs/wm8994.c
--- TC4_Kernel_3.0/sound/soc/codecs/wm8994.c	2012-05-15 15:08:30.000000000 +0800
+++ modem/sound/soc/codecs/wm8994.c	2012-06-07 19:58:14.000000000 +0800
@@ -39,6 +39,11 @@
 #include "wm8994.h"
 #include "wm_hubs.h"
 
+#define TC4_CALL /* INCALL support */
+#ifdef TC4_CALL
+#include "wm8994-call.h"
+#endif
+
 #ifdef CONFIG_SND_SAMSUNG_RP
 #include "../samsung/srp-types.h"
 #endif
@@ -279,6 +284,86 @@
 	return strcmp(source->name, clk) == 0;
 }
 
+#ifdef TC4_CALL
+//0:OFF	1:SPK	2:HP	3:BT
+static short voice_path = 0;
+static const char *voice_call_path_name[] = {"OFF","SPK","HP","BT"};
+
+static const struct soc_enum tc4_voice_call_path_enum = \
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(voice_call_path_name), voice_call_path_name);
+
+static int tc4_get_voice_call_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{	
+
+	dprintk("[wenpin] %s called\n", __func__);
+  	ucontrol->value.integer.value[0] = voice_path;
+
+	return 0;
+}
+
+static int tc4_set_voice_call_path(struct snd_kcontrol *kcontrol,
+        struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip (kcontrol);
+	int user_value = ucontrol->value.integer.value[0];
+	int i;
+	
+	dprintk("[wenpin] %s called, path %d\n", __func__, user_value);
+
+	if(ARRAY_SIZE(voice_call_path_name) <= user_value)
+	{
+		printk ("%s:Invalid input %d\n", __func__, user_value);
+		return -EINVAL;
+	}
+	
+	if (user_value) {//valid incall path
+		switch (user_value) {
+		case 1:
+			cur_incall_reg = incall_spk_reg;
+			cache_size = ARRAY_SIZE(incall_spk_reg);
+			break;
+		case 2:
+			cur_incall_reg = incall_hp_reg;
+			cache_size = ARRAY_SIZE(incall_hp_reg);
+			break;
+		case 3:
+			cur_incall_reg = incall_bt_reg;
+			cache_size = ARRAY_SIZE(incall_bt_reg);
+			break;
+		default:
+			printk("[wenpin] %s error\n", __func__);
+			break;
+		}
+
+		cache_path = user_value;
+
+		for (i = 0;i < cache_size; i++) {
+			dprintk("[wenpin] save wm8994 reg, store size %d\n", cache_size);
+			cache[i].reg = cur_incall_reg[i].reg;
+			cache[i].val = wm8994_read(codec, cur_incall_reg[i].reg);
+			wm8994_write(codec, cur_incall_reg[i].reg, cur_incall_reg[i].val);
+		}
+		calling_flag = 1;
+	}
+	else {
+		if (cache_size) {
+			dprintk("[wenpin] restore wm8994 reg, cache_size %d\n", cache_size);
+			for (i = 0;i < cache_size; i++) {
+				wm8994_write(codec, cache[i].reg, cache[i].val);
+			}
+		}
+		cur_incall_reg = NULL;
+		cache_path = -1;
+		cache_size = 0;
+		calling_flag = 0;
+	}
+
+	voice_path = user_value; 
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_SND_SOC_WM8994_MEIZU
 /* 
  * Definition of the audio path
@@ -594,7 +679,113 @@
 
 	return 0;
 }
+#ifdef TC4
+static const char *sys_clk_src[] = {"AIF1CLK", "AIF2CLK"};
+static const struct soc_enum sys_clk_src_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sys_clk_src), sys_clk_src);
+static int sys_clk_get_info(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+  	ucontrol->value.integer.value[0] = wm8994_read(codec, WM8994_CLOCKING_1) & 0x1;
+
+	return 0;
+}
 
+static int sys_clk_put_info(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int user_value = ucontrol->value.integer.value[0];
+
+	if (user_value > 1 || user_value < 0) {
+		printk("Invaild value\n");
+		return -EINVAL;
+	}
+
+	if (user_value)
+		snd_soc_update_bits(codec, WM8994_CLOCKING_1,
+				    WM8994_SYSCLK_SRC_MASK, 0x0001);
+	else
+		snd_soc_update_bits(codec, WM8994_CLOCKING_1,
+				    WM8994_SYSCLK_SRC_MASK, 0x0000);
+
+	snd_soc_dapm_sync(&codec->dapm);
+
+	return 0;
+}
+
+static const char *dapm_fake_name[] = {"Fake enum"};
+static const struct soc_enum dapm_fake_enum = 
+	SOC_ENUM_SINGLE_EXT(1, dapm_fake_name);
+static int dapm_get_info(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+
+	ucontrol->value.enumerated.item[0] = 0;
+
+	return 0;
+}
+static int dapm_put_info(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	int reg = ucontrol->value.integer.value[0];
+
+	if (reg < 0)
+		return -EINVAL;
+#if 1
+	printk("[%s] [reg]0x%04x : [val]0x%04x\n", __func__, \
+			reg, wm8994_read(codec, reg));
+#else
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0204, wm8994_read(codec, 0x0204));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0211, wm8994_read(codec, 0x0211));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0310, wm8994_read(codec, 0x0310));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0208, wm8994_read(codec, 0x0208));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0312, wm8994_read(codec, 0x0312));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0311, wm8994_read(codec, 0x0311));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0601, wm8994_read(codec, 0x0601));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0602, wm8994_read(codec, 0x0602));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0036, wm8994_read(codec, 0x0036));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0024, wm8994_read(codec, 0x0024));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0610, wm8994_read(codec, 0x0610));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0611, wm8994_read(codec, 0x0611));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0612, wm8994_read(codec, 0x0612));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0613, wm8994_read(codec, 0x0613));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0502, wm8994_read(codec, 0x0502));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0503, wm8994_read(codec, 0x0503));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0022, wm8994_read(codec, 0x0022));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0023, wm8994_read(codec, 0x0023));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0026, wm8994_read(codec, 0x0026));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0027, wm8994_read(codec, 0x0027));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0025, wm8994_read(codec, 0x0025));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0028, wm8994_read(codec, 0x0028));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0029, wm8994_read(codec, 0x0029));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0621, wm8994_read(codec, 0x0621));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0604, wm8994_read(codec, 0x0604));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0605, wm8994_read(codec, 0x0605));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0018, wm8994_read(codec, 0x0018));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0029, wm8994_read(codec, 0x0029));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0603, wm8994_read(codec, 0x0603));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0500, wm8994_read(codec, 0x0500));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0501, wm8994_read(codec, 0x0501));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x003A, wm8994_read(codec, 0x003A));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0200, wm8994_read(codec, 0x0200));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0208, wm8994_read(codec, 0x0208));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0001, wm8994_read(codec, 0x0001));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0002, wm8994_read(codec, 0x0002));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0003, wm8994_read(codec, 0x0003));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0004, wm8994_read(codec, 0x0004));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0005, wm8994_read(codec, 0x0005));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0006, wm8994_read(codec, 0x0006));
+	printk("[spk incall]reg:0x%04x val:0x%04x\n", 0x0520, wm8994_read(codec, 0x0520));
+#endif
+	return 0;
+}
+#endif
 static const char *aif_chan_src_text[] = {
 	"Left", "Right"
 };
@@ -779,6 +970,22 @@
 	       eq_tlv),
 SOC_SINGLE_TLV("AIF2 EQ5 Volume", WM8994_AIF2_EQ_GAINS_2, 6, 31, 0,
 	       eq_tlv),
+
+#ifdef TC4
+#ifdef TC4_CALL
+SOC_ENUM_EXT("VOICE CALL MIX", tc4_voice_call_path_enum,\
+		tc4_get_voice_call_path, tc4_set_voice_call_path),
+#endif
+
+#ifdef CONFIG_SND_SOC_WM8994_MEIZU
+SOC_ENUM_EXT("Playback_path Selection", path_enum[0],tc4_get_playback_path, tc4_set_playback_path),
+SOC_ENUM_EXT("Capture_path Selection", path_enum[1],tc4_get_capture_path, tc4_set_capture_path),
+#endif
+/* mic bias voltage control, 1 -> 0.65avdd, 0 -> 0.9avdd */
+SOC_SINGLE("AIF2 DAC Switch", WM8994_AIF2_DAC_FILTERS_1, 9, 1, 1),
+SOC_ENUM_EXT("SYSCLK SEL", sys_clk_src_enum, sys_clk_get_info, sys_clk_put_info),
+SOC_ENUM_EXT("DAPM Debug", dapm_fake_enum, dapm_get_info, dapm_put_info),
+#endif
 };
 
 static const struct snd_kcontrol_new wm8958_snd_controls[] = {
@@ -1380,16 +1587,16 @@
 		      SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
 
 SND_SOC_DAPM_AIF_IN("AIF1DACDAT", "AIF1 Playback", 0, SND_SOC_NOPM, 0, 0),
+SND_SOC_DAPM_INPUT("AIF2DACDAT"), //wenpin.cui
 SND_SOC_DAPM_AIF_OUT("AIF1ADCDAT", "AIF1 Capture", 0, SND_SOC_NOPM, 0, 0),
-SND_SOC_DAPM_AIF_IN("AIF2DACDAT", NULL, 0, SND_SOC_NOPM, 0, 0), //wenpin.cui
-SND_SOC_DAPM_AIF_OUT("AIF2ADCDAT", NULL, 0, SND_SOC_NOPM, 0, 0), //wenpin.cui
+SND_SOC_DAPM_OUTPUT("AIF2ADCDAT"), //wenpin.cui
 
 SND_SOC_DAPM_MUX("AIF1DAC Mux", SND_SOC_NOPM, 0, 0, &aif1dac_mux),
 SND_SOC_DAPM_MUX("AIF2DAC Mux", SND_SOC_NOPM, 0, 0, &aif2dac_mux),
 SND_SOC_DAPM_MUX("AIF2ADC Mux", SND_SOC_NOPM, 0, 0, &aif2adc_mux),
 
-SND_SOC_DAPM_AIF_IN("AIF3DACDAT", NULL, 0, SND_SOC_NOPM, 0, 0), //wenpin.cui
-SND_SOC_DAPM_AIF_OUT("AIF3ADCDAT", NULL, 0, SND_SOC_NOPM, 0, 0), //wenpin.cui
+SND_SOC_DAPM_INPUT("AIF3DACDAT"), //wenpin.cui
+SND_SOC_DAPM_OUTPUT("AIF3ADCDAT"), //wenpin.cui
 
 SND_SOC_DAPM_SUPPLY("TOCLK", WM8994_CLOCKING_1, 4, 0, NULL, 0),
 
@@ -2581,6 +2788,22 @@
 	struct wm8994 *control = codec->control_data;
 	int i, ret;
 
+	printk("calling_flag = %d\n", calling_flag);  //support voice call based on AP sleep
+	if(calling_flag == 1)
+		{
+			for (i = 0;i < cache_size; i++) {
+				wm8994_write(codec, cur_incall_reg[i].reg, cur_incall_reg[i].val);
+			}
+			/*
+			wm8994_write(codec, 0x0208,  0x001F);	//aif2dspclk ena, sysdspclk ena, sysclk src: aif2
+			wm8994_write(codec, 0x0001,  0x3013);	//spkL,R ena, micb1 ena
+			wm8994_write(codec, 0x0002,  0x0240);	//mixinL ena, in1L ena
+			wm8994_write(codec, 0x0003,  0x0300);	//spkLvol, spkRvol ena
+			wm8994_write(codec, 0x0004,  0x3003);	//aif2adcL, aif2adcR ena, adcL, adcR ena
+			wm8994_write(codec, 0x0005,  0x3003);	//aif2dacL, aif2dacR ena, dacL, dacR ena
+			*/
+		}
+
 	switch (control->type) {
 	case WM8994:
 		snd_soc_update_bits(codec, WM8994_MICBIAS, WM8994_MICD_ENA, 0);
@@ -2592,6 +2815,8 @@
 	}
 
 	for (i = 0; i < ARRAY_SIZE(wm8994->fll); i++) {
+		if((i != 1)||(calling_flag != 1))    //do not close the FLL2 for voice call in AP sleep mode. xujie_2012.03.09
+			{
 		memcpy(&wm8994->fll_suspend[i], &wm8994->fll[i],
 		       sizeof(struct wm8994_fll_config));
 		ret = _wm8994_set_fll(codec, i + 1, 0, 0, 0);
@@ -2599,7 +2824,8 @@
 			dev_warn(codec->dev, "Failed to stop FLL%d: %d\n",
 				 i + 1, ret);
 	}
-
+	}
+	if(calling_flag != 1)
 	wm8994_set_bias_level(codec, SND_SOC_BIAS_OFF);
 
 	return 0;
@@ -3033,17 +3259,32 @@
 	wm8994_write(codec, WM8994_GPIO_5,  0x8100);//dacdat2
 	wm8994_write(codec, WM8994_GPIO_6,  0xA101);//gpio6
 	wm8994_write(codec, WM8994_GPIO_7,  0x0100);//adcdat2
+	/*AIF3 GPIO*/
+	/*
+	wm8994_write(codec, WM8994_GPIO_8,  0xA101);//dacdat
+	wm8994_write(codec, WM8994_GPIO_9,  0x0101);//adcdat
+	wm8994_write(codec, WM8994_GPIO_10, 0xA101);//sync
+	wm8994_write(codec, WM8994_GPIO_11, 0xA101);//clk
+	*/
 	/*AIF3 GPIO*/  //xujie GPIO config for BT 2012.2.17
 	wm8994_write(codec, WM8994_GPIO_8,  0x8100);//dacdat
 	wm8994_write(codec, WM8994_GPIO_9,  0x0100);//adcdat
 	wm8994_write(codec, WM8994_GPIO_10, 0x0100);//sync
 	wm8994_write(codec, WM8994_GPIO_11, 0x0100);//clk
+
 	/*AIF2 rate*/
 	wm8994_write(codec, WM8994_AIF2_RATE, 0x0009);//rate: 8khz, 1536
 	wm8994_write(codec, WM8994_AIF2_CONTROL_1, 0x4118);//aif2 format
 	wm8994_write(codec, WM8994_AIF2_CONTROL_2, 0x0100);//aif2 format
 
-	snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_2, 0x6000, 0x0000);
+	//snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_2, 0x6000, 0x0000);
+#ifdef TC4_CALL
+	cache_size = max(ARRAY_SIZE(incall_spk_reg), ARRAY_SIZE(incall_hp_reg));
+	cache_size = max(cache_size, ARRAY_SIZE(incall_bt_reg));
+	
+	cache = kmalloc(cache_size * sizeof(struct incall_reg), GFP_KERNEL);
+	cache_size = 0;
+#endif
 
 	return 0;
 }
diff -ruNa TC4_Kernel_3.0/sound/soc/codecs/wm8994-call.h modem/sound/soc/codecs/wm8994-call.h
--- TC4_Kernel_3.0/sound/soc/codecs/wm8994-call.h	1970-01-01 08:00:00.000000000 +0800
+++ modem/sound/soc/codecs/wm8994-call.h	2012-06-07 19:58:14.000000000 +0800
@@ -0,0 +1,130 @@
+//#define max(a, b) ((a) > (b)? (a): (b))
+
+struct incall_reg {
+	unsigned int reg;
+	unsigned int val;
+};
+
+static unsigned int cache_size = 0;
+static struct incall_reg *cache;
+static int cache_path = -1;
+static int calling_flag = 0;
+static struct incall_reg *cur_incall_reg = NULL;
+
+static struct incall_reg incall_spk_reg[] = {
+	{0x0204, 0x0019},
+	{0x0211, 0x0009},
+	{0x0310, 0x4118},
+	{0x0312, 0x0000},
+	{0x0311, 0x0100},
+	{0x0601, 0x0004},
+	{0x0602, 0x0004},
+	{0x0036, 0x0003},
+	{0x0024, 0x0011},
+	{0x0610, 0x01C0},
+	{0x0611, 0x01C0},
+	{0x0612, 0x01C0},
+	{0x0613, 0x01C0},
+	{0x0502, 0x01C0},
+	{0x0503, 0x01C0},
+	{0x0022, 0x0000},
+	{0x0023, 0x0000},
+	{0x0026, 0x017C},
+	{0x0027, 0x017C},
+	{0x0025, 0x0164},
+	{0x0028, 0x0030},
+	{0x0029, 0x0020},
+	{0x0621, 0x0000},
+	{0x0604, 0x0010},
+	{0x0605, 0x0010},
+	{0x0018, 0x010B},
+	{0x0029, 0x0030},
+	{0x0603, 0x000C},
+	{0x0500, 0x01C0},
+	{0x0501, 0x01C0},
+	{0x003A, 0x0002},
+	{0x0200, 0x0001},
+	{0x0208, 0x001F},
+	{0x0001, 0x3013},
+	{0x0002, 0x0240},
+	{0x0003, 0x0300},
+	{0x0004, 0x3003},
+	{0x0005, 0x3003},
+	{0x0006, 0x0000},
+	{0x0520, 0x0000},
+};
+static struct incall_reg incall_hp_reg[] = {
+	{0x0204, 0x0019},
+	{0x0211, 0x0009},
+	{0x0310, 0x4118},
+	{0x0208, 0x000F},
+	{0x0312, 0x0000},
+	{0x0311, 0x0100},
+	{0x002D, 0x0100},
+	{0x002E, 0x0100},
+	{0x0601, 0x0004},
+	{0x0602, 0x0004},
+	{0x0036, 0x0000},
+	{0x0610, 0x01C0},
+	{0x0611, 0x01C0},
+	{0x0612, 0x01C0},
+	{0x0613, 0x01C0},
+	{0x0502, 0x01C0},
+	{0x0503, 0x01C0},
+	{0x001C, 0x01ea},
+	{0x001D, 0x01ea},
+	{0x0020, 0x01F9},
+	{0x0021, 0x01F9},
+	{0x0025, 0x0164},
+	{0x0028, 0x0003},
+	{0x002A, 0x0020},
+	{0x0621, 0x0000},
+	{0x0604, 0x0020},
+	{0x0605, 0x0020},
+	{0x001A, 0x010B},
+	{0x002A, 0x0030},
+	{0x0603, 0x0180},
+	{0x0500, 0x01C0},
+	{0x0501, 0x01C0},
+	{0x003A, 0x0002},
+	{0x003B, 0x000D},
+	{0x003C, 0x0003},
+	{0x0200, 0x0001},
+	{0x0208, 0x001F},
+	{0x0051, 0x0005},
+	{0x0060, 0x0022},
+	{0x004C, 0x9F25},
+	{0x0055, 0x0541},
+	{0x0055, 0x0401},
+	{0x0054, 0x0303},
+	{0x0057, 0xFBFB},
+	{0x0054, 0x000F},
+	{0x0060, 0x00EE},
+	{0x0001, 0x0323},
+	{0x0002, 0x0110},
+	{0x0003, 0x0000},
+	{0x0004, 0x3003},
+	{0x0005, 0x3003},
+	{0x0006, 0x0000},
+	{0x0520, 0x0000},
+};
+
+static struct incall_reg incall_bt_reg[] = {
+	{0x0204, 0x0019},
+	{0x0211, 0x0009},
+	{0x0310, 0x4118},
+	{0x0208, 0x000F},
+	{0x0312, 0x0000},
+	{0x0311, 0x0100},
+	{0x0006, 0x0014},
+	{0x0502, 0x01C0},
+	{0x0503, 0x01C0},
+	{0x0200, 0x0001},
+	{0x0204, 0x0001},
+	{0x0001, 0x0003},
+	{0x0002, 0x0000},
+	{0x0003, 0x0000},
+	{0x0004, 0x3000},
+	{0x0005, 0x3000},
+	{0x0520, 0x0000},
+};
diff -ruNa TC4_Kernel_3.0/sound/soc/codecs/wm8994-path.c modem/sound/soc/codecs/wm8994-path.c
--- TC4_Kernel_3.0/sound/soc/codecs/wm8994-path.c	2012-05-15 15:08:30.000000000 +0800
+++ modem/sound/soc/codecs/wm8994-path.c	2012-06-07 19:58:14.000000000 +0800
@@ -244,12 +244,22 @@
 	case PLAYBACK_SPK_INCALL:
 		switch (1) {
 		default:
+			#if (1)
+			//wm8994_write(codec,	0x0244,	 0x0002);   //FLL2 control, FLL2 source clk = LRCLK2
+			wm8994_write(codec, 0x0204,  0x0019);	//AIF2CLK = FLL2, AIF2CLK enable
+			wm8994_write(codec, 0x0211,  0x0009);	//AIF2 fs = 8khz, AIF2CLK/fs = 1536
+			wm8994_write(codec, 0x0310,  0x4118);	//DSP mode A 
+			wm8994_write(codec, 0x0208,  0x000F);	//SYSCLK = AIF2CLK
+			wm8994_write(codec, 0x0312,  0x0000);	//AIF2 slave mode
+			wm8994_write(codec, 0x0311,  0x0100);	//mono 
+			#else
 			wm8994_write(codec, 0x0204,  0x0001);	//AIF2CLK = MCLK1, AIF2CLK enable
 			wm8994_write(codec, 0x0211,  0x0009);	//AIF2 fs = 8khz, AIF2CLK/fs = 1536
 			wm8994_write(codec, 0x0310,  0x4118);	//DSP mode A 
 			wm8994_write(codec, 0x0208,  0x000F);	//SYSCLK = AIF2CLK
 			wm8994_write(codec, 0x0312,  0x0000);	//AIF2 slave mode
 			wm8994_write(codec, 0x0311,  0x0100);	//mono 
+			#endif
 			//playback path
 			wm8994_write(codec, 0x0601,  0x0004);	//aif2dacL --> dac1L
 			wm8994_write(codec, 0x0602,  0x0004);	//aif2dacR --> dac1R
@@ -280,7 +290,7 @@
 			wm8994_write(codec, 0x0500,  0x01C0);	//aif2_adcL_vol: 0db
 			wm8994_write(codec, 0x0501,  0x01C0);	//aif2_adcR_vol: 0db
 			//mic
-			wm8994_write(codec, 0x003A,  0x0000);	//micb1 level
+			wm8994_write(codec, 0x003A,  0x0002);	//micb1 level
 			//clock
 			wm8994_write(codec, 0x0200,  0x0001);	//aif1clk ena
 			wm8994_write(codec, 0x0208,  0x001F);	//aif2dspclk ena, sysdspclk ena, sysclk src: aif2
@@ -299,12 +309,23 @@
 	case PLAYBACK_HP_INCALL:
 		switch (1) {
 		default:
+			
+#if (1)
+			//wm8994_write(codec,	0x0244,	 0x0002);   //FLL2 control, FLL2 source clk = LRCLK2
+			wm8994_write(codec, 0x0204,  0x0019);	//AIF2CLK = FLL2, AIF2CLK enable
+			wm8994_write(codec, 0x0211,  0x0009);	//AIF2 fs = 8khz, AIF2CLK/fs = 1536
+			wm8994_write(codec, 0x0310,  0x4118);	//DSP mode A 
+			wm8994_write(codec, 0x0208,  0x000F);	//SYSCLK = AIF2CLK
+			wm8994_write(codec, 0x0312,  0x0000);	//AIF2 slave mode
+			wm8994_write(codec, 0x0311,  0x0100);	//mono 
+#else
 			wm8994_write(codec, 0x0204,  0x0001);	//AIF2CLK = MCLK1, AIF2CLK enable, 409600
 			wm8994_write(codec, 0x0211,  0x0009);	//AIF2 fs = 8khz, AIF2CLK / fs = 1536
 			wm8994_write(codec, 0x0310,  0x4118);	//DSP mode A 
 			wm8994_write(codec, 0x0208,  0x000F);	//SYSCLK = AIF2CLK
 			wm8994_write(codec, 0x0312,  0x0000);	//AIF2 slave mode
 			wm8994_write(codec, 0x0311,  0x0100);	//mono 
+#endif
 			//playback path
 			wm8994_write(codec, 0x002D,  0x0100);	//dac1L --> hpout1Lvol
 			wm8994_write(codec, 0x002E,  0x0100);	//dac1R --> hpout1Rvol
@@ -336,7 +357,7 @@
 			wm8994_write(codec, 0x0500,  0x01C0);	//aif2_adcL_vol: 0db
 			wm8994_write(codec, 0x0501,  0x01C0);	//aif2_adcR_vol: 0db
 			//mic
-			wm8994_write(codec, 0x003A,  0x0000);	//micb1 level
+			wm8994_write(codec, 0x003A,  0x0002);	//micb1 level
 			wm8994_write(codec, 0x003B,  0x000D);	//LDO1		//test
 			wm8994_write(codec, 0x003C,  0x0003);	//LDO2		//test
 			//clock
diff -ruNa TC4_Kernel_3.0/sound/soc/samsung/smdk_wm8994.c modem/sound/soc/samsung/smdk_wm8994.c
--- TC4_Kernel_3.0/sound/soc/samsung/smdk_wm8994.c	2012-05-15 15:08:30.000000000 +0800
+++ modem/sound/soc/samsung/smdk_wm8994.c	2012-06-07 19:58:14.000000000 +0800
@@ -245,6 +245,12 @@
 	if (ret < 0)
 		return ret;
 	
+	
+	ret = snd_soc_dai_set_pll(codec_dai, WM8994_FLL2, WM8994_FLL_SRC_BCLK,     //open FLL2 for voice call when AP sleep. xujie_2012.03.09
+					139264, 12582912);                                        //source clk: 8K*17, output clk: 8k*1536
+	if (ret < 0)
+		return ret;
+	
 	return 0;
 }
 #endif /* CONFIG_SND_SAMSUNG_I2S_MASTER */
